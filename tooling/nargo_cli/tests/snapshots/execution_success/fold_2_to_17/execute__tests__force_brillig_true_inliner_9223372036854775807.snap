---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/+1bz4scRRSunp87PTuZmewmeokoCLnO7M5mE/Cw4OpN/wFBmEyyFxG8Ch7avyIgeBK8efEkgggeBS8qeA54yD+gBy+6vam38/U3X9f0ZLs2G0nB0j1dr9+vqvfVq1e9iVu2xF9b9NsJmiN/nVysTWvkNZGKhprR3G48vfb87wb0N2s0tkdy6+R/dzK70xP21aj/fs/zjOkf4xmB/6Tr+byTLfmzLXkb+N84h+ydrdO/bbe8H/r7Hr0TY2wj+n6yI/RvgG15ezurX/Z0b39m/I8j8D9t+30/Vo1GcXxtvB3YbX5uRfDzqa0HCclzrjjfHclPXdSYmCYkz/Rh/zTIP+04/pklxB/1aQv/2Fh2RJ/xsrhvAy+kb4ONSI/39j4+e81fR4JnQvcdt2oPPjP/5s9e9feMKXk78tfJBdvArY47x0CMMT5ts6oxYPJTFy8mJxADas61xBipOWfv1jkXLovX0JXHV0+8V+e6wzHacvXGqGWFOf5vNYq2hzDGZKHvWkKfnnjvyG3umxz7+NlA2McxugXPaxyXyuuUyU/d6rjEiNEt0of9wzHaE7qORB/HVU/I6Qk5LxIvm6MW7zh3ON7xvRjxnnp+LWEH6tYgerx3bhnv9uxdf1XxrubOVsB3LaGP8l2XfJdG9l1f+C4N+K4PfXaPvrNn77v6fNcV+gzEe0nJ1eTwM5aj5nAot3lWOTgXuiSnW4Mcmzs4VnXOHTUufbJju0Y7BkRzVLMd28B/QLKvxZF9Xp8Yxhmjc/6jOPxnNs5YQ7A5kOdaC3iO+Rfum+zdvFk9oE30XyRLnif+2ZBoeAwR/zHWkH7givKM/iN/jY2/14GvI1nrfPsx2brOt8dZ0Vaj/wx8+4l/pnzL6xWurS3qQ38xto1BJ7Pb/Iz+eB65p8lPSde64zIheaYP+jVvjIE7cfQ5r5HsCn3GQp/82TW3Omaon/HC2DMcUnNoTLZGmgvnOc8O6NcUMrF2z7bZfd7a9Oxzf1U5z6a59ljoo/KUDvWhz8fUh+t1Sn2In7jmoQzUHfWzNWwodLB3B4LXs+YFqv5QJV+z+RVpX1m5FmXyL6sW1SV92D+8z1X7ETX3ErrfNK+PzWvoVseb96aRah4TlYc0Xbl/G24VFxEfOE/50l8V1qjx7gZ8t+l+JPK+vvKabfIvq17Uq+hX810qdB2JPp77qZCTCjkvEi+uFyFvjslIZwXBmGwLuzeNyW/9VcUkz2V+FopJxjO1llyVWhv7rmqt7XtXn++6Qh91Dp+UXE2OWyNHzeEXsV5UpZ6T1igH58SA5JTteX+G5xivVesJRr+bLHn+4p9ZXKHuaYk8ztXYDpb3q7/GzjdUPYFrpWW+/Z1sbYItVeoJRv838PzD3w+FbMYz9CPXExCXee6r2u9VzU0ijXswNwl9cxGpNnxeT9gW+qj8HesJOGaon/EK1RNwDLbI1throjpDYZlmM9sWOkN54q9qTcSxDY232h81qQ/nbZVzK7Ve8DcLiJ9cT2gI3VE/rico/RSucG0BcawMgxjD/vLXmN9u5U3htcnqOz2vOa8JrYHKfqP/x19zf429Akoe47T6piN0hqlqfbyuKpxQ300Y/UDQY+2K5wfG2qACr2ZA9ljQDwKyUS+ufQ/ot8I7o2lmyz78ViRvLeirc53Lx7NP3zgWsCor+kaNI9JX8aUaR1UPHVAfxhBjG8Zvn/rUubLCL/M1xksIh9FWwzKVgzWBL+dgqv4Vmptq/ceY5LnZFvbVFcstwRvHrU30t7xPDXMjnb1IzB2TDaF6Xd6Os6INRn/omeZj+Tphaqg2GTpLw3jgcUC9eRzMTlwXtgM2GP1tr1yu7xsQ+3lDDML8Km8t6Kszl1QYhOdmjEF4NtMU9Bwz6swLz3rMZyOi5/jB38gLx29I9ObDTgk9ru1Ivwdj9GajqB/O6+uku4rJTfO4Mej8gRemzgxwb3mP8LIHdm0SXx9CfL0VIb747P3lWfXLs+r/81n1e4AjMc6qr9q6UajbZ0V7dyraW3Xd4DxTrRsKsxmXq57lD6kPMdswDjE7tGZVzV3bwNdqsypeeM9q+ij85/UB6e8D/n+alMtj/EeMZ/wfCz2tD2OM8ys1/phf8Xy5IehxTvD3VTiXblTgFZqrNwX9jYBs1AvfZdllOKri3nzzPPasBQzMir4JxXHeqvhSjeOI6NF3m8b9DvVhPDEm4Dy1+YvxEsJ3VX9TuR3uhe9RHOL3OBz3Ku9TtTvO+zKI+0cBeRf9RlFhAn9TWvc6wXtyxJzdCrw6AdnrMIdlK8xhXZzQ095TcW++eR5xX+c+UflSjePIreLrLvVV/XaP929Vv93DPdojinv1HV/V9b4DfPn746pnTwnpj/QYrzw3O8L2UK6h4pxj2fzUErwTt1qrMvqvvE9j5/+qVnWdbAh9i5G346xog9H/AJj6NWGq+r8p5c9nzaXKMBXXhXHABqP/xuu9rlZ1SRg0i517rMNzzgUQg/j/dKt+z8vx3SmhL1u7v4Mx4loV4iDnOComFQ4yfuLcwvznsddD/R8n1qp+JLxMwa5N4utPiK+fIsQXng+hrdbvXPRaTOValclPXVS8nDKemD683nCtajeOPrNQ3KpcA2tVal+FvEK1KrUHiDwXJoxpuB6hzBRsZtsQD9v07DfAEa5VbfpNqtrXX7V1o/CdZFa0d7eivVXXDa5VqXVDYTbjctXclWtVZbnrY8LiunLXhb8P7QUT0kfhP68PSP8E8P/fpFwe4z9iPOP/daGn2rtxfqXGX9XKjX5dvYjPilW9KMQrNFdfEfQ3A7JRL3yXZZfhqIp7rO/nrQV9sfesBQzMir4JxXHeqvhSjeOI6NF3m8Y973UxnhgTcJ7a/MV4CeE7xiDHvYpPzO1ijuvh3adr4Zmunr9hB7cW9CN91w8k4oRdWxfQ8+RwPj3Zn5/MD+YPHswWc95f5s3mUD+C/Pnh/t3F3mxxeP9gf75/Z618G9dOtuzHOD3zlf9t+QbTG7820Q99x9n3PLR3bAt5Z990BOiSkusZD/GslRWf9bJV+ma2Sm+y02xVR+vrQx9iSN62/W/0F/IyPdpEf8vbbmOyBe/Y+yMhf4vkF/QWzxDDmFdTPDP6fHxuUtyg7XXvM85kEn98xrrZ3IkRV4uDO/cXs4P55OE0/7l32XF9KvpwMT+cTu/Npg9n04N18v8DSBUUGyVWAAA=",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "global len: u32 = 2450 * 2 - 240; // for just under 2^17 gates\nfn main(x: Field) {\n    let ped_input = [x; len];\n    let mut val = poseidon::poseidon2::Poseidon2::hash(ped_input, len);\n    let z = foo(x);\n    assert(val == z);\n}\n\n#[fold]\nfn foo(x: Field) -> Field {\n    let ped_input = [x; len];\n    let mut val = poseidon::poseidon2::Poseidon2::hash(ped_input, len);\n    val\n}\n",
      "path": ""
    },
    "57": {
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
