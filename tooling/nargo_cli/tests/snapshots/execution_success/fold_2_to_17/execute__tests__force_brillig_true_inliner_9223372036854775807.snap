---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "global len: u32 = 2450 * 2 - 240; // for just under 2^17 gates\nfn main(x: Field) {\n    let ped_input = [x; len];\n    let mut val = poseidon::poseidon2::Poseidon2::hash(ped_input, len);\n    let z = foo(x);\n    assert(val == z);\n}\n\n#[fold]\nfn foo(x: Field) -> Field {\n    let ped_input = [x; len];\n    let mut val = poseidon::poseidon2::Poseidon2::hash(ped_input, len);\n    val\n}\n",
      "path": ""
    },
    "57": {
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
