---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "global len: u32 = 2450 * 2 - 240; // for just under 2^17 gates\nfn main(x: Field) {\n    let ped_input = [x; len];\n    let mut val = poseidon::poseidon2::Poseidon2::hash(ped_input, len);\n    let z = foo(x);\n    assert(val == z);\n}\n\n#[fold]\nfn foo(x: Field) -> Field {\n    let ped_input = [x; len];\n    let mut val = poseidon::poseidon2::Poseidon2::hash(ped_input, len);\n    val\n}\n",
      "path": ""
    },
    "57": {
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
