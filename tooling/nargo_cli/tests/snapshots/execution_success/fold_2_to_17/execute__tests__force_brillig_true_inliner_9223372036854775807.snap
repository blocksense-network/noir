---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "global len: u32 = 2450 * 2 - 240; // for just under 2^17 gates\nfn main(x: Field) {\n    let ped_input = [x; len];\n    let mut val = poseidon::poseidon2::Poseidon2::hash(ped_input, len);\n    let z = foo(x);\n    assert(val == z);\n}\n\n#[fold]\nfn foo(x: Field) -> Field {\n    let ped_input = [x; len];\n    let mut val = poseidon::poseidon2::Poseidon2::hash(ped_input, len);\n    val\n}\n",
      "path": ""
    },
    "57": {
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
