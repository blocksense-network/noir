---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "to_hash",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "array",
            "length": 10,
            "type": {
              "kind": "field"
            }
          }
        },
        "visibility": "private"
      },
      {
        "name": "enable",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "boolean"
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "kind": "array",
        "length": 3,
        "type": {
          "kind": "field"
        }
      },
      "visibility": "public"
    },
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "50": {
      "source": "use std::hash::poseidon2::Poseidon2;\n\nglobal NUM_HASHES: u32 = 2;\nglobal HASH_LENGTH: u32 = 10;\n\n#[no_predicates]\npub fn poseidon_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    Poseidon2::hash(inputs, inputs.len())\n}\n\nfn main(\n    to_hash: [[Field; HASH_LENGTH]; NUM_HASHES],\n    enable: [bool; NUM_HASHES],\n) -> pub [Field; NUM_HASHES + 1] {\n    let mut result = [0; NUM_HASHES + 1];\n    for i in 0..NUM_HASHES {\n        let enable = enable[i];\n        let to_hash = to_hash[i];\n        if enable {\n            result[i] = poseidon_hash(to_hash);\n        }\n    }\n\n    // We want to make sure that the function marked with `#[no_predicates]` with a numeric generic\n    // is monomorphized correctly.\n    let mut double_preimage = [0; 20];\n    for i in 0..HASH_LENGTH * 2 {\n        double_preimage[i] = to_hash[0][i % HASH_LENGTH];\n    }\n    result[NUM_HASHES] = poseidon_hash(double_preimage);\n\n    result\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
