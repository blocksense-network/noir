---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "to_hash",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "array",
            "length": 10,
            "type": {
              "kind": "field"
            }
          }
        },
        "visibility": "private"
      },
      {
        "name": "enable",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "boolean"
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "kind": "array",
        "length": 3,
        "type": {
          "kind": "field"
        }
      },
      "visibility": "public"
    },
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "50": {
      "source": "use std::hash::poseidon2::Poseidon2;\n\nglobal NUM_HASHES: u32 = 2;\nglobal HASH_LENGTH: u32 = 10;\n\n#[no_predicates]\npub fn poseidon_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    Poseidon2::hash(inputs, inputs.len())\n}\n\nfn main(\n    to_hash: [[Field; HASH_LENGTH]; NUM_HASHES],\n    enable: [bool; NUM_HASHES],\n) -> pub [Field; NUM_HASHES + 1] {\n    let mut result = [0; NUM_HASHES + 1];\n    for i in 0..NUM_HASHES {\n        let enable = enable[i];\n        let to_hash = to_hash[i];\n        if enable {\n            result[i] = poseidon_hash(to_hash);\n        }\n    }\n\n    // We want to make sure that the function marked with `#[no_predicates]` with a numeric generic\n    // is monomorphized correctly.\n    let mut double_preimage = [0; 20];\n    for i in 0..HASH_LENGTH * 2 {\n        double_preimage[i] = to_hash[0][i % HASH_LENGTH];\n    }\n    result[NUM_HASHES] = poseidon_hash(double_preimage);\n\n    result\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
