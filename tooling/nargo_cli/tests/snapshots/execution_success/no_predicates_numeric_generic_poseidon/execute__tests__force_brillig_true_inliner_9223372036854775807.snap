---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "to_hash",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "array",
            "length": 10,
            "type": {
              "kind": "field"
            }
          }
        },
        "visibility": "private"
      },
      {
        "name": "enable",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "boolean"
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "kind": "array",
        "length": 3,
        "type": {
          "kind": "field"
        }
      },
      "visibility": "public"
    },
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "50": {
      "source": "use std::hash::poseidon2::Poseidon2;\n\nglobal NUM_HASHES: u32 = 2;\nglobal HASH_LENGTH: u32 = 10;\n\n#[no_predicates]\npub fn poseidon_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    Poseidon2::hash(inputs, inputs.len())\n}\n\nfn main(\n    to_hash: [[Field; HASH_LENGTH]; NUM_HASHES],\n    enable: [bool; NUM_HASHES],\n) -> pub [Field; NUM_HASHES + 1] {\n    let mut result = [0; NUM_HASHES + 1];\n    for i in 0..NUM_HASHES {\n        let enable = enable[i];\n        let to_hash = to_hash[i];\n        if enable {\n            result[i] = poseidon_hash(to_hash);\n        }\n    }\n\n    // We want to make sure that the function marked with `#[no_predicates]` with a numeric generic\n    // is monomorphized correctly.\n    let mut double_preimage = [0; 20];\n    for i in 0..HASH_LENGTH * 2 {\n        double_preimage[i] = to_hash[0][i % HASH_LENGTH];\n    }\n    result[NUM_HASHES] = poseidon_hash(double_preimage);\n\n    result\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
