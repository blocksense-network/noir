---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "to_hash",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "array",
            "length": 10,
            "type": {
              "kind": "field"
            }
          }
        },
        "visibility": "private"
      },
      {
        "name": "enable",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "boolean"
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "kind": "array",
        "length": 3,
        "type": {
          "kind": "field"
        }
      },
      "visibility": "public"
    },
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "50": {
      "source": "use std::hash::poseidon2::Poseidon2;\n\nglobal NUM_HASHES: u32 = 2;\nglobal HASH_LENGTH: u32 = 10;\n\n#[no_predicates]\npub fn poseidon_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    Poseidon2::hash(inputs, inputs.len())\n}\n\nfn main(\n    to_hash: [[Field; HASH_LENGTH]; NUM_HASHES],\n    enable: [bool; NUM_HASHES],\n) -> pub [Field; NUM_HASHES + 1] {\n    let mut result = [0; NUM_HASHES + 1];\n    for i in 0..NUM_HASHES {\n        let enable = enable[i];\n        let to_hash = to_hash[i];\n        if enable {\n            result[i] = poseidon_hash(to_hash);\n        }\n    }\n\n    // We want to make sure that the function marked with `#[no_predicates]` with a numeric generic\n    // is monomorphized correctly.\n    let mut double_preimage = [0; 20];\n    for i in 0..HASH_LENGTH * 2 {\n        double_preimage[i] = to_hash[0][i % HASH_LENGTH];\n    }\n    result[NUM_HASHES] = poseidon_hash(double_preimage);\n\n    result\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
