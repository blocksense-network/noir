---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "to_hash",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "array",
            "length": 10,
            "type": {
              "kind": "field"
            }
          }
        },
        "visibility": "private"
      },
      {
        "name": "enable",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "boolean"
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "kind": "array",
        "length": 3,
        "type": {
          "kind": "field"
        }
      },
      "visibility": "public"
    },
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "tdnRThs5FMbxd8l1L8Y+to/dV6lQRWm6QkKAKKy0qnj39Tf2f2BXYkWN9obzC4m/zIyPJ5PJr9P387enP75e3/64+3n6/OXX6dvD9c3N9R9fb+6uLh+v7277f3+dNv1p6fQ5fDq1PEoZxUepo7S9hG2bNcwaZ7VZ06x51jLrSAuhj4+q/fWmmmbNs5ZZfdY6axs1brOGWeOsMy/OvDjz4syLMy/OvDjzrOcl1TBrH59V++uLan99VW2jpm3WMGuc1WZNs+ZZtf+b4KCCNpE3EEAEBhLowa6qYB3R7KCCNlE2EEAEBsrY8eKz1lnbqD4PkM8D5HFWm1Ubphn1DApwUEGbqNoyHf8aQAQGlKy3qBkU4KCCNtE2EEAEytHk7h2+w4FyNN97n3fEvdF3BBCBgQQyKMBBBUruMxeDcppgIIEMCnBQQZvQUohBCCACAwlkUICDCpTcmzZqUeybqlUxEIGBBDIowCfUzzEK2jATtGFJSCCDAhxU0CbU0AMBREByIbmQXEguJBeSC8lOspPsJDvJTrJaPWahAAcVtAm1+kAAEShHvaGmjTpiatqBCAwkkEEBDipoA6bujVWIwEACGRTgoII2sZ/AdyiwCTrVbkIBDnS2DUKb2M/fOwKIwEACGRTggMC9SaLQRo8ZTWI0idEkRpMYTWI0idEkRpMYTWI0idEkRpMYTWI0idEk5iQ7yU6yk+wkV5IryTSJ6Xw4kEAGBTioYLaf7Y1UhNkkRpMYTZK2DQQQgYEEMihgNkmiSRJNkkIAERhIIIMCHLTRY2lvkk0wkMBskkSTJJokxQpmtyTbQAARGEiAQH3oWxQCiMBAAhkU4KCCNpFJ1qnSTIjAQAIZFOCggjahVTBAciG5kKx+tiQEoNdkwUACGejdi6D3UgOoewcCiEA5mkp170AGytHkqnsHKmgTOjEOBBCBLkDUADoxDmRQgIMK2kBWzw/ogiYIBhLIoAAHFbQJ9fyArpSiEIEBJZuQQQEOKmgTOmcOKDkJERhIQMOzoOF9mvJ+ibsjgAg03IUEMijAQQVtQutiIIAISE4kJ5ITyYnkRLLWReq9kbUuBvRUn+6sNs6aL7XxgIEEMijAQQVtQs0/QLKTrObPmko1/0AGBTiooE1oOQwEEAHJleRKslZBVpNoFWRNt1ZB1pyq57PmVD0/kEAGhRc7qEA5fbqLen4gACW7YOPFRc0/kEEBDiqYW1jU/AMBRLAnPz9/OvHF8+vjw/ms752vvon276f3lw/n28fT59unm5tPpz8vb572F/28v7zd6+PlQ3+2z8/59nuvPfDH9c1Zev70Mnp7e2j//J6D+wf4MTy/e3z/xJvj+0fVwng3xrv5wvi6+Rxfw8p4L+y/e155/xp4/7ay/7Uc29/e3H5/e3z/ljbH929eK+NrZHxob41v7+mffo1wjI/v3//E/NeSVo5fYP+r2cf6x1be3+ux/dvK+JSO45fayng3xteV/c+B/c9xpX+zLkXH+Pzm+UNz9KEG/s+A93Rw3P6/Fu53KNqxBb6YcByEfvtmJSHqls1IiK8Wwu8k5JeEsn04oawk+JZI8Fen899JONZTvyOxNBexHtvQ7y+sJFhkTfWpyEsJwY6EuHIkczqWdVrpp3K0U1nqpn7vmoDOtpaQjgSPSwnHubnfIl/ahn6xS0K/lF1KeDkOee045PRqG8JSQqOb+k3vpdk0OxIsL82FHauqc+k49HtPLwlLxyFFrtU6l/ai1GM2y9pelJfj4NvSNnhjafcfClbODaG9zGZLKwmvLprLyhmy//J1HMdtbV1tx3k+bEsz0Y4Ll7Z0hmuRXWhp5Ri0wiQ0Lx8bX1Y+KVvlALZmH3v/f42/6I8ur64f/vGj6rOSHq4vv92c58MfT7dXr559/OueZ/hR9v7h7ur8/enhrKSXX2b7ny/WbxBatot+x7Y/6hdwdbvQL6r9Qew3nGIqeti/d3/J/f5BzuniWRv2Nw==",
  "file_map": {
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "50": {
      "source": "use std::hash::poseidon2::Poseidon2;\n\nglobal NUM_HASHES: u32 = 2;\nglobal HASH_LENGTH: u32 = 10;\n\n#[no_predicates]\npub fn poseidon_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    Poseidon2::hash(inputs, inputs.len())\n}\n\nfn main(\n    to_hash: [[Field; HASH_LENGTH]; NUM_HASHES],\n    enable: [bool; NUM_HASHES],\n) -> pub [Field; NUM_HASHES + 1] {\n    let mut result = [0; NUM_HASHES + 1];\n    for i in 0..NUM_HASHES {\n        let enable = enable[i];\n        let to_hash = to_hash[i];\n        if enable {\n            result[i] = poseidon_hash(to_hash);\n        }\n    }\n\n    // We want to make sure that the function marked with `#[no_predicates]` with a numeric generic\n    // is monomorphized correctly.\n    let mut double_preimage = [0; 20];\n    for i in 0..HASH_LENGTH * 2 {\n        double_preimage[i] = to_hash[0][i % HASH_LENGTH];\n    }\n    result[NUM_HASHES] = poseidon_hash(double_preimage);\n\n    result\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
