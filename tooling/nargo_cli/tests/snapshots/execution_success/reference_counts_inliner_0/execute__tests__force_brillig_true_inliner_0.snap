---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [],
    "return_type": null,
    "error_types": {
      "4717959987348973079": {
        "error_kind": "string",
        "string": "the original should not be mutated by copy_mut, only borrow_mut_two"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "6055981641117986912": {
        "error_kind": "string",
        "string": "borrow_mut_two should create a fresh array with an RC of 1"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12435520423058260345": {
        "error_kind": "string",
        "string": "borrow_mut_two should create a fresh array and not decrease its RC"
      },
      "15646392865860948187": {
        "error_kind": "string",
        "string": "the copy should have the expected content"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "50": {
      "source": "use std::mem::array_refcount;\n\nfn main() {\n    let mut array = [0, 1, 2];\n    assert_refcount(array, 1);\n\n    borrow(array, array_refcount(array));\n    borrow_mut(&mut array, array_refcount(array));\n    let _ = copy_mut(array, array_refcount(array));\n\n    borrow_mut_two(&mut array, &mut array, array_refcount(array));\n\n    let mut u32_array = [0, 1, 2];\n    let rc1 = array_refcount(array);\n    let rc2 = array_refcount(u32_array);\n    borrow_mut_two_separate(&mut array, &mut u32_array, rc1, rc2);\n\n    // Safety: test\n    regression_7297();\n}\n\nfn borrow(array: [Field; 3], rc_before_call: u32) {\n    assert_refcount(array, rc_before_call);\n    println(array[0]);\n}\n\nfn borrow_mut(array: &mut [Field; 3], rc_before_call: u32) {\n    // Optimization: inc_rc isn't needed since there is only one array (`array`)\n    // of the same type that `array` can be modified through\n    assert_refcount(*array, rc_before_call + 0);\n    array[0] = 3;\n    println(array[0]);\n}\n\n// Returning a copy of the array, otherwise the SSA can end up optimizing away\n// the `array_set`, with the whole body just becoming basically `println(4);`.\nfn copy_mut(mut array: [Field; 3], rc_before_call: u32) -> [Field; 3] {\n    assert_refcount(array, rc_before_call + 1);\n    array[0] = 4;\n    println(array[0]);\n    array\n}\n\n/// Borrow the same array mutably through both parameters, inc_rc is necessary here, although\n/// only one is needed to bring the rc from 1 to 2.\nfn borrow_mut_two(array1: &mut [Field; 3], array2: &mut [Field; 3], rc_before_call: u32) {\n    assert_refcount(*array1, rc_before_call + 1);\n    assert_refcount(*array2, rc_before_call + 1);\n    array1[0] = 5;\n    array2[0] = 6;\n    println(array1[0]); // array1 & 2 alias, so this should also print 6\n    println(array2[0]);\n}\n\n/// Borrow a different array: we should be able to reason that these types cannot be mutably\n/// aliased since they're different types so we don't need any inc_rc instructions.\nfn borrow_mut_two_separate(\n    array1: &mut [Field; 3],\n    array2: &mut [u32; 3],\n    rc_before_call1: u32,\n    rc_before_call2: u32,\n) {\n    assert_refcount(*array1, rc_before_call1 + 0);\n    assert_refcount(*array2, rc_before_call2 + 0);\n    array1[0] = 7;\n    array2[0] = 8;\n    println(array1[0]);\n    println(array2[0]);\n}\n\nfn assert_refcount<T>(array: [T; 3], expected: u32) {\n    let count = array_refcount(array);\n\n    // All ref counts are zero when running this as a constrained program\n    if std::runtime::is_unconstrained() {\n        if count != expected {\n            // Brillig doesn't print the actual & expected arguments on assertion failure\n            println(f\"actual = {count}, expected = {expected}\");\n        }\n        assert_eq(count, expected);\n    } else {\n        assert_eq(count, 0);\n    }\n}\n\nfn regression_7297() {\n    let mut array = [0, 1, 2];\n\n    let refcount_0 = array_refcount(array);\n    borrow_mut_two(&mut array, &mut array, refcount_0);\n    let refcount_1 = array_refcount(array);\n    let array_2 = copy_mut(array, refcount_1);\n    let refcount_2 = array_refcount(array);\n\n    // Mutation of the original could occur if we double decremented the RC and then went back to 1 by accident.\n    // For this to come out we have to run the test with `--inliner-aggressiveness -9223372036854775808`\n    assert_eq(array[0], 6, \"the original should not be mutated by copy_mut, only borrow_mut_two\");\n    assert_eq(array_2[0], 4, \"the copy should have the expected content\");\n\n    if std::runtime::is_unconstrained() {\n        // Double decrementing the RC could occur if we don't realize that array mutation made a copy,\n        // which decreases the RC of the original and sets the new one to 1.\n        // This assertion is redundant with the one following it, but it's here because `assert_eq` doesn't print\n        // what actual values that cause it to fail, so this is a way to highlight the bug about the refcount of\n        // still live arrays going to zero, without any doubt that it's just not 1, as it should be.\n        assert(\n            refcount_1 != 0,\n            \"borrow_mut_two should create a fresh array and not decrease its RC\",\n        );\n        assert_eq(refcount_1, 1, \"borrow_mut_two should create a fresh array with an RC of 1\");\n        assert_eq(refcount_2, refcount_1);\n    }\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
