---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [],
    "return_type": null,
    "error_types": {
      "4717959987348973079": {
        "error_kind": "string",
        "string": "the original should not be mutated by copy_mut, only borrow_mut_two"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "6055981641117986912": {
        "error_kind": "string",
        "string": "borrow_mut_two should create a fresh array with an RC of 1"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12435520423058260345": {
        "error_kind": "string",
        "string": "borrow_mut_two should create a fresh array and not decrease its RC"
      },
      "15646392865860948187": {
        "error_kind": "string",
        "string": "the copy should have the expected content"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "50": {
      "source": "use std::mem::array_refcount;\n\nfn main() {\n    let mut array = [0, 1, 2];\n    assert_refcount(array, 1);\n\n    borrow(array, array_refcount(array));\n    borrow_mut(&mut array, array_refcount(array));\n    let _ = copy_mut(array, array_refcount(array));\n\n    borrow_mut_two(&mut array, &mut array, array_refcount(array));\n\n    let mut u32_array = [0, 1, 2];\n    let rc1 = array_refcount(array);\n    let rc2 = array_refcount(u32_array);\n    borrow_mut_two_separate(&mut array, &mut u32_array, rc1, rc2);\n\n    // Safety: test\n    regression_7297();\n}\n\nfn borrow(array: [Field; 3], rc_before_call: u32) {\n    assert_refcount(array, rc_before_call);\n    println(array[0]);\n}\n\nfn borrow_mut(array: &mut [Field; 3], rc_before_call: u32) {\n    // Optimization: inc_rc isn't needed since there is only one array (`array`)\n    // of the same type that `array` can be modified through\n    assert_refcount(*array, rc_before_call + 0);\n    array[0] = 3;\n    println(array[0]);\n}\n\n// Returning a copy of the array, otherwise the SSA can end up optimizing away\n// the `array_set`, with the whole body just becoming basically `println(4);`.\nfn copy_mut(mut array: [Field; 3], rc_before_call: u32) -> [Field; 3] {\n    assert_refcount(array, rc_before_call + 1);\n    array[0] = 4;\n    println(array[0]);\n    array\n}\n\n/// Borrow the same array mutably through both parameters, inc_rc is necessary here, although\n/// only one is needed to bring the rc from 1 to 2.\nfn borrow_mut_two(array1: &mut [Field; 3], array2: &mut [Field; 3], rc_before_call: u32) {\n    assert_refcount(*array1, rc_before_call + 1);\n    assert_refcount(*array2, rc_before_call + 1);\n    array1[0] = 5;\n    array2[0] = 6;\n    println(array1[0]); // array1 & 2 alias, so this should also print 6\n    println(array2[0]);\n}\n\n/// Borrow a different array: we should be able to reason that these types cannot be mutably\n/// aliased since they're different types so we don't need any inc_rc instructions.\nfn borrow_mut_two_separate(\n    array1: &mut [Field; 3],\n    array2: &mut [u32; 3],\n    rc_before_call1: u32,\n    rc_before_call2: u32,\n) {\n    assert_refcount(*array1, rc_before_call1 + 0);\n    assert_refcount(*array2, rc_before_call2 + 0);\n    array1[0] = 7;\n    array2[0] = 8;\n    println(array1[0]);\n    println(array2[0]);\n}\n\nfn assert_refcount<T>(array: [T; 3], expected: u32) {\n    let count = array_refcount(array);\n\n    // All ref counts are zero when running this as a constrained program\n    if std::runtime::is_unconstrained() {\n        if count != expected {\n            // Brillig doesn't print the actual & expected arguments on assertion failure\n            println(f\"actual = {count}, expected = {expected}\");\n        }\n        assert_eq(count, expected);\n    } else {\n        assert_eq(count, 0);\n    }\n}\n\nfn regression_7297() {\n    let mut array = [0, 1, 2];\n\n    let refcount_0 = array_refcount(array);\n    borrow_mut_two(&mut array, &mut array, refcount_0);\n    let refcount_1 = array_refcount(array);\n    let array_2 = copy_mut(array, refcount_1);\n    let refcount_2 = array_refcount(array);\n\n    // Mutation of the original could occur if we double decremented the RC and then went back to 1 by accident.\n    // For this to come out we have to run the test with `--inliner-aggressiveness -9223372036854775808`\n    assert_eq(array[0], 6, \"the original should not be mutated by copy_mut, only borrow_mut_two\");\n    assert_eq(array_2[0], 4, \"the copy should have the expected content\");\n\n    if std::runtime::is_unconstrained() {\n        // Double decrementing the RC could occur if we don't realize that array mutation made a copy,\n        // which decreases the RC of the original and sets the new one to 1.\n        // This assertion is redundant with the one following it, but it's here because `assert_eq` doesn't print\n        // what actual values that cause it to fail, so this is a way to highlight the bug about the refcount of\n        // still live arrays going to zero, without any doubt that it's just not 1, as it should be.\n        assert(\n            refcount_1 != 0,\n            \"borrow_mut_two should create a fresh array and not decrease its RC\",\n        );\n        assert_eq(refcount_1, 1, \"borrow_mut_two should create a fresh array with an RC of 1\");\n        assert_eq(refcount_2, refcount_1);\n    }\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
