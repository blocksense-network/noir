---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "50": {
      "source": "struct Match {\n    succeeded: bool,\n    match_ends: u32,\n    leftover: [u8],\n}\n\nimpl Match {\n    fn empty(leftover: [u8]) -> Self {\n        Match { succeeded: true, match_ends: 0, leftover }\n    }\n}\n\nimpl Eq for Match {\n    fn eq(self, other: Self) -> bool {\n        (self.succeeded == other.succeeded) & (self.match_ends == other.match_ends)\n        // (self.leftover == other.leftover)\n    }\n}\n\n// TODO: load match into str<N> and assert that it's the correct length\n// impl<N> From<Match> for str<N>\n\ntrait Regex {\n    fn find_match(self, input: [u8]) -> Match;\n}\n\n// Empty\nimpl Regex for () {\n    fn find_match(_self: Self, input: [u8]) -> Match {\n        Match::empty(input)\n    }\n}\n\n// Exact\nimpl<let N: u32> Regex for str<N> {\n    fn find_match(self, input: [u8]) -> Match {\n        let mut leftover = input;\n        let mut matches_input = true;\n        let self_as_bytes = self.as_bytes();\n        for c in self_as_bytes {\n            if leftover.len() != 0 {\n                let (first_elem, popped_slice) = leftover.pop_front();\n                leftover = popped_slice;\n                matches_input &= first_elem == c;\n            } else {\n                matches_input = false;\n            }\n        }\n        if matches_input {\n            Match { succeeded: true, match_ends: self_as_bytes.len(), leftover }\n        } else {\n            Match { succeeded: false, match_ends: 0, leftover: input }\n        }\n    }\n}\n\n// And\nimpl<T, U> Regex for (T, U)\nwhere\n    T: Regex,\n    U: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let lhs_result = self.0.find_match(input);\n        if lhs_result.succeeded {\n            let rhs_result = self.1.find_match(lhs_result.leftover);\n            if rhs_result.succeeded {\n                Match {\n                    succeeded: true,\n                    match_ends: lhs_result.match_ends + rhs_result.match_ends,\n                    leftover: rhs_result.leftover,\n                }\n            } else {\n                Match { succeeded: false, match_ends: 0, leftover: input }\n            }\n        } else {\n            Match { succeeded: false, match_ends: 0, leftover: input }\n        }\n    }\n}\n\n// N T's: (T, (T, (T, T)))\nstruct Repeated<T, let N: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32> Regex for Repeated<T, N>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let mut result = Match::empty(input);\n        for _ in 0..N {\n            if result.succeeded {\n                let next_result = self.inner.find_match(result.leftover);\n                result = Match {\n                    succeeded: next_result.succeeded,\n                    match_ends: result.match_ends + next_result.match_ends,\n                    leftover: next_result.leftover,\n                };\n            }\n        }\n        result\n    }\n}\n\nstruct Or<T, U> {\n    lhs: T,\n    rhs: U,\n}\n\nimpl<T, U> Regex for Or<T, U>\nwhere\n    T: Regex,\n    U: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let lhs_result = self.lhs.find_match(input);\n        if lhs_result.succeeded {\n            lhs_result\n        } else {\n            self.rhs.find_match(input)\n        }\n    }\n}\n\nstruct Question<T> {\n    inner: T,\n}\n\nimpl<T> Regex for Question<T>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        Or { lhs: self.inner, rhs: () }.find_match(input)\n    }\n}\n\n// 0 <= num_matches <= N\nstruct Star<T, let N: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32> Regex for Star<T, N>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let regex: Repeated<_, N> = Repeated { inner: Question { inner: self.inner } };\n        regex.find_match(input)\n    }\n}\n\n// 0 < num_matches <= N\nstruct Plus<T, let N: u32, let N_PRED: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32, let N_PRED: u32> Regex for Plus<T, N, N_PRED>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        std::static_assert(N_PRED + 1 == N, \"N - 1 != N_PRED\");\n        let star: Star<T, N_PRED> = Star { inner: self.inner };\n        (self.inner, star).find_match(input)\n    }\n}\n\nfn main() {\n    // gr(a|e)y\n    let graey_regex = (\"gr\", (Or { lhs: \"a\", rhs: \"e\" }, \"y\"));\n\n    // NOTE: leftover ignored in Eq: Match\n    let result = graey_regex.find_match(\"gray\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 4, leftover: &[] });\n\n    // NOTE: leftover ignored in Eq: Match\n    let result = graey_regex.find_match(\"grey\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 4, leftover: &[] });\n\n    // colou?r\n    let colour_regex = (\"colo\", (Question { inner: \"u\" }, \"r\"));\n\n    let result = colour_regex.find_match(\"color\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n\n    let result = colour_regex.find_match(\"colour\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 6, leftover: &[] });\n\n    // parse the empty string three times\n    // EMPTY{3}\n    let three_empties_regex: Repeated<(), 3> = Repeated { inner: () };\n\n    let result = three_empties_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 0, leftover: &[] });\n\n    // 1{0}\n    let zero_ones_regex: Repeated<str<1>, 0> = Repeated { inner: \"1\" };\n\n    let result = zero_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 0, leftover: &[] });\n\n    // 1{1}\n    let one_ones_regex: Repeated<str<1>, 1> = Repeated { inner: \"1\" };\n\n    let result = one_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 1, leftover: &[] });\n\n    // 1{2}\n    let two_ones_regex: Repeated<str<1>, 2> = Repeated { inner: \"1\" };\n\n    let result = two_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n\n    // 1{3}\n    let three_ones_regex: Repeated<str<1>, 3> = Repeated { inner: \"1\" };\n\n    let result = three_ones_regex.find_match(\"1111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 3, leftover: &[] });\n    // TODO(https://github.com/noir-lang/noir/issues/6285): re-enable these cases and complete the test using array_regex below\n    //\n    // // 1*\n    // let ones_regex: Star<str<1>, 5> = Star { inner: \"1\" };\n    //\n    // let result = ones_regex.find_match(\"11000\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n    //\n    // let result = ones_regex.find_match(\"11\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n    //\n    // let result = ones_regex.find_match(\"111111\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    //\n    // // 1+\n    // let nonempty_ones_regex: Plus<str<1>, 5, 4> = Plus { inner: \"1\" };\n    //\n    // let result = nonempty_ones_regex.find_match(\"111111\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    // // 2^n-1 in binary: 1+0\n    // let pred_pow_two_regex = (nonempty_ones_regex, \"0\");\n    //\n    // let result = pred_pow_two_regex.find_match(\"1110\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 3, leftover: &[] });\n    //\n    // // (0|1)*\n    // let binary_regex: Star<Or<str<1>, str<1>>, 5> = Star { inner: Or { lhs: \"0\", rhs: \"1\" } };\n    //\n    // let result = binary_regex.find_match(\"110100\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    // // even numbers in binary: 1(0|1)*0\n    // let even_binary_regex = (\"1\", (binary_regex, \"0\"));\n    //\n    // let result = even_binary_regex.find_match(\"1111110\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 6, leftover: &[] });\n    // 2-letter capitalized words: [A-Z][a-z]\n    // numbers: \\d+\n    // [0-9]+\n    // words: \\w+\n    // [a-Z]+\n    // adapted URL parser: (https?:\\/\\/)?([\\da-z.\\-]+)\\.([a-z.]+)([\\/\\w \\.\\-]*)*\\/?\n    // // panics (at compile time) when input string is too short\n    // let foo_regex = (\n    //     \"colo\",\n    //     (\n    //         Question {\n    //             inner: \"u\",\n    //         },\n    //         \"r\"\n    //     )\n    // );\n    //\n    // let result = foo_regex.find_match(\"colo\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match {\n    //     succeeded: true,\n    //     match_ends: 4,\n    //     leftover: &[],\n    // });\n}\n\n// TODO\n// array_regex execution_success test:\n// use to complete test once https://github.com/noir-lang/noir/issues/6285 is resolved\n//\n// // offset <= len <= N\n// struct Bvec<T, let N: u32> {\n//     inner: [T; N],\n//\n//     // elements at indices < offset are zero\n//     offset: u32,\n//\n//     // elements at indices >= len are zero\n//     len: u32,\n// }\n//\n// impl<T, let N: u32> Eq for Bvec<T, N> where T: Eq {\n//     fn eq(self, other: Self) -> bool {\n//         (self.inner == other.inner) &\n//             (self.offset == other.offset) &\n//             (self.len == other.len)\n//     }\n// }\n//\n// impl<T, let N: u32> Bvec<T, N> {\n//     fn empty() -> Self {\n//         Self { inner: [std::mem::zeroed(); N], offset: 0, len: 0 }\n//     }\n//\n//     fn new(array: [T; N]) -> Self {\n//         let mut result = Bvec::empty();\n//         for x in array {\n//             result = result.push(x);\n//         }\n//         result\n//     }\n//\n//     // pushing when len == N is a no-op\n//     fn push(self, x: T) -> Self {\n//         let mut inner = self.inner;\n//         let mut len = self.len;\n//         if self.len < N {\n//             inner[self.len] = x;\n//             len += 1;\n//         }\n//\n//         Self { inner, offset: self.offset, len }\n//     }\n//\n//     fn pop_front(self) -> (T, Self) {\n//         assert(self.offset <= self.inner.len());\n//         assert(self.len != 0);\n//\n//         let first_elem = self.inner[self.offset];\n//         let popped_slice = Self { inner: self.inner, offset: self.offset + 1, len: self.len - 1 };\n//\n//         (first_elem, popped_slice)\n//     }\n// }\n//\n// struct Match<let N: u32> {\n//     succeeded: bool,\n//     match_ends: u32,\n//     leftover: Bvec<u8, N>,\n// }\n//\n// impl<let N: u32> Match<N> {\n//     fn empty(leftover: Bvec<u8, N>) -> Self {\n//         Match { succeeded: true, match_ends: 0, leftover }\n//     }\n//\n//     fn failed(leftover: Bvec<u8, N>) -> Self {\n//         Match { succeeded: false, match_ends: 0, leftover }\n//     }\n// }\n//\n// impl<let N: u32> Eq for Match<N> {\n//     fn eq(self, other: Self) -> bool {\n//         (self.succeeded == other.succeeded) &\n//             (self.match_ends == other.match_ends) &\n//             (self.leftover == other.leftover)\n//     }\n// }\n//\n// // TODO: load match into str<N> and assert that it's the correct length\n// // impl<N> From<Match> for str<N>\n//\n// trait Regex {\n//     // Perform a match without backtracking\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N>;\n// }\n//\n// // Empty\n// impl Regex for () {\n//     fn find_match<let N: u32>(_self: Self, input: Bvec<u8, N>) -> Match<N> {\n//         Match::empty(input)\n//     }\n// }\n//\n// // Exact\n// impl<let M: u32> Regex for str<M> {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut leftover = input;\n//         let mut matches_input = true;\n//         let self_as_bytes = self.as_bytes();\n//         for c in self_as_bytes {\n//             if leftover.len != 0 {\n//                 let (first_elem, popped_slice) = leftover.pop_front();\n//                 leftover = popped_slice;\n//                 matches_input &= first_elem == c;\n//             } else {\n//                 matches_input = false;\n//             }\n//         }\n//         if matches_input {\n//             Match {\n//                 succeeded: true,\n//                 match_ends: self_as_bytes.len(),\n//                 leftover,\n//             }\n//         } else {\n//             Match {\n//                 succeeded: false,\n//                 match_ends: 0,\n//                 leftover: input,\n//             }\n//         }\n//     }\n// }\n//\n// // And\n// impl<T, U> Regex for (T, U) where T: Regex, U: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let lhs_result = self.0.find_match(input);\n//         if lhs_result.succeeded {\n//             let rhs_result = self.1.find_match(lhs_result.leftover);\n//             if rhs_result.succeeded {\n//                 Match {\n//                     succeeded: true,\n//                     match_ends: lhs_result.match_ends + rhs_result.match_ends,\n//                     leftover: rhs_result.leftover,\n//                 }\n//             } else {\n//                 Match {\n//                     succeeded: false,\n//                     match_ends: 0,\n//                     leftover: input,\n//                 }\n//             }\n//         } else {\n//             Match {\n//                 succeeded: false,\n//                 match_ends: 0,\n//                 leftover: input,\n//             }\n//         }\n//     }\n// }\n//\n// // N T's: (T, (T, (T, T)))\n// struct Repeated<T, let N: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32> Regex for Repeated<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut result = Match::empty(input);\n//         for _ in 0..M {\n//             if result.succeeded {\n//                 let next_result = self.inner.find_match(result.leftover);\n//                 result = Match {\n//                     succeeded: next_result.succeeded,\n//                     match_ends: result.match_ends + next_result.match_ends,\n//                     leftover: next_result.leftover,\n//                 };\n//             }\n//         }\n//         result\n//     }\n// }\n//\n// struct Or<T, U> {\n//     lhs: T,\n//     rhs: U,\n// }\n//\n// impl<T, U> Regex for Or<T, U> where T: Regex, U: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let lhs_result = self.lhs.find_match(input);\n//         if lhs_result.succeeded {\n//             lhs_result\n//         } else {\n//             self.rhs.find_match(input)\n//         }\n//     }\n// }\n//\n// struct Question<T> {\n//     inner: T,\n// }\n//\n// impl<T> Regex for Question<T> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         Or {\n//             lhs: self.inner,\n//             rhs: (),\n//         }.find_match(input)\n//     }\n// }\n//\n// // 0 <= num_matches <= N\n// struct Star<T, let N: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32> Regex for Star<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let regex: Repeated<_, M> = Repeated {\n//             inner: Question { inner: self.inner },\n//         };\n//         regex.find_match(input)\n//     }\n// }\n//\n// // 0 < num_matches <= N\n// struct Plus<T, let N: u32, let N_PRED: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32, let M_PRED: u32> Regex for Plus<T, M, M_PRED> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         std::static_assert(M_PRED + 1 == M, \"M - 1 != M_PRED\");\n//         let star: Star<T, M_PRED> = Star { inner: self.inner };\n//         (\n//             self.inner,\n//             star\n//         ).find_match(input)\n//     }\n// }\n//\n// // Repeated is to (,) as AnyOf is to Or\n// struct AnyOf<T, let N: u32> {\n//     inner: [T; N],\n// }\n//\n// impl<T, let M: u32> Regex for AnyOf<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut result = Match::failed(input);\n//         for i in 0..M {\n//             if !result.succeeded {\n//                 result = self.inner[i].find_match(result.leftover);\n//             }\n//         }\n//         result\n//     }\n// }\n//\n// fn reverse_array<T, let N: u32>(input: [T; N]) -> [T; N] {\n//     let mut output = [std::mem::zeroed(); N];\n//     for i in 0..N {\n//         output[i] = input[N - (i + 1)];\n//     }\n//     output\n// }\n//\n// fn main() {\n//     assert_eq(reverse_array([1, 2, 3, 4]), [4, 3, 2, 1]);\n//\n//     let mut xs: Bvec<u8, 3> = Bvec::empty();\n//\n//     xs = xs.push(0);\n//     assert_eq(xs, Bvec { inner: [0, 0, 0], offset: 0, len: 1 });\n//\n//     xs = xs.push(1);\n//     assert_eq(xs, Bvec { inner: [0, 1, 0], offset: 0, len: 2 });\n//\n//     xs = xs.push(2);\n//     assert_eq(xs, Bvec { inner: [0, 1, 2], offset: 0, len: 3 });\n//\n//     xs = xs.push(3);\n//     assert_eq(xs, Bvec { inner: [0, 1, 2], offset: 0, len: 3 });\n//\n//     let ys = Bvec::new([0, 1, 2]);\n//     assert_eq(xs, ys);\n//\n//     // test that pop_front gives all contents, in order,\n//     // followed by std::mem::zeroed()\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 0);\n//\n//     xs = new_xs;\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 1);\n//\n//     xs = new_xs;\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 2);\n//\n//     xs = new_xs;\n//     println(xs);\n//     if xs.len != 0 {\n//         let (x, _new_xs) = xs.pop_front();\n//         assert_eq(x, std::mem::zeroed());\n//     }\n//\n//     assert_eq(new_xs, Bvec { inner: [0, 1, 2], offset: 3, len: 0 });\n//\n//     // gr(a|e)y\n//     let graey_regex = (\"gr\", (Or { lhs: \"a\", rhs: \"e\" }, \"y\"));\n//\n//     let result = graey_regex.find_match(Bvec::new(\"gray\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = graey_regex.find_match(Bvec::new(\"grey\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // colou?r\n//     let colour_regex = (\"colo\", (Question { inner: \"u\" }, \"r\"));\n//\n//     let result = colour_regex.find_match(Bvec::new(\"color\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = colour_regex.find_match(Bvec::new(\"colour\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 6);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // parse the empty string three times\n//     // EMPTY{3}\n//     let three_empties_regex: Repeated<(), 3> = Repeated { inner: () };\n//\n//     let result = three_empties_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 3);\n//\n//     // 1{0}\n//     let zero_ones_regex: Repeated<str<1>, 0> = Repeated { inner: \"1\" };\n//\n//     let result = zero_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 3);\n//\n//     // 1{1}\n//     let one_ones_regex: Repeated<str<1>, 1> = Repeated { inner: \"1\" };\n//\n//     let result = one_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 1);\n//     assert_eq(result.leftover.len, 2);\n//\n//     // 1{2}\n//     let two_ones_regex: Repeated<str<1>, 2> = Repeated { inner: \"1\" };\n//\n//     let result = two_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1{3}\n//     let three_ones_regex: Repeated<str<1>, 3> = Repeated { inner: \"1\" };\n//\n//     let result = three_ones_regex.find_match(Bvec::new(\"1111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 3);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1*\n//     let ones_regex: Star<str<1>, 5> = Star { inner: \"1\" };\n//\n//     let result = ones_regex.find_match(Bvec::new(\"11000\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 3);\n//\n//     let result = ones_regex.find_match(Bvec::new(\"11\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = ones_regex.find_match(Bvec::new(\"111111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1+\n//     let nonempty_ones_regex: Plus<str<1>, 5, 4> = Plus { inner: \"1\" };\n//\n//     let result = nonempty_ones_regex.find_match(Bvec::new(\"111111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 2^n-1 in binary: 1+0\n//     let pred_pow_two_regex = (nonempty_ones_regex, \"0\");\n//\n//     let result = pred_pow_two_regex.find_match(Bvec::new(\"1110\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // (0|1)*\n//     let binary_regex: Star<Or<str<1>, str<1>>, 5> = Star { inner: Or { lhs: \"0\", rhs: \"1\" } };\n//\n//     let result = binary_regex.find_match(Bvec::new(\"110100\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // even numbers in binary: 1(0|1)*0\n//     let even_binary_regex = (\"1\", (binary_regex, \"0\"));\n//\n//     let result = even_binary_regex.find_match(Bvec::new(\"1111110\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 7);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // digit: \\d+\n//     // [0-9]\n//     let digit_regex = AnyOf {\n//         inner: [\n//             \"0\",\n//             \"1\",\n//             \"2\",\n//             \"3\",\n//             \"4\",\n//             \"5\",\n//             \"6\",\n//             \"7\",\n//             \"8\",\n//             \"9\"\n//         ]\n//     };\n//\n//     let result = digit_regex.find_match(Bvec::new(\"157196345823795\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 1);\n//     assert_eq(result.leftover.len, 14);\n//\n//     let result = digit_regex.find_match(Bvec::new(\"hi\".as_bytes()));\n//     println(result);\n//     assert(!result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 2);\n//\n//     // digits: \\d+\n//     // [0-9]+\n//     let digits_regex: Plus<AnyOf<str<1>, 10>, 32, 31> = Plus { inner: digit_regex };\n//\n//     let result = digits_regex.find_match(Bvec::new(\"123456789012345\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 15);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = digits_regex.find_match(Bvec::new(\"123456789012345 then words\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 15);\n//     assert_eq(result.leftover.len, 11);\n//\n//     // multiples of 10\n//     // apply to a reversed input string (because there isn't backtracking)\n//     // 0\\d+\n//     let backwards_mult_of_10_regex = (\"0\", digits_regex);\n//\n//     let result = backwards_mult_of_10_regex.find_match(Bvec::new(reverse_array(\"1230\".as_bytes())));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let ten_pow_16: str<17> = \"10000000000000000\";\n//     let result = backwards_mult_of_10_regex.find_match(Bvec::new(reverse_array(ten_pow_16.as_bytes())));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 17);\n//     assert_eq(result.leftover.len, 0);\n//     // adapted URL parser: (https?:\\/\\/)?([\\da-c.\\-]+)\\.([a-c.]+)([\\/\\w \\.\\-]*)*\\/?\n// }\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
