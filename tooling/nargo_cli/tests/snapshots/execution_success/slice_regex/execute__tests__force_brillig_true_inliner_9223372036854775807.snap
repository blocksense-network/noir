---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "50": {
      "source": "struct Match {\n    succeeded: bool,\n    match_ends: u32,\n    leftover: [u8],\n}\n\nimpl Match {\n    fn empty(leftover: [u8]) -> Self {\n        Match { succeeded: true, match_ends: 0, leftover }\n    }\n}\n\nimpl Eq for Match {\n    fn eq(self, other: Self) -> bool {\n        (self.succeeded == other.succeeded) & (self.match_ends == other.match_ends)\n        // (self.leftover == other.leftover)\n    }\n}\n\n// TODO: load match into str<N> and assert that it's the correct length\n// impl<N> From<Match> for str<N>\n\ntrait Regex {\n    fn find_match(self, input: [u8]) -> Match;\n}\n\n// Empty\nimpl Regex for () {\n    fn find_match(_self: Self, input: [u8]) -> Match {\n        Match::empty(input)\n    }\n}\n\n// Exact\nimpl<let N: u32> Regex for str<N> {\n    fn find_match(self, input: [u8]) -> Match {\n        let mut leftover = input;\n        let mut matches_input = true;\n        let self_as_bytes = self.as_bytes();\n        for c in self_as_bytes {\n            if leftover.len() != 0 {\n                let (first_elem, popped_slice) = leftover.pop_front();\n                leftover = popped_slice;\n                matches_input &= first_elem == c;\n            } else {\n                matches_input = false;\n            }\n        }\n        if matches_input {\n            Match { succeeded: true, match_ends: self_as_bytes.len(), leftover }\n        } else {\n            Match { succeeded: false, match_ends: 0, leftover: input }\n        }\n    }\n}\n\n// And\nimpl<T, U> Regex for (T, U)\nwhere\n    T: Regex,\n    U: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let lhs_result = self.0.find_match(input);\n        if lhs_result.succeeded {\n            let rhs_result = self.1.find_match(lhs_result.leftover);\n            if rhs_result.succeeded {\n                Match {\n                    succeeded: true,\n                    match_ends: lhs_result.match_ends + rhs_result.match_ends,\n                    leftover: rhs_result.leftover,\n                }\n            } else {\n                Match { succeeded: false, match_ends: 0, leftover: input }\n            }\n        } else {\n            Match { succeeded: false, match_ends: 0, leftover: input }\n        }\n    }\n}\n\n// N T's: (T, (T, (T, T)))\nstruct Repeated<T, let N: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32> Regex for Repeated<T, N>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let mut result = Match::empty(input);\n        for _ in 0..N {\n            if result.succeeded {\n                let next_result = self.inner.find_match(result.leftover);\n                result = Match {\n                    succeeded: next_result.succeeded,\n                    match_ends: result.match_ends + next_result.match_ends,\n                    leftover: next_result.leftover,\n                };\n            }\n        }\n        result\n    }\n}\n\nstruct Or<T, U> {\n    lhs: T,\n    rhs: U,\n}\n\nimpl<T, U> Regex for Or<T, U>\nwhere\n    T: Regex,\n    U: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let lhs_result = self.lhs.find_match(input);\n        if lhs_result.succeeded {\n            lhs_result\n        } else {\n            self.rhs.find_match(input)\n        }\n    }\n}\n\nstruct Question<T> {\n    inner: T,\n}\n\nimpl<T> Regex for Question<T>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        Or { lhs: self.inner, rhs: () }.find_match(input)\n    }\n}\n\n// 0 <= num_matches <= N\nstruct Star<T, let N: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32> Regex for Star<T, N>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let regex: Repeated<_, N> = Repeated { inner: Question { inner: self.inner } };\n        regex.find_match(input)\n    }\n}\n\n// 0 < num_matches <= N\nstruct Plus<T, let N: u32, let N_PRED: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32, let N_PRED: u32> Regex for Plus<T, N, N_PRED>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        std::static_assert(N_PRED + 1 == N, \"N - 1 != N_PRED\");\n        let star: Star<T, N_PRED> = Star { inner: self.inner };\n        (self.inner, star).find_match(input)\n    }\n}\n\nfn main() {\n    // gr(a|e)y\n    let graey_regex = (\"gr\", (Or { lhs: \"a\", rhs: \"e\" }, \"y\"));\n\n    // NOTE: leftover ignored in Eq: Match\n    let result = graey_regex.find_match(\"gray\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 4, leftover: &[] });\n\n    // NOTE: leftover ignored in Eq: Match\n    let result = graey_regex.find_match(\"grey\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 4, leftover: &[] });\n\n    // colou?r\n    let colour_regex = (\"colo\", (Question { inner: \"u\" }, \"r\"));\n\n    let result = colour_regex.find_match(\"color\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n\n    let result = colour_regex.find_match(\"colour\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 6, leftover: &[] });\n\n    // parse the empty string three times\n    // EMPTY{3}\n    let three_empties_regex: Repeated<(), 3> = Repeated { inner: () };\n\n    let result = three_empties_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 0, leftover: &[] });\n\n    // 1{0}\n    let zero_ones_regex: Repeated<str<1>, 0> = Repeated { inner: \"1\" };\n\n    let result = zero_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 0, leftover: &[] });\n\n    // 1{1}\n    let one_ones_regex: Repeated<str<1>, 1> = Repeated { inner: \"1\" };\n\n    let result = one_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 1, leftover: &[] });\n\n    // 1{2}\n    let two_ones_regex: Repeated<str<1>, 2> = Repeated { inner: \"1\" };\n\n    let result = two_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n\n    // 1{3}\n    let three_ones_regex: Repeated<str<1>, 3> = Repeated { inner: \"1\" };\n\n    let result = three_ones_regex.find_match(\"1111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 3, leftover: &[] });\n    // TODO(https://github.com/noir-lang/noir/issues/6285): re-enable these cases and complete the test using array_regex below\n    //\n    // // 1*\n    // let ones_regex: Star<str<1>, 5> = Star { inner: \"1\" };\n    //\n    // let result = ones_regex.find_match(\"11000\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n    //\n    // let result = ones_regex.find_match(\"11\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n    //\n    // let result = ones_regex.find_match(\"111111\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    //\n    // // 1+\n    // let nonempty_ones_regex: Plus<str<1>, 5, 4> = Plus { inner: \"1\" };\n    //\n    // let result = nonempty_ones_regex.find_match(\"111111\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    // // 2^n-1 in binary: 1+0\n    // let pred_pow_two_regex = (nonempty_ones_regex, \"0\");\n    //\n    // let result = pred_pow_two_regex.find_match(\"1110\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 3, leftover: &[] });\n    //\n    // // (0|1)*\n    // let binary_regex: Star<Or<str<1>, str<1>>, 5> = Star { inner: Or { lhs: \"0\", rhs: \"1\" } };\n    //\n    // let result = binary_regex.find_match(\"110100\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    // // even numbers in binary: 1(0|1)*0\n    // let even_binary_regex = (\"1\", (binary_regex, \"0\"));\n    //\n    // let result = even_binary_regex.find_match(\"1111110\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 6, leftover: &[] });\n    // 2-letter capitalized words: [A-Z][a-z]\n    // numbers: \\d+\n    // [0-9]+\n    // words: \\w+\n    // [a-Z]+\n    // adapted URL parser: (https?:\\/\\/)?([\\da-z.\\-]+)\\.([a-z.]+)([\\/\\w \\.\\-]*)*\\/?\n    // // panics (at compile time) when input string is too short\n    // let foo_regex = (\n    //     \"colo\",\n    //     (\n    //         Question {\n    //             inner: \"u\",\n    //         },\n    //         \"r\"\n    //     )\n    // );\n    //\n    // let result = foo_regex.find_match(\"colo\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match {\n    //     succeeded: true,\n    //     match_ends: 4,\n    //     leftover: &[],\n    // });\n}\n\n// TODO\n// array_regex execution_success test:\n// use to complete test once https://github.com/noir-lang/noir/issues/6285 is resolved\n//\n// // offset <= len <= N\n// struct Bvec<T, let N: u32> {\n//     inner: [T; N],\n//\n//     // elements at indices < offset are zero\n//     offset: u32,\n//\n//     // elements at indices >= len are zero\n//     len: u32,\n// }\n//\n// impl<T, let N: u32> Eq for Bvec<T, N> where T: Eq {\n//     fn eq(self, other: Self) -> bool {\n//         (self.inner == other.inner) &\n//             (self.offset == other.offset) &\n//             (self.len == other.len)\n//     }\n// }\n//\n// impl<T, let N: u32> Bvec<T, N> {\n//     fn empty() -> Self {\n//         Self { inner: [std::mem::zeroed(); N], offset: 0, len: 0 }\n//     }\n//\n//     fn new(array: [T; N]) -> Self {\n//         let mut result = Bvec::empty();\n//         for x in array {\n//             result = result.push(x);\n//         }\n//         result\n//     }\n//\n//     // pushing when len == N is a no-op\n//     fn push(self, x: T) -> Self {\n//         let mut inner = self.inner;\n//         let mut len = self.len;\n//         if self.len < N {\n//             inner[self.len] = x;\n//             len += 1;\n//         }\n//\n//         Self { inner, offset: self.offset, len }\n//     }\n//\n//     fn pop_front(self) -> (T, Self) {\n//         assert(self.offset <= self.inner.len());\n//         assert(self.len != 0);\n//\n//         let first_elem = self.inner[self.offset];\n//         let popped_slice = Self { inner: self.inner, offset: self.offset + 1, len: self.len - 1 };\n//\n//         (first_elem, popped_slice)\n//     }\n// }\n//\n// struct Match<let N: u32> {\n//     succeeded: bool,\n//     match_ends: u32,\n//     leftover: Bvec<u8, N>,\n// }\n//\n// impl<let N: u32> Match<N> {\n//     fn empty(leftover: Bvec<u8, N>) -> Self {\n//         Match { succeeded: true, match_ends: 0, leftover }\n//     }\n//\n//     fn failed(leftover: Bvec<u8, N>) -> Self {\n//         Match { succeeded: false, match_ends: 0, leftover }\n//     }\n// }\n//\n// impl<let N: u32> Eq for Match<N> {\n//     fn eq(self, other: Self) -> bool {\n//         (self.succeeded == other.succeeded) &\n//             (self.match_ends == other.match_ends) &\n//             (self.leftover == other.leftover)\n//     }\n// }\n//\n// // TODO: load match into str<N> and assert that it's the correct length\n// // impl<N> From<Match> for str<N>\n//\n// trait Regex {\n//     // Perform a match without backtracking\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N>;\n// }\n//\n// // Empty\n// impl Regex for () {\n//     fn find_match<let N: u32>(_self: Self, input: Bvec<u8, N>) -> Match<N> {\n//         Match::empty(input)\n//     }\n// }\n//\n// // Exact\n// impl<let M: u32> Regex for str<M> {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut leftover = input;\n//         let mut matches_input = true;\n//         let self_as_bytes = self.as_bytes();\n//         for c in self_as_bytes {\n//             if leftover.len != 0 {\n//                 let (first_elem, popped_slice) = leftover.pop_front();\n//                 leftover = popped_slice;\n//                 matches_input &= first_elem == c;\n//             } else {\n//                 matches_input = false;\n//             }\n//         }\n//         if matches_input {\n//             Match {\n//                 succeeded: true,\n//                 match_ends: self_as_bytes.len(),\n//                 leftover,\n//             }\n//         } else {\n//             Match {\n//                 succeeded: false,\n//                 match_ends: 0,\n//                 leftover: input,\n//             }\n//         }\n//     }\n// }\n//\n// // And\n// impl<T, U> Regex for (T, U) where T: Regex, U: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let lhs_result = self.0.find_match(input);\n//         if lhs_result.succeeded {\n//             let rhs_result = self.1.find_match(lhs_result.leftover);\n//             if rhs_result.succeeded {\n//                 Match {\n//                     succeeded: true,\n//                     match_ends: lhs_result.match_ends + rhs_result.match_ends,\n//                     leftover: rhs_result.leftover,\n//                 }\n//             } else {\n//                 Match {\n//                     succeeded: false,\n//                     match_ends: 0,\n//                     leftover: input,\n//                 }\n//             }\n//         } else {\n//             Match {\n//                 succeeded: false,\n//                 match_ends: 0,\n//                 leftover: input,\n//             }\n//         }\n//     }\n// }\n//\n// // N T's: (T, (T, (T, T)))\n// struct Repeated<T, let N: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32> Regex for Repeated<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut result = Match::empty(input);\n//         for _ in 0..M {\n//             if result.succeeded {\n//                 let next_result = self.inner.find_match(result.leftover);\n//                 result = Match {\n//                     succeeded: next_result.succeeded,\n//                     match_ends: result.match_ends + next_result.match_ends,\n//                     leftover: next_result.leftover,\n//                 };\n//             }\n//         }\n//         result\n//     }\n// }\n//\n// struct Or<T, U> {\n//     lhs: T,\n//     rhs: U,\n// }\n//\n// impl<T, U> Regex for Or<T, U> where T: Regex, U: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let lhs_result = self.lhs.find_match(input);\n//         if lhs_result.succeeded {\n//             lhs_result\n//         } else {\n//             self.rhs.find_match(input)\n//         }\n//     }\n// }\n//\n// struct Question<T> {\n//     inner: T,\n// }\n//\n// impl<T> Regex for Question<T> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         Or {\n//             lhs: self.inner,\n//             rhs: (),\n//         }.find_match(input)\n//     }\n// }\n//\n// // 0 <= num_matches <= N\n// struct Star<T, let N: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32> Regex for Star<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let regex: Repeated<_, M> = Repeated {\n//             inner: Question { inner: self.inner },\n//         };\n//         regex.find_match(input)\n//     }\n// }\n//\n// // 0 < num_matches <= N\n// struct Plus<T, let N: u32, let N_PRED: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32, let M_PRED: u32> Regex for Plus<T, M, M_PRED> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         std::static_assert(M_PRED + 1 == M, \"M - 1 != M_PRED\");\n//         let star: Star<T, M_PRED> = Star { inner: self.inner };\n//         (\n//             self.inner,\n//             star\n//         ).find_match(input)\n//     }\n// }\n//\n// // Repeated is to (,) as AnyOf is to Or\n// struct AnyOf<T, let N: u32> {\n//     inner: [T; N],\n// }\n//\n// impl<T, let M: u32> Regex for AnyOf<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut result = Match::failed(input);\n//         for i in 0..M {\n//             if !result.succeeded {\n//                 result = self.inner[i].find_match(result.leftover);\n//             }\n//         }\n//         result\n//     }\n// }\n//\n// fn reverse_array<T, let N: u32>(input: [T; N]) -> [T; N] {\n//     let mut output = [std::mem::zeroed(); N];\n//     for i in 0..N {\n//         output[i] = input[N - (i + 1)];\n//     }\n//     output\n// }\n//\n// fn main() {\n//     assert_eq(reverse_array([1, 2, 3, 4]), [4, 3, 2, 1]);\n//\n//     let mut xs: Bvec<u8, 3> = Bvec::empty();\n//\n//     xs = xs.push(0);\n//     assert_eq(xs, Bvec { inner: [0, 0, 0], offset: 0, len: 1 });\n//\n//     xs = xs.push(1);\n//     assert_eq(xs, Bvec { inner: [0, 1, 0], offset: 0, len: 2 });\n//\n//     xs = xs.push(2);\n//     assert_eq(xs, Bvec { inner: [0, 1, 2], offset: 0, len: 3 });\n//\n//     xs = xs.push(3);\n//     assert_eq(xs, Bvec { inner: [0, 1, 2], offset: 0, len: 3 });\n//\n//     let ys = Bvec::new([0, 1, 2]);\n//     assert_eq(xs, ys);\n//\n//     // test that pop_front gives all contents, in order,\n//     // followed by std::mem::zeroed()\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 0);\n//\n//     xs = new_xs;\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 1);\n//\n//     xs = new_xs;\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 2);\n//\n//     xs = new_xs;\n//     println(xs);\n//     if xs.len != 0 {\n//         let (x, _new_xs) = xs.pop_front();\n//         assert_eq(x, std::mem::zeroed());\n//     }\n//\n//     assert_eq(new_xs, Bvec { inner: [0, 1, 2], offset: 3, len: 0 });\n//\n//     // gr(a|e)y\n//     let graey_regex = (\"gr\", (Or { lhs: \"a\", rhs: \"e\" }, \"y\"));\n//\n//     let result = graey_regex.find_match(Bvec::new(\"gray\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = graey_regex.find_match(Bvec::new(\"grey\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // colou?r\n//     let colour_regex = (\"colo\", (Question { inner: \"u\" }, \"r\"));\n//\n//     let result = colour_regex.find_match(Bvec::new(\"color\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = colour_regex.find_match(Bvec::new(\"colour\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 6);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // parse the empty string three times\n//     // EMPTY{3}\n//     let three_empties_regex: Repeated<(), 3> = Repeated { inner: () };\n//\n//     let result = three_empties_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 3);\n//\n//     // 1{0}\n//     let zero_ones_regex: Repeated<str<1>, 0> = Repeated { inner: \"1\" };\n//\n//     let result = zero_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 3);\n//\n//     // 1{1}\n//     let one_ones_regex: Repeated<str<1>, 1> = Repeated { inner: \"1\" };\n//\n//     let result = one_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 1);\n//     assert_eq(result.leftover.len, 2);\n//\n//     // 1{2}\n//     let two_ones_regex: Repeated<str<1>, 2> = Repeated { inner: \"1\" };\n//\n//     let result = two_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1{3}\n//     let three_ones_regex: Repeated<str<1>, 3> = Repeated { inner: \"1\" };\n//\n//     let result = three_ones_regex.find_match(Bvec::new(\"1111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 3);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1*\n//     let ones_regex: Star<str<1>, 5> = Star { inner: \"1\" };\n//\n//     let result = ones_regex.find_match(Bvec::new(\"11000\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 3);\n//\n//     let result = ones_regex.find_match(Bvec::new(\"11\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = ones_regex.find_match(Bvec::new(\"111111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1+\n//     let nonempty_ones_regex: Plus<str<1>, 5, 4> = Plus { inner: \"1\" };\n//\n//     let result = nonempty_ones_regex.find_match(Bvec::new(\"111111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 2^n-1 in binary: 1+0\n//     let pred_pow_two_regex = (nonempty_ones_regex, \"0\");\n//\n//     let result = pred_pow_two_regex.find_match(Bvec::new(\"1110\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // (0|1)*\n//     let binary_regex: Star<Or<str<1>, str<1>>, 5> = Star { inner: Or { lhs: \"0\", rhs: \"1\" } };\n//\n//     let result = binary_regex.find_match(Bvec::new(\"110100\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // even numbers in binary: 1(0|1)*0\n//     let even_binary_regex = (\"1\", (binary_regex, \"0\"));\n//\n//     let result = even_binary_regex.find_match(Bvec::new(\"1111110\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 7);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // digit: \\d+\n//     // [0-9]\n//     let digit_regex = AnyOf {\n//         inner: [\n//             \"0\",\n//             \"1\",\n//             \"2\",\n//             \"3\",\n//             \"4\",\n//             \"5\",\n//             \"6\",\n//             \"7\",\n//             \"8\",\n//             \"9\"\n//         ]\n//     };\n//\n//     let result = digit_regex.find_match(Bvec::new(\"157196345823795\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 1);\n//     assert_eq(result.leftover.len, 14);\n//\n//     let result = digit_regex.find_match(Bvec::new(\"hi\".as_bytes()));\n//     println(result);\n//     assert(!result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 2);\n//\n//     // digits: \\d+\n//     // [0-9]+\n//     let digits_regex: Plus<AnyOf<str<1>, 10>, 32, 31> = Plus { inner: digit_regex };\n//\n//     let result = digits_regex.find_match(Bvec::new(\"123456789012345\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 15);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = digits_regex.find_match(Bvec::new(\"123456789012345 then words\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 15);\n//     assert_eq(result.leftover.len, 11);\n//\n//     // multiples of 10\n//     // apply to a reversed input string (because there isn't backtracking)\n//     // 0\\d+\n//     let backwards_mult_of_10_regex = (\"0\", digits_regex);\n//\n//     let result = backwards_mult_of_10_regex.find_match(Bvec::new(reverse_array(\"1230\".as_bytes())));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let ten_pow_16: str<17> = \"10000000000000000\";\n//     let result = backwards_mult_of_10_regex.find_match(Bvec::new(reverse_array(ten_pow_16.as_bytes())));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 17);\n//     assert_eq(result.leftover.len, 0);\n//     // adapted URL parser: (https?:\\/\\/)?([\\da-c.\\-]+)\\.([a-c.]+)([\\/\\w \\.\\-]*)*\\/?\n// }\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
