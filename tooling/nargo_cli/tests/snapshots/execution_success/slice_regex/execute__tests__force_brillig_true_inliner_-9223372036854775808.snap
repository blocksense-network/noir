---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "50": {
      "source": "struct Match {\n    succeeded: bool,\n    match_ends: u32,\n    leftover: [u8],\n}\n\nimpl Match {\n    fn empty(leftover: [u8]) -> Self {\n        Match { succeeded: true, match_ends: 0, leftover }\n    }\n}\n\nimpl Eq for Match {\n    fn eq(self, other: Self) -> bool {\n        (self.succeeded == other.succeeded) & (self.match_ends == other.match_ends)\n        // (self.leftover == other.leftover)\n    }\n}\n\n// TODO: load match into str<N> and assert that it's the correct length\n// impl<N> From<Match> for str<N>\n\ntrait Regex {\n    fn find_match(self, input: [u8]) -> Match;\n}\n\n// Empty\nimpl Regex for () {\n    fn find_match(_self: Self, input: [u8]) -> Match {\n        Match::empty(input)\n    }\n}\n\n// Exact\nimpl<let N: u32> Regex for str<N> {\n    fn find_match(self, input: [u8]) -> Match {\n        let mut leftover = input;\n        let mut matches_input = true;\n        let self_as_bytes = self.as_bytes();\n        for c in self_as_bytes {\n            if leftover.len() != 0 {\n                let (first_elem, popped_slice) = leftover.pop_front();\n                leftover = popped_slice;\n                matches_input &= first_elem == c;\n            } else {\n                matches_input = false;\n            }\n        }\n        if matches_input {\n            Match { succeeded: true, match_ends: self_as_bytes.len(), leftover }\n        } else {\n            Match { succeeded: false, match_ends: 0, leftover: input }\n        }\n    }\n}\n\n// And\nimpl<T, U> Regex for (T, U)\nwhere\n    T: Regex,\n    U: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let lhs_result = self.0.find_match(input);\n        if lhs_result.succeeded {\n            let rhs_result = self.1.find_match(lhs_result.leftover);\n            if rhs_result.succeeded {\n                Match {\n                    succeeded: true,\n                    match_ends: lhs_result.match_ends + rhs_result.match_ends,\n                    leftover: rhs_result.leftover,\n                }\n            } else {\n                Match { succeeded: false, match_ends: 0, leftover: input }\n            }\n        } else {\n            Match { succeeded: false, match_ends: 0, leftover: input }\n        }\n    }\n}\n\n// N T's: (T, (T, (T, T)))\nstruct Repeated<T, let N: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32> Regex for Repeated<T, N>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let mut result = Match::empty(input);\n        for _ in 0..N {\n            if result.succeeded {\n                let next_result = self.inner.find_match(result.leftover);\n                result = Match {\n                    succeeded: next_result.succeeded,\n                    match_ends: result.match_ends + next_result.match_ends,\n                    leftover: next_result.leftover,\n                };\n            }\n        }\n        result\n    }\n}\n\nstruct Or<T, U> {\n    lhs: T,\n    rhs: U,\n}\n\nimpl<T, U> Regex for Or<T, U>\nwhere\n    T: Regex,\n    U: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let lhs_result = self.lhs.find_match(input);\n        if lhs_result.succeeded {\n            lhs_result\n        } else {\n            self.rhs.find_match(input)\n        }\n    }\n}\n\nstruct Question<T> {\n    inner: T,\n}\n\nimpl<T> Regex for Question<T>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        Or { lhs: self.inner, rhs: () }.find_match(input)\n    }\n}\n\n// 0 <= num_matches <= N\nstruct Star<T, let N: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32> Regex for Star<T, N>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let regex: Repeated<_, N> = Repeated { inner: Question { inner: self.inner } };\n        regex.find_match(input)\n    }\n}\n\n// 0 < num_matches <= N\nstruct Plus<T, let N: u32, let N_PRED: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32, let N_PRED: u32> Regex for Plus<T, N, N_PRED>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        std::static_assert(N_PRED + 1 == N, \"N - 1 != N_PRED\");\n        let star: Star<T, N_PRED> = Star { inner: self.inner };\n        (self.inner, star).find_match(input)\n    }\n}\n\nfn main() {\n    // gr(a|e)y\n    let graey_regex = (\"gr\", (Or { lhs: \"a\", rhs: \"e\" }, \"y\"));\n\n    // NOTE: leftover ignored in Eq: Match\n    let result = graey_regex.find_match(\"gray\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 4, leftover: &[] });\n\n    // NOTE: leftover ignored in Eq: Match\n    let result = graey_regex.find_match(\"grey\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 4, leftover: &[] });\n\n    // colou?r\n    let colour_regex = (\"colo\", (Question { inner: \"u\" }, \"r\"));\n\n    let result = colour_regex.find_match(\"color\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n\n    let result = colour_regex.find_match(\"colour\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 6, leftover: &[] });\n\n    // parse the empty string three times\n    // EMPTY{3}\n    let three_empties_regex: Repeated<(), 3> = Repeated { inner: () };\n\n    let result = three_empties_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 0, leftover: &[] });\n\n    // 1{0}\n    let zero_ones_regex: Repeated<str<1>, 0> = Repeated { inner: \"1\" };\n\n    let result = zero_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 0, leftover: &[] });\n\n    // 1{1}\n    let one_ones_regex: Repeated<str<1>, 1> = Repeated { inner: \"1\" };\n\n    let result = one_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 1, leftover: &[] });\n\n    // 1{2}\n    let two_ones_regex: Repeated<str<1>, 2> = Repeated { inner: \"1\" };\n\n    let result = two_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n\n    // 1{3}\n    let three_ones_regex: Repeated<str<1>, 3> = Repeated { inner: \"1\" };\n\n    let result = three_ones_regex.find_match(\"1111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 3, leftover: &[] });\n    // TODO(https://github.com/noir-lang/noir/issues/6285): re-enable these cases and complete the test using array_regex below\n    //\n    // // 1*\n    // let ones_regex: Star<str<1>, 5> = Star { inner: \"1\" };\n    //\n    // let result = ones_regex.find_match(\"11000\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n    //\n    // let result = ones_regex.find_match(\"11\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n    //\n    // let result = ones_regex.find_match(\"111111\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    //\n    // // 1+\n    // let nonempty_ones_regex: Plus<str<1>, 5, 4> = Plus { inner: \"1\" };\n    //\n    // let result = nonempty_ones_regex.find_match(\"111111\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    // // 2^n-1 in binary: 1+0\n    // let pred_pow_two_regex = (nonempty_ones_regex, \"0\");\n    //\n    // let result = pred_pow_two_regex.find_match(\"1110\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 3, leftover: &[] });\n    //\n    // // (0|1)*\n    // let binary_regex: Star<Or<str<1>, str<1>>, 5> = Star { inner: Or { lhs: \"0\", rhs: \"1\" } };\n    //\n    // let result = binary_regex.find_match(\"110100\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    // // even numbers in binary: 1(0|1)*0\n    // let even_binary_regex = (\"1\", (binary_regex, \"0\"));\n    //\n    // let result = even_binary_regex.find_match(\"1111110\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 6, leftover: &[] });\n    // 2-letter capitalized words: [A-Z][a-z]\n    // numbers: \\d+\n    // [0-9]+\n    // words: \\w+\n    // [a-Z]+\n    // adapted URL parser: (https?:\\/\\/)?([\\da-z.\\-]+)\\.([a-z.]+)([\\/\\w \\.\\-]*)*\\/?\n    // // panics (at compile time) when input string is too short\n    // let foo_regex = (\n    //     \"colo\",\n    //     (\n    //         Question {\n    //             inner: \"u\",\n    //         },\n    //         \"r\"\n    //     )\n    // );\n    //\n    // let result = foo_regex.find_match(\"colo\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match {\n    //     succeeded: true,\n    //     match_ends: 4,\n    //     leftover: &[],\n    // });\n}\n\n// TODO\n// array_regex execution_success test:\n// use to complete test once https://github.com/noir-lang/noir/issues/6285 is resolved\n//\n// // offset <= len <= N\n// struct Bvec<T, let N: u32> {\n//     inner: [T; N],\n//\n//     // elements at indices < offset are zero\n//     offset: u32,\n//\n//     // elements at indices >= len are zero\n//     len: u32,\n// }\n//\n// impl<T, let N: u32> Eq for Bvec<T, N> where T: Eq {\n//     fn eq(self, other: Self) -> bool {\n//         (self.inner == other.inner) &\n//             (self.offset == other.offset) &\n//             (self.len == other.len)\n//     }\n// }\n//\n// impl<T, let N: u32> Bvec<T, N> {\n//     fn empty() -> Self {\n//         Self { inner: [std::mem::zeroed(); N], offset: 0, len: 0 }\n//     }\n//\n//     fn new(array: [T; N]) -> Self {\n//         let mut result = Bvec::empty();\n//         for x in array {\n//             result = result.push(x);\n//         }\n//         result\n//     }\n//\n//     // pushing when len == N is a no-op\n//     fn push(self, x: T) -> Self {\n//         let mut inner = self.inner;\n//         let mut len = self.len;\n//         if self.len < N {\n//             inner[self.len] = x;\n//             len += 1;\n//         }\n//\n//         Self { inner, offset: self.offset, len }\n//     }\n//\n//     fn pop_front(self) -> (T, Self) {\n//         assert(self.offset <= self.inner.len());\n//         assert(self.len != 0);\n//\n//         let first_elem = self.inner[self.offset];\n//         let popped_slice = Self { inner: self.inner, offset: self.offset + 1, len: self.len - 1 };\n//\n//         (first_elem, popped_slice)\n//     }\n// }\n//\n// struct Match<let N: u32> {\n//     succeeded: bool,\n//     match_ends: u32,\n//     leftover: Bvec<u8, N>,\n// }\n//\n// impl<let N: u32> Match<N> {\n//     fn empty(leftover: Bvec<u8, N>) -> Self {\n//         Match { succeeded: true, match_ends: 0, leftover }\n//     }\n//\n//     fn failed(leftover: Bvec<u8, N>) -> Self {\n//         Match { succeeded: false, match_ends: 0, leftover }\n//     }\n// }\n//\n// impl<let N: u32> Eq for Match<N> {\n//     fn eq(self, other: Self) -> bool {\n//         (self.succeeded == other.succeeded) &\n//             (self.match_ends == other.match_ends) &\n//             (self.leftover == other.leftover)\n//     }\n// }\n//\n// // TODO: load match into str<N> and assert that it's the correct length\n// // impl<N> From<Match> for str<N>\n//\n// trait Regex {\n//     // Perform a match without backtracking\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N>;\n// }\n//\n// // Empty\n// impl Regex for () {\n//     fn find_match<let N: u32>(_self: Self, input: Bvec<u8, N>) -> Match<N> {\n//         Match::empty(input)\n//     }\n// }\n//\n// // Exact\n// impl<let M: u32> Regex for str<M> {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut leftover = input;\n//         let mut matches_input = true;\n//         let self_as_bytes = self.as_bytes();\n//         for c in self_as_bytes {\n//             if leftover.len != 0 {\n//                 let (first_elem, popped_slice) = leftover.pop_front();\n//                 leftover = popped_slice;\n//                 matches_input &= first_elem == c;\n//             } else {\n//                 matches_input = false;\n//             }\n//         }\n//         if matches_input {\n//             Match {\n//                 succeeded: true,\n//                 match_ends: self_as_bytes.len(),\n//                 leftover,\n//             }\n//         } else {\n//             Match {\n//                 succeeded: false,\n//                 match_ends: 0,\n//                 leftover: input,\n//             }\n//         }\n//     }\n// }\n//\n// // And\n// impl<T, U> Regex for (T, U) where T: Regex, U: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let lhs_result = self.0.find_match(input);\n//         if lhs_result.succeeded {\n//             let rhs_result = self.1.find_match(lhs_result.leftover);\n//             if rhs_result.succeeded {\n//                 Match {\n//                     succeeded: true,\n//                     match_ends: lhs_result.match_ends + rhs_result.match_ends,\n//                     leftover: rhs_result.leftover,\n//                 }\n//             } else {\n//                 Match {\n//                     succeeded: false,\n//                     match_ends: 0,\n//                     leftover: input,\n//                 }\n//             }\n//         } else {\n//             Match {\n//                 succeeded: false,\n//                 match_ends: 0,\n//                 leftover: input,\n//             }\n//         }\n//     }\n// }\n//\n// // N T's: (T, (T, (T, T)))\n// struct Repeated<T, let N: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32> Regex for Repeated<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut result = Match::empty(input);\n//         for _ in 0..M {\n//             if result.succeeded {\n//                 let next_result = self.inner.find_match(result.leftover);\n//                 result = Match {\n//                     succeeded: next_result.succeeded,\n//                     match_ends: result.match_ends + next_result.match_ends,\n//                     leftover: next_result.leftover,\n//                 };\n//             }\n//         }\n//         result\n//     }\n// }\n//\n// struct Or<T, U> {\n//     lhs: T,\n//     rhs: U,\n// }\n//\n// impl<T, U> Regex for Or<T, U> where T: Regex, U: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let lhs_result = self.lhs.find_match(input);\n//         if lhs_result.succeeded {\n//             lhs_result\n//         } else {\n//             self.rhs.find_match(input)\n//         }\n//     }\n// }\n//\n// struct Question<T> {\n//     inner: T,\n// }\n//\n// impl<T> Regex for Question<T> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         Or {\n//             lhs: self.inner,\n//             rhs: (),\n//         }.find_match(input)\n//     }\n// }\n//\n// // 0 <= num_matches <= N\n// struct Star<T, let N: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32> Regex for Star<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let regex: Repeated<_, M> = Repeated {\n//             inner: Question { inner: self.inner },\n//         };\n//         regex.find_match(input)\n//     }\n// }\n//\n// // 0 < num_matches <= N\n// struct Plus<T, let N: u32, let N_PRED: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32, let M_PRED: u32> Regex for Plus<T, M, M_PRED> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         std::static_assert(M_PRED + 1 == M, \"M - 1 != M_PRED\");\n//         let star: Star<T, M_PRED> = Star { inner: self.inner };\n//         (\n//             self.inner,\n//             star\n//         ).find_match(input)\n//     }\n// }\n//\n// // Repeated is to (,) as AnyOf is to Or\n// struct AnyOf<T, let N: u32> {\n//     inner: [T; N],\n// }\n//\n// impl<T, let M: u32> Regex for AnyOf<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut result = Match::failed(input);\n//         for i in 0..M {\n//             if !result.succeeded {\n//                 result = self.inner[i].find_match(result.leftover);\n//             }\n//         }\n//         result\n//     }\n// }\n//\n// fn reverse_array<T, let N: u32>(input: [T; N]) -> [T; N] {\n//     let mut output = [std::mem::zeroed(); N];\n//     for i in 0..N {\n//         output[i] = input[N - (i + 1)];\n//     }\n//     output\n// }\n//\n// fn main() {\n//     assert_eq(reverse_array([1, 2, 3, 4]), [4, 3, 2, 1]);\n//\n//     let mut xs: Bvec<u8, 3> = Bvec::empty();\n//\n//     xs = xs.push(0);\n//     assert_eq(xs, Bvec { inner: [0, 0, 0], offset: 0, len: 1 });\n//\n//     xs = xs.push(1);\n//     assert_eq(xs, Bvec { inner: [0, 1, 0], offset: 0, len: 2 });\n//\n//     xs = xs.push(2);\n//     assert_eq(xs, Bvec { inner: [0, 1, 2], offset: 0, len: 3 });\n//\n//     xs = xs.push(3);\n//     assert_eq(xs, Bvec { inner: [0, 1, 2], offset: 0, len: 3 });\n//\n//     let ys = Bvec::new([0, 1, 2]);\n//     assert_eq(xs, ys);\n//\n//     // test that pop_front gives all contents, in order,\n//     // followed by std::mem::zeroed()\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 0);\n//\n//     xs = new_xs;\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 1);\n//\n//     xs = new_xs;\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 2);\n//\n//     xs = new_xs;\n//     println(xs);\n//     if xs.len != 0 {\n//         let (x, _new_xs) = xs.pop_front();\n//         assert_eq(x, std::mem::zeroed());\n//     }\n//\n//     assert_eq(new_xs, Bvec { inner: [0, 1, 2], offset: 3, len: 0 });\n//\n//     // gr(a|e)y\n//     let graey_regex = (\"gr\", (Or { lhs: \"a\", rhs: \"e\" }, \"y\"));\n//\n//     let result = graey_regex.find_match(Bvec::new(\"gray\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = graey_regex.find_match(Bvec::new(\"grey\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // colou?r\n//     let colour_regex = (\"colo\", (Question { inner: \"u\" }, \"r\"));\n//\n//     let result = colour_regex.find_match(Bvec::new(\"color\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = colour_regex.find_match(Bvec::new(\"colour\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 6);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // parse the empty string three times\n//     // EMPTY{3}\n//     let three_empties_regex: Repeated<(), 3> = Repeated { inner: () };\n//\n//     let result = three_empties_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 3);\n//\n//     // 1{0}\n//     let zero_ones_regex: Repeated<str<1>, 0> = Repeated { inner: \"1\" };\n//\n//     let result = zero_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 3);\n//\n//     // 1{1}\n//     let one_ones_regex: Repeated<str<1>, 1> = Repeated { inner: \"1\" };\n//\n//     let result = one_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 1);\n//     assert_eq(result.leftover.len, 2);\n//\n//     // 1{2}\n//     let two_ones_regex: Repeated<str<1>, 2> = Repeated { inner: \"1\" };\n//\n//     let result = two_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1{3}\n//     let three_ones_regex: Repeated<str<1>, 3> = Repeated { inner: \"1\" };\n//\n//     let result = three_ones_regex.find_match(Bvec::new(\"1111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 3);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1*\n//     let ones_regex: Star<str<1>, 5> = Star { inner: \"1\" };\n//\n//     let result = ones_regex.find_match(Bvec::new(\"11000\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 3);\n//\n//     let result = ones_regex.find_match(Bvec::new(\"11\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = ones_regex.find_match(Bvec::new(\"111111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1+\n//     let nonempty_ones_regex: Plus<str<1>, 5, 4> = Plus { inner: \"1\" };\n//\n//     let result = nonempty_ones_regex.find_match(Bvec::new(\"111111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 2^n-1 in binary: 1+0\n//     let pred_pow_two_regex = (nonempty_ones_regex, \"0\");\n//\n//     let result = pred_pow_two_regex.find_match(Bvec::new(\"1110\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // (0|1)*\n//     let binary_regex: Star<Or<str<1>, str<1>>, 5> = Star { inner: Or { lhs: \"0\", rhs: \"1\" } };\n//\n//     let result = binary_regex.find_match(Bvec::new(\"110100\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // even numbers in binary: 1(0|1)*0\n//     let even_binary_regex = (\"1\", (binary_regex, \"0\"));\n//\n//     let result = even_binary_regex.find_match(Bvec::new(\"1111110\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 7);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // digit: \\d+\n//     // [0-9]\n//     let digit_regex = AnyOf {\n//         inner: [\n//             \"0\",\n//             \"1\",\n//             \"2\",\n//             \"3\",\n//             \"4\",\n//             \"5\",\n//             \"6\",\n//             \"7\",\n//             \"8\",\n//             \"9\"\n//         ]\n//     };\n//\n//     let result = digit_regex.find_match(Bvec::new(\"157196345823795\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 1);\n//     assert_eq(result.leftover.len, 14);\n//\n//     let result = digit_regex.find_match(Bvec::new(\"hi\".as_bytes()));\n//     println(result);\n//     assert(!result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 2);\n//\n//     // digits: \\d+\n//     // [0-9]+\n//     let digits_regex: Plus<AnyOf<str<1>, 10>, 32, 31> = Plus { inner: digit_regex };\n//\n//     let result = digits_regex.find_match(Bvec::new(\"123456789012345\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 15);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = digits_regex.find_match(Bvec::new(\"123456789012345 then words\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 15);\n//     assert_eq(result.leftover.len, 11);\n//\n//     // multiples of 10\n//     // apply to a reversed input string (because there isn't backtracking)\n//     // 0\\d+\n//     let backwards_mult_of_10_regex = (\"0\", digits_regex);\n//\n//     let result = backwards_mult_of_10_regex.find_match(Bvec::new(reverse_array(\"1230\".as_bytes())));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let ten_pow_16: str<17> = \"10000000000000000\";\n//     let result = backwards_mult_of_10_regex.find_match(Bvec::new(reverse_array(ten_pow_16.as_bytes())));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 17);\n//     assert_eq(result.leftover.len, 0);\n//     // adapted URL parser: (https?:\\/\\/)?([\\da-c.\\-]+)\\.([a-c.]+)([\\/\\w \\.\\-]*)*\\/?\n// }\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
