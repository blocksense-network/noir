---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "array",
          "length": 5,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "z",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "u",
        "type": {
          "kind": "integer",
          "sign": "signed",
          "width": 16
        },
        "visibility": "private"
      },
      {
        "name": "v",
        "type": {
          "kind": "integer",
          "sign": "signed",
          "width": 16
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "global NIBBLE_LENGTH: u32 = 16;\n\nstruct U4 {\n    inner: u8,\n}\n\nimpl U4 {\n    fn zero() -> U4 {\n        U4 { inner: 0 }\n    }\n\n    fn from_u8(x: u8) -> U4 {\n        U4 { inner: x % 16 }\n    }\n}\n\nimpl Eq for U4 {\n    fn eq(self, other: Self) -> bool {\n        self.inner == other.inner\n    }\n}\n\nfn compact_decode<let N: u32>(input: [u8; N], length: Field) -> ([U4; NIBBLE_LENGTH], Field) {\n    assert(2 * input.len() <= NIBBLE_LENGTH);\n    assert(length as u32 <= input.len());\n\n    let mut nibble = [U4::zero(); NIBBLE_LENGTH];\n\n    let first_nibble = U4::from_u8(input[0] >> 4);\n    let parity = first_nibble.inner as u1;\n\n    if parity == 1 {\n        nibble[0] = U4::from_u8(input[0] & 0x0f);\n        for i in 1..input.len() {\n            if i as u32 < length as u32 {\n                let x = input[i];\n                nibble[2 * i - 1] = U4::from_u8(x >> 4);\n                nibble[2 * i] = U4::from_u8(x & 0x0f);\n            }\n        }\n    } else {\n        for i in 0..2 {\n            if (i as u32) < length as u32 - 1 {\n                let x = input[i + 1];\n                nibble[2 * i] = U4::from_u8(x >> 4);\n                nibble[2 * i + 1] = U4::from_u8(x & 0x0f);\n            }\n        }\n    }\n\n    let out = (nibble, 2 * length + (parity as Field) - 2);\n\n    out\n}\n\nfn enc<let N: u32>(value: [u8; N], value_length: Field) -> ([u8; 32], Field) {\n    assert(value.len() as u8 >= value_length as u8);\n    let mut out_value = [0; 32];\n    if value_length == 0 {\n        let out = (out_value, value_length);\n        out\n    } else if value_length as u8 < 31 {\n        out_value[0] = 0x80 + value_length as u8;\n\n        for i in 1..value.len() {\n            out_value[i] = value[i - 1];\n        }\n\n        let out = (out_value, value_length + 1);\n\n        out\n    } else {\n        let out = (out_value, 32);\n        out\n    }\n}\n\nfn bitshift_literal_0() -> u64 {\n    let mut bits: u64 = 0;\n    bits |= 1 << 0;\n\n    bits\n}\nfn bitshift_literal_4() -> u64 {\n    let mut bits: u64 = 0;\n    bits |= 1 << 4;\n\n    bits\n}\nfn bitshift_variable(idx: u8) -> u64 {\n    let mut bits: u64 = 0;\n    bits |= 1 << idx;\n\n    bits\n}\n\nfn main(x: [u8; 5], z: Field, u: i16, v: i16) {\n    //Issue 1144\n    let (nib, len) = compact_decode(x, z);\n    assert(len == 5);\n    assert(\n        [nib[0], nib[1], nib[2], nib[3], nib[4]]\n            == [U4::from_u8(15), U4::from_u8(1), U4::from_u8(12), U4::from_u8(11), U4::from_u8(8)],\n    );\n    // Issue 1169\n    let val1 = [\n        0xb8, 0x8f, 0x61, 0xe6, 0xfb, 0xda, 0x83, 0xfb, 0xff, 0xfa, 0xbe, 0x36, 0x41, 0x12, 0x13,\n        0x74, 0x80, 0x39, 0x80, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    let val1_length = 20;\n\n    let enc_val1 = enc(val1, val1_length);\n\n    assert(\n        enc_val1.0\n            == [\n                0x94, 0xb8, 0x8f, 0x61, 0xe6, 0xfb, 0xda, 0x83, 0xfb, 0xff, 0xfa, 0xbe, 0x36, 0x41,\n                0x12, 0x13, 0x74, 0x80, 0x39, 0x80, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                0x00, 0x00, 0x00, 0x00,\n            ],\n    );\n    assert(enc_val1.1 == 21);\n    // Issue 2399\n    let result_0 = bitshift_literal_0();\n    assert(result_0 == 1);\n    let result_4 = bitshift_literal_4();\n    assert(result_4 == 16);\n    let result_0 = bitshift_variable(0);\n    assert(result_0 == 1);\n    let result_4 = bitshift_variable(4);\n    assert(result_4 == 16);\n\n    // Issue 6609\n    assert(u % -13 == 0);\n    assert(u % v == 0);\n    assert(u % -11 == 4);\n    assert(-u % -11 == -4);\n    assert(u % -11 == u % (v + 2));\n    assert(-u % -11 == -u % (v + 2));\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
