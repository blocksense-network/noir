---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "a",
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 32
        },
        "visibility": "private"
      },
      {
        "name": "b",
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 32
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "pZnRbhs5DEX/xc9+GImUKOVXiqJwU7cwYDiBmyywKPLvyzvUHWcX2BfNS+9xPbyZoUhJI/85/Dh/f//17XL7+fL78PTlz+H7/XK9Xn59u748n94uLzf/3z+HBf/kdHhKx0POIRKiISWkhlhIC+mHp3w8yBKSQnKIu4iLhpSQGmIhLaSvoktICnEXdZEQDSkh7lJc3KW6tJC+SllCUkgOkRANcRdzqSEW0kLcpR0PdQlJITlEQjSkhNQQC2kh4WLhYuFi4WLhYu7SXUpIDbGQFtJXaUtICsEYLa4yVIeWoXWoDW1D3Sz5kPVlaBqah8LPh63r0DK0DrWhbWgPTctCgKMAYKkAISihECrBCI0AZx/elBZCImQCnCtACYVQCUZohD4gLwQ4GyAThKCEQqgEIzRCH4BWCKCz0FnoLHQWOgudhc5CZ6Gz0lnprHRGk6QGUEIhVIIRGqEPQMsEwLkDMkEISnDnvAAqwQiN0AegjQISIRPcOSeAO2fUDxoqoBKM0Ah9AForIBEyQQh0NjobnY3ORmejc6NzozNaLqOw0XMBSiiESjBCI/QBaL2MCkfvBWSCEOCMCkf/BVSCERqhB2T0YEAiwLkChABnAxRCJRihEfoA9GBAIsC5AYSghEKAcwcYoREw2S9YaxZCIrizrMuQEJRQCJVghEaAc8byBWcBJEImCAHOCiiESoAzcrguT0jdukAB1iVqhUSAM9KCHgxQQiFUghEaAc7IGHpQkB/0YEAmCAGLIBKFHgyoBCO4s66rdh+AHgxIhEwQgg5A7yhyiN4JKAQ4I3XoC0Wi0A6KRKEdFNlAOwRUghEaoQ9AYSuSgMIOaAGCMtYGgHMHYMlfAH5xSYBG6ANQq2XdhyRCJghBCYWAcOxCUJABiYBwBQhBCYVQCUZohD5A6INiKwXAi4UXCy9GjQUkAsNRY6UCcBtIFGosoBKM0Ah9AEa5IKuYaQMqAVHIM2bagD4AM21AImSCEJRAH8yiFePVeHHjxY0Xo1oCKmELx54OY4pqqRgmTJ4BiZAJQlACwtedJcLl4+N44Kb329v9fMae99Mu2PfGr6f7+fZ2eLq9X6/Hw1+n6/t60e/X023Vt9Pdv/UHOt9+uLrhz8v1DPo4PqKX/w9NWErWYN8IbOFlKr5OxGes3mu8T4s743Ui3mttxIv1mXiUcMS3ZWf8TP4Vc98arzrz/GocP7UyE18f8XVn/Ez+S+L4lTQVv2zxeWb8tD/i0874mfErhfkrpeyLr1N/Xx/xti/eZvJfF/ZPTTPxpT/i0774qfop7REvO+Nn+q8b58/eZ56/10f8TP10bJFG/Ez9+us9J0BHm3IQ2xykTTlsTew4dQ/+l+mQpsbRTxy2hdhfvHc7TN1DThxMxzzloH1zKMuUg3xySHNP0R4Oc09RHw6173WwqXvwnSkddJlzsK0vdGpu9Nd13oPj3O5u2bZ3aWp+91OAujlon3LItjnIstthZpbMn7a5eWqd8cOLtjnIVB6yPe6h5SmHso2FHwRMOWzbRUfbew9zDrKtF45tyqHI5jC1a/MRTJvD1Lrrx0lbJsXKboep0VTbnkKnZjk/sdrGQtvUPRScS4ZDyVOj+XiFcOx7HZJMObQtk+U/vfnVP52eL/d//b72Aa/75fT9eh4ff77fnj99+/b3K7/h73Ov95fn84/3+xlOjx/p/JTji/hbhNT8FT+T+MfsL9XZEj76qcgXXdJRF/n6gZv5Bw==",
  "file_map": {
    "50": {
      "source": "use std::hint::black_box;\n\nfn main(a: u32, b: u32) {\n    // This version unrolls into a number of additions\n    assert_eq(loop_(5, a), b);\n    // This version simplifies into a single `constraint 50 == b`\n    assert_eq(loop_(5, 10), b);\n    // This version should not simplify down to a single constraint,\n    // it should treat 10 as opaque:\n    assert_eq(loop_(5, black_box(10)), b);\n\n    // Check array handling.\n    let arr = [a, a, a, a, a];\n\n    assert_eq(array_sum(arr), b);\n    assert_eq(array_sum(black_box(arr)), b);\n\n    assert_eq(slice_sum(arr.as_slice()), b);\n    assert_eq(slice_sum(black_box(arr).as_slice()), b);\n\n    // This doesn't work because by calling `black_box` on a slice the compiler\n    // loses track of the length, and then cannot unroll the loop for ACIR.\n    //assert_eq(slice_sum(black_box(arr.as_slice())), b);\n\n    // But we can pass a blackboxed slice to Brillig.\n    // Safety: testing context\n    let s = unsafe { brillig_slice_sum(black_box(arr.as_slice())) };\n    assert_eq(s, b);\n\n    let mut d = b;\n    // This gets completely eliminated:\n    let mut c = 0;\n    set_ref(&mut c, &mut d);\n    assert_eq(c, b);\n\n    // This way the constraint is preserved:\n    let mut c = 0;\n    set_ref(&mut c, &mut black_box(d));\n    assert_eq(c, b);\n\n    // A reference over the output of black box is not the original variable:\n    let mut c = 0;\n    set_ref(&mut black_box(c), &mut d);\n    assert_eq(c, 0);\n\n    // This would cause a causes a crash during SSA passes unless it's a Brillig runtime:\n    //  > Could not resolve some references to the array. All references must be resolved at compile time\n    // The SSA cannot have Allocate by the time we start generating ACIR, but `black_box` prevents them\n    // from being optimised away during SSA passes.\n    // If we use `--force-brillig` then the it doesn't crash but the assertion fails because `mem2reg`\n    // eliminates the storing to the reference.\n    //let mut c = 0;\n    //set_ref(black_box(&mut c), black_box(&mut d));\n    //assert_eq(c, b);\n}\n\nfn loop_(n: u32, k: u32) -> u32 {\n    let mut sum = 0;\n    for _ in 0..n {\n        sum = sum + k;\n    }\n    sum\n}\n\nfn array_sum<let N: u32>(xs: [u32; N]) -> u32 {\n    let mut sum = 0;\n    for i in 0..N {\n        sum = sum + xs[i];\n    }\n    sum\n}\n\nfn slice_sum(xs: [u32]) -> u32 {\n    let mut sum = 0;\n    for x in xs {\n        sum = sum + x;\n    }\n    sum\n}\n\nunconstrained fn brillig_slice_sum(xs: [u32]) -> u32 {\n    let mut sum = 0;\n    for x in xs {\n        sum = sum + x;\n    }\n    sum\n}\n\nfn set_ref(c: &mut u32, b: &mut u32) {\n    *c = *b;\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
