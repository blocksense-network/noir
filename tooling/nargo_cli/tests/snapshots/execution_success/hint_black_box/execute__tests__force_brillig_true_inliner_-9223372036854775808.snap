---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "a",
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 32
        },
        "visibility": "private"
      },
      {
        "name": "b",
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 32
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "ndzdavM4EAbge8lxDiTNjEbqrSwfH/1JPwKlLf1ZWErvfZ2ldrKeccQ7J0UpfTDRq9rSWPbX7uFw9/nn9/H58eV9d/PX1+7p5f724/jyPH36+t7v7t6OT0/HP78vf71Lpx8l//f376+3z6eP7x+3bx+7m1zKfnd4fphaRJN/PD4ddjeSvn/td6XAgmDBsBBYVFgoLBos+kjUlaAEiwyLAgs385L7jyiU14JhIbCosFBYNFh0VHCCRYZFGQleC4IFw0Jg4WZOtf4I0r4WbuYkOouW1qLBoqNCEiwyLAosCBYMCxmJ9VlUKiwUFg0WbubM9COY12O3JlhkWBRYECwYFgKLCguFRYMFnLnCmSucucKZK5y5+pnrPGdglbUQWFRYKCwaLDoqWoJFhoWfeT2L9RyuESwYFgKLCguFRYNFH4n1LKMnWGRYFFi4mUueZ0uSjWBYCCwqLBQWDRYdFTklnLipS1pISYb4sfczyYYQThgngpOKE8VJw0kfkfUVMeeEk4yTghP/v17m84SIGMI4EZxUnChOGk46TErCSR6QaqL0y3PXCeGEcSI4qThRnDScdJhQwgmePuHpE54+4ekTnj7h6ROePuHpE54+4+kznj7j6fs1O+EzUUMYJ4KTihPFScNJh4lfurtO8oComfX5xbvrhHDCOHHTr2mulNVsScWJ4qThpMPEL+JdJxknBSd++v1MzKTXL+RdELsY8St510nFieKk4aTDxC/nXScZJwUnhBM8fcXTVzx9xdNXPH3F0294+g1P3y/tSTsTMoRwwjgRnFScKE4aTjpM/BLfJamGZJwUnBBO3PS7zjdeezcXC7/Od51UnChOGk46Sopf67tOMk7c9Hs9EzaEcOKnL3khYojgpOJEcdJw0mHi1/quk4wTf2NOyvN9uampBlEEcQRJBPkbsxLpgqgZpBHUIsjfoZWW+urUNN/Jr/2NUI4gf0RM32RG2Zzcy8YOvQHiCJIIqhGkEdQiyB8ReVkTT027JzKNkTnSxs69ASoRRBHkj4jpxDaj6YRlkERQjaCN/ZvcFyTJoI0tnHSBzEWZegBxiqAcQRvbOXM7I9N7TBHEESQRVCNII6hF0MaIqGdU17d+i6QhUnMkyRFUIogiyB8R1NOMOFkkEVQjSCPIHxGkyzyCTSmt+JXEAfJriSOUI6hEEEUQB5BfvZom6nNOU9MijiCJoI1N4GnZp5xNPba0jT3aXBfE5hzRNjZdF10Q2SPxGJk1YJMIqhGkEdQiqAeQX6QoF5vQi6nRFb9MMUINR+QXEaY5flsQdYP8EVH0fKRWDNroCFkG7HSWM2ijI5ZNaVNTDWoR1APIX7f/7zs5KEdQiSCKII4giSC/y2lZUU/N9Yqa/MXxCOUI8ruchBZkNuGQvzgeIY4giaAaQRpBLYJ6AFEkp43HwajnBZnCJlGkIyjSERTpiI0HvQYoR1Ckyzee+KJlG/rUtIjHyFw1Np77GqAaQRpBLYJ6APmz5Wklu4xyNosu8u/Bj1CNIL/3eLm1NDXtd2oR1APIvxs/QjmCSgRRBHEERXLy72ZPxQOZkRRzzW2RjmiRjmiRjthY1QxQjaBQl/v/Guft/1PToj5EeV2Qpp4iKEdQiSCKII6gjS5vy3lP7FKodxR9T5/+vn073t49HX5e0/D4+Xx/8daGj39eD6sXOLy+vdwfHj7fDqdXOZzf4nDqG5Kyp1p+nR5NmD6WWvdF8+njKSNOec+JpqNOR/4X",
  "file_map": {
    "50": {
      "source": "use std::hint::black_box;\n\nfn main(a: u32, b: u32) {\n    // This version unrolls into a number of additions\n    assert_eq(loop_(5, a), b);\n    // This version simplifies into a single `constraint 50 == b`\n    assert_eq(loop_(5, 10), b);\n    // This version should not simplify down to a single constraint,\n    // it should treat 10 as opaque:\n    assert_eq(loop_(5, black_box(10)), b);\n\n    // Check array handling.\n    let arr = [a, a, a, a, a];\n\n    assert_eq(array_sum(arr), b);\n    assert_eq(array_sum(black_box(arr)), b);\n\n    assert_eq(slice_sum(arr.as_slice()), b);\n    assert_eq(slice_sum(black_box(arr).as_slice()), b);\n\n    // This doesn't work because by calling `black_box` on a slice the compiler\n    // loses track of the length, and then cannot unroll the loop for ACIR.\n    //assert_eq(slice_sum(black_box(arr.as_slice())), b);\n\n    // But we can pass a blackboxed slice to Brillig.\n    // Safety: testing context\n    let s = unsafe { brillig_slice_sum(black_box(arr.as_slice())) };\n    assert_eq(s, b);\n\n    let mut d = b;\n    // This gets completely eliminated:\n    let mut c = 0;\n    set_ref(&mut c, &mut d);\n    assert_eq(c, b);\n\n    // This way the constraint is preserved:\n    let mut c = 0;\n    set_ref(&mut c, &mut black_box(d));\n    assert_eq(c, b);\n\n    // A reference over the output of black box is not the original variable:\n    let mut c = 0;\n    set_ref(&mut black_box(c), &mut d);\n    assert_eq(c, 0);\n\n    // This would cause a causes a crash during SSA passes unless it's a Brillig runtime:\n    //  > Could not resolve some references to the array. All references must be resolved at compile time\n    // The SSA cannot have Allocate by the time we start generating ACIR, but `black_box` prevents them\n    // from being optimised away during SSA passes.\n    // If we use `--force-brillig` then the it doesn't crash but the assertion fails because `mem2reg`\n    // eliminates the storing to the reference.\n    //let mut c = 0;\n    //set_ref(black_box(&mut c), black_box(&mut d));\n    //assert_eq(c, b);\n}\n\nfn loop_(n: u32, k: u32) -> u32 {\n    let mut sum = 0;\n    for _ in 0..n {\n        sum = sum + k;\n    }\n    sum\n}\n\nfn array_sum<let N: u32>(xs: [u32; N]) -> u32 {\n    let mut sum = 0;\n    for i in 0..N {\n        sum = sum + xs[i];\n    }\n    sum\n}\n\nfn slice_sum(xs: [u32]) -> u32 {\n    let mut sum = 0;\n    for x in xs {\n        sum = sum + x;\n    }\n    sum\n}\n\nunconstrained fn brillig_slice_sum(xs: [u32]) -> u32 {\n    let mut sum = 0;\n    for x in xs {\n        sum = sum + x;\n    }\n    sum\n}\n\nfn set_ref(c: &mut u32, b: &mut u32) {\n    *c = *b;\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
