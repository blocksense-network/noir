---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "a",
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 32
        },
        "visibility": "private"
      },
      {
        "name": "b",
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 32
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/+1azYrjRhDutvVje1g8JIEccsohh0BYrLE1niEEBpLNDuS8h4UQovXuQA45BAK5GvImOeUR8gx5iDxALskpEPayq5mu8afPJVmy1SPtzjaYltTVVV9Xf13VUtuam2LdLy+Bqwdmu4jMhatnh5WkRV0znzitJ5wFJ1tTXqTtF3cxpv7542GLAx6T3Tb1n80W52NlfC3in49Bpwf9J6I/8KN/Fjs9j9dF/YbsDklO6yMylyBzSTIPTDEIoB5pQ65K/9Hr39Rsrj9w12PS54M/iKlt/7+v4B/A2PLy5dqPbdH/Feg3pv21/cgP/lv9X/vRnx45rv1tilzztBZT4X9otou0RfBMxi1tMeBCPnEZ0j2OKR/vv2CT5RgPxoqI7IvOwMmxvPA8JPmPXS3+DqFPm/x/D/QasuU5rmeex3aq8YXnLoZnzKUR4ZJrLhqXZExNuYTrirksOpFLKM9cEvmHrhZ/RzSuC3c/O7BoXIoqxjckXG8CDxA/lzZ5gHxjHuwbUz53dZcxhceHcp5zy6mWD4YKVrE/MV7jX8LzKXjYPwPyXahgPVbaLF2Hip1QsXPfdfUpHjH/uOyKOYHd6GU5tukj9zxxdd9zjydcSy2/sN8PyS+Cu+lcI7fRfll+Qfmy/JK5usu59rx2U9Ef+9E/t2Y7NmhzIPaZ2+wXrEVXme8mxmv+TarGhvg5RiOPOF5ruqKGujzzdV6Vm9DXHK80rNo4bIs+uU+67st7x0cN8gL6uc4eAOXL9gC/uroPewBLtu8AV2rJ3tBUc1bwjPzguY1HyL2h4oMR+Q7jly2pRRe3ia2J8brmkqqxVb0HINc5Vmi64oa6upzTqr3eSJG3ytgkdgzX27qkLYC2mNrC9bZP8v5f2KJ/+rAPzwvHYjyjQ39y2bVH3zcW87ztG4t/c3WXsXiq4A0Il69vU7x/KHvHEWwDxU8Ys0N69rur8/m6tEV9HCPL1tox+QTltLND5ipiZb96em8509aQIczjivFMoA3xc9HWl4wpt/1Ng/WF/mVsIl/3e4fI/+HqPu11WM6Y6nxtzDYXtdhy6LunZgd1yZlvX7/RVPF6n9zwYw3uTk35Grd0j9xF+bLvN3+62nOsULnb1vcMY+pxSvMjxyRtH6e90x2KDzGIzb7Fa+Z8W/G6a87/5eo+cF4w5kV46nM9oE3P//FpfObBfOP9rzH1+SZjqsu3I7PhfrA2rftjeXazD73G6/SHZhs72g9J/h93j+tQ6uAAnFfLLLmaZ1dZmj1/vlhlzNu8DMBP+N+gu4rd2hmytOX8+g/05j/xnfjYkm0L7Sj/0mx0/u+uq95djqBdO6OVfru+7Q9IPgYcmnxE+G/3MQ5kPkc/uWstBnAO1L5To68frW9q7b8KIWCVedA4op3/78sRjQdVMTXHNrEbvegP5Aj2lXcszh9Tu9H5wF1rHBGMyBHtPLKKI5oPmCMor+U/jZ9xDduINSyxHZnqcw3m54cV/KzznzrEh3PF/ERfBYB1AvbvOoZp88C52Ne7I89b2Z4phPEwT5BvPK+fgF/5G0jT/2cMFDy74v+nJTabxv+HsLY/q1jbGP9Zxwx88bO77vIMGf3J635XDBGfVcWQOnv1XXY4vsjeLyqRF30hyZ/XzH9l51yIb5/8hzzMS7wu6r2u4VkIeq9xozy1jaEtWBftTNy9rGvWJThCkn8MHL8eA/SR/seK/YjsF3Arz5CDrGuoPBP53KcXrlO+1tre+2bL+dnqZLFaPkvn2fy0l3vftzlvPOk4bzxtKW98B3nj2z3zxvfv8kZneeOHjvPGU7Av8WWq9Kn6Ro/vG23HyUWaLVfZMknOF8mLRZLuipNt21+lp89Wr0HMXiT57cku+68AwfU5ink7AAA=",
  "debug_symbols": "ndvbSiw5FAbgd+lrL7JOWYmvMmw2HtpNg6i0OjCI7z7pwa52KinDv24kLX6Ezh+rklWpj939/vb9z+/D08Pz6+76r4/d4/Pdzdvh+al9+vi82t0eD4+Phz+/v/96l04/mP77+9eXm6fTx9e3m+Pb7pqYr3b7p/vWEmn+4fC4311b+vx1tWOGhcBCYWGwyLBwWBRY1JnIKyEJFgQLhsUwc6b6JVhoLRQWBosMC4dFgUVFhSZYECx4JnQtBBYKC4PFMHPJ+UuI17UYZi7mZ1HSWhRYVFRYggXBgmEhsFBY2Eysr6KWYeGwKLAYZq4qX0J1PXdzggXBgmEhsFBYGCwyLBwWBRZw5g5n7nDmDmfucOY+zjyf1wzq6zWDGywyLBwWBRYVFSXBgmZifVcrDAuBhcJimLml893ZeH03KOPM60WsVzLFYVFgUVFREywIFgwLmYn1/3lVWBgsMiyGmZudZ6LlThRYVFRQSjghnDBOBCeKE8NJxonjpOAET5/w9AlPn/D0CU+f8PQJT5/w9AlPn/D0aZy+XoivCSecEE4YJ4ITxYnhJOPEJ8RTRwpOKkwk4WScfj3vMDNRR3hCuO9FcKI4MZxknDhOCk4qTMYFu58J4QRPX/H0FU9f8fQVT1/x9BVPX/H0x6U7KxciHSGcME4EJ4oTw0nGieOkzEjuSIVJTjghnAzTr34ujNfa3SzGdbyfieLEcJJx4jgpOKkwGZfzar6Qbm05ruf9TMbpGy3EOiI4UZwYTjJOHCcFJxUm48Je29Of66at2a1hx7W9GeIIkgjSMRJfkJQOWQTlCBo/pU9Lsag1++9UIqgG0Ljs10oDy5BTf3EfV/5miCNIIkgjyCIoR9B4RtCy92rNbm0wLgf+H/U9VRxxShFEEbRxjIPOV7DW5A5JBGkEbZzh0bogSx3aOMYj3xB1yCOoRFANINo40kPlgrrRI4ogjiCJII0gi6AcQRszIl9Qrh0qU+R9TzWAOEUQRdB4RkhNZ6SpRxJBGkEWQeMZIb6sI7QrpfHGab8JKhFUA2jj2N8EUQRxAG2cN0tLTq3ZI44giaCNg4BpOUfW1hQd2jinp3lB2l0jbOPgHfuCpOvJeI60QxJBGkEWQTmCPIDG1RP+dkiQuxodj+snMyQRNB4IlrIg6abRuPLQLlKXnkp33fONgbBlwrJ1PfnGQCyHOFrTOyQRpBFk0+80QDmCPIJKBNUAGpcWZmg85LLsqFuzdMgiKEfQeMjFZEFmHSoRVANovHefIYogjiCJII2gQE6SNkav0oK6wqYkjvQkEaQRZBGUIyg05Bv/Gr5cYcV7VOdofdcQShFEEcQRJBGkATReLbP6Msu123TJxtsyE6QRNJ6wujxaas3+O+UI8ggqEVQDaOMVmgmiCOIIiuQ0fprddhN2Rsbre65YZCAsMhAWGYiNXc0EaQRFhnxjV3M5wNyaPfIpIulQiaAaQOMH1jNEEcQRtDHkZbnuWbcVkuwo+myf/r45Hm5uH/dfr9E+vD/dfXur9u2fl/3qBduX4/Pd/v79uD+9ant5y/Y0h4X8Sth/nY6Oto8setUWPKePp5GT9nRXnFqvred/AQ==",
  "file_map": {
    "50": {
      "source": "use std::hint::black_box;\n\nfn main(a: u32, b: u32) {\n    // This version unrolls into a number of additions\n    assert_eq(loop_(5, a), b);\n    // This version simplifies into a single `constraint 50 == b`\n    assert_eq(loop_(5, 10), b);\n    // This version should not simplify down to a single constraint,\n    // it should treat 10 as opaque:\n    assert_eq(loop_(5, black_box(10)), b);\n\n    // Check array handling.\n    let arr = [a, a, a, a, a];\n\n    assert_eq(array_sum(arr), b);\n    assert_eq(array_sum(black_box(arr)), b);\n\n    assert_eq(slice_sum(arr.as_slice()), b);\n    assert_eq(slice_sum(black_box(arr).as_slice()), b);\n\n    // This doesn't work because by calling `black_box` on a slice the compiler\n    // loses track of the length, and then cannot unroll the loop for ACIR.\n    //assert_eq(slice_sum(black_box(arr.as_slice())), b);\n\n    // But we can pass a blackboxed slice to Brillig.\n    // Safety: testing context\n    let s = unsafe { brillig_slice_sum(black_box(arr.as_slice())) };\n    assert_eq(s, b);\n\n    let mut d = b;\n    // This gets completely eliminated:\n    let mut c = 0;\n    set_ref(&mut c, &mut d);\n    assert_eq(c, b);\n\n    // This way the constraint is preserved:\n    let mut c = 0;\n    set_ref(&mut c, &mut black_box(d));\n    assert_eq(c, b);\n\n    // A reference over the output of black box is not the original variable:\n    let mut c = 0;\n    set_ref(&mut black_box(c), &mut d);\n    assert_eq(c, 0);\n\n    // This would cause a causes a crash during SSA passes unless it's a Brillig runtime:\n    //  > Could not resolve some references to the array. All references must be resolved at compile time\n    // The SSA cannot have Allocate by the time we start generating ACIR, but `black_box` prevents them\n    // from being optimised away during SSA passes.\n    // If we use `--force-brillig` then the it doesn't crash but the assertion fails because `mem2reg`\n    // eliminates the storing to the reference.\n    //let mut c = 0;\n    //set_ref(black_box(&mut c), black_box(&mut d));\n    //assert_eq(c, b);\n}\n\nfn loop_(n: u32, k: u32) -> u32 {\n    let mut sum = 0;\n    for _ in 0..n {\n        sum = sum + k;\n    }\n    sum\n}\n\nfn array_sum<let N: u32>(xs: [u32; N]) -> u32 {\n    let mut sum = 0;\n    for i in 0..N {\n        sum = sum + xs[i];\n    }\n    sum\n}\n\nfn slice_sum(xs: [u32]) -> u32 {\n    let mut sum = 0;\n    for x in xs {\n        sum = sum + x;\n    }\n    sum\n}\n\nunconstrained fn brillig_slice_sum(xs: [u32]) -> u32 {\n    let mut sum = 0;\n    for x in xs {\n        sum = sum + x;\n    }\n    sum\n}\n\nfn set_ref(c: &mut u32, b: &mut u32) {\n    *c = *b;\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
