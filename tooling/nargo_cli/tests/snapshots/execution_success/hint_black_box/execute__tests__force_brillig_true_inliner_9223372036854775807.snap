---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "a",
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 32
        },
        "visibility": "private"
      },
      {
        "name": "b",
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 32
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "tZzZautKEEX/xc9+6Krq6iG/cjkcMjgHQ0hChguXkH+/8iGWg7sjsS3tlyAFr2Vbu6stlYaPzd3u5v3P7/3j/dPr5uqfj83D0+312/7pcVj7+Nxubl72Dw/7P7+//3sTDn8k/3396/P142H19e365W1zJarbze7xblgyG/j7/cNuc+Xhc9u8VEXz12tVLH5/8a/tRgpXX6l6DVy9cPXK1RtXH7l65+oTV8+tWuVWrXKr1rhVa9yqNW7V2mzVpnMiwoTDRIKJbgWo1ONXb795gYmKEjHAhMBEd4BYSl+E5XpOGEx0Mzc/DiwrYckgjM7VJ64+c/WFq69UvQeuXrh65eqNq+dWrXOr1rlV69yqdW7VOrdq02zV2jkhMKEwYTDRrYAY7YuIsfnmDhMJJjJMFJioKJEDTAhMKEwYTMCZZzjzDGee4cwznHnuZ56Pe80x+xlRAkwITChMGExEmHCYSDDRzzydiDQzSX/b71cN5/rC1Veqvgau3hfrrYx6Oz8gqsu3fT59+qLn+tltf/6BJAQcERxRHOlWs8vxaNOlRSKOOI4kHMk4UnCkwogEHOmm72FEmpoS6adfT4gsqVkRI/sj2Z8X+6cmHemff4D8U7OO9E9AfPc3J1xUccRwJOJIf0Lw40zl7g2ScCTjSMGRCiP9pvc0IjiiOGIzSGqi7HecpxHHkYQjGUcKjlQYiQFHBEcUR/D0I55+xNOPePoRTz/i6Uc8fcfTdzx9x9N3PH3H0+/3JT2ekDzzK2k29sbMSuNPZH8m+8tiv9vob2f4fm9yPX+/ObmiX8h+JfuN7I9kv5P95PGfl4+fKqO/NvNbnhs/uTkwyYYjEUccR7pzaQrH+StJi2QcKThSYaTfTJ1GBEcURwxH+unXEyIN4jNIe7zcb6lOIxlHCo5UGOn3M6cRwRHFEcORiCN4+hVPv+LpVzz9CqevIeCI4IjiSD/9ckLmLh+b3JnUH1q16/md7E+L/VM7A/pDx3g9fyH7K9f/Q+N6Pb+Q/Ur2G9lPHv+yfPxM7Qyrzo6f1CCCI4ojhiPdubSOLftapUEcRxKOZBwpOFJhpN/lnkYER7rp13RC2nshDEf66buMiM9USsxjpcSsjd/J/kT258X+sfiGxdr4C9lfuf5+z39Fv5D9SvYb2R/JfvL49MX5uvrR79rsaffPF0iQ4+7DsJgbyC6B4iWQXwL9cJ+KHef54TR083PiP9yslcoItbOfl0ugegGUwiVQ/yYoq+EIxdBC5IpM5IpMTvYnsp/8i5rIM1Za/It6utppWGz8OazpF2v8QvYr2W9kfyT7newn92YyuTdTyL2ZQu7NlOW9mfHq7mGx9duq/mb+KZHsd7I/kf2Z7C9cf+VeaKBVyX4j+yPZv/xCg8n5oaZV/e34yWR/Ifsr1W8hkP1C9nfHP3S5t4/7J8PBYOP3xf7xxo9hMTf+RPZnsr+suf07/sr1SyD7hexXst/I/v74R24Sm6xfWX5/4eT4l0L2V65fw5rbv+MXsl/JfiP7I9nvRP/nsPbv9cv++uZh9/XUvPv3x9tvD9F7++95d/Y8veeXp9vd3fvL7vBkvdND9Q7b2WLYmodfh/v7DqtatmZ2WD2MIrM4rKbhXYd3/h8=",
  "file_map": {
    "50": {
      "source": "use std::hint::black_box;\n\nfn main(a: u32, b: u32) {\n    // This version unrolls into a number of additions\n    assert_eq(loop_(5, a), b);\n    // This version simplifies into a single `constraint 50 == b`\n    assert_eq(loop_(5, 10), b);\n    // This version should not simplify down to a single constraint,\n    // it should treat 10 as opaque:\n    assert_eq(loop_(5, black_box(10)), b);\n\n    // Check array handling.\n    let arr = [a, a, a, a, a];\n\n    assert_eq(array_sum(arr), b);\n    assert_eq(array_sum(black_box(arr)), b);\n\n    assert_eq(slice_sum(arr.as_slice()), b);\n    assert_eq(slice_sum(black_box(arr).as_slice()), b);\n\n    // This doesn't work because by calling `black_box` on a slice the compiler\n    // loses track of the length, and then cannot unroll the loop for ACIR.\n    //assert_eq(slice_sum(black_box(arr.as_slice())), b);\n\n    // But we can pass a blackboxed slice to Brillig.\n    // Safety: testing context\n    let s = unsafe { brillig_slice_sum(black_box(arr.as_slice())) };\n    assert_eq(s, b);\n\n    let mut d = b;\n    // This gets completely eliminated:\n    let mut c = 0;\n    set_ref(&mut c, &mut d);\n    assert_eq(c, b);\n\n    // This way the constraint is preserved:\n    let mut c = 0;\n    set_ref(&mut c, &mut black_box(d));\n    assert_eq(c, b);\n\n    // A reference over the output of black box is not the original variable:\n    let mut c = 0;\n    set_ref(&mut black_box(c), &mut d);\n    assert_eq(c, 0);\n\n    // This would cause a causes a crash during SSA passes unless it's a Brillig runtime:\n    //  > Could not resolve some references to the array. All references must be resolved at compile time\n    // The SSA cannot have Allocate by the time we start generating ACIR, but `black_box` prevents them\n    // from being optimised away during SSA passes.\n    // If we use `--force-brillig` then the it doesn't crash but the assertion fails because `mem2reg`\n    // eliminates the storing to the reference.\n    //let mut c = 0;\n    //set_ref(black_box(&mut c), black_box(&mut d));\n    //assert_eq(c, b);\n}\n\nfn loop_(n: u32, k: u32) -> u32 {\n    let mut sum = 0;\n    for _ in 0..n {\n        sum = sum + k;\n    }\n    sum\n}\n\nfn array_sum<let N: u32>(xs: [u32; N]) -> u32 {\n    let mut sum = 0;\n    for i in 0..N {\n        sum = sum + xs[i];\n    }\n    sum\n}\n\nfn slice_sum(xs: [u32]) -> u32 {\n    let mut sum = 0;\n    for x in xs {\n        sum = sum + x;\n    }\n    sum\n}\n\nunconstrained fn brillig_slice_sum(xs: [u32]) -> u32 {\n    let mut sum = 0;\n    for x in xs {\n        sum = sum + x;\n    }\n    sum\n}\n\nfn set_ref(c: &mut u32, b: &mut u32) {\n    *c = *b;\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
