---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "a",
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 32
        },
        "visibility": "private"
      },
      {
        "name": "b",
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 32
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/+VbzW4jRRDusWfs2I43KxauSHCBU2THdpwVSKwEgYgT4sANiVlngxAnJCSQuFhwQELiCTjxKpx4AQ5IXHiGfYHdSbrsbz5/7ozt6XVW21LU4+6a+uuvqnpmOom7aYn/K1rq+4ZbbUbzyPeD3dqwRl6DmHomkfQsOTlx65vN/e4vOnR/Mdys0eAOya2T/9lg/LAj7KtR/1EHeEbgf2L80zj8B23P55N5mb8juU2iU/cYzQXQXBBN35WTAPKxOcSq3X/w/O/ILa9f99cd4hcDP6hT3f5/IPRvgG1F+3AeR7bx/wj4O1d/bJ/H0X/B/+M4/Cc9j7W3kzLWsjhYODX8t9xqs7k2jJndNncAeiGeuDXpN9pU8Hg3WfJlOtYH81Kb5BvP1MtkesN5RvRv+d783YJ76sT/a8DXkazIeTePbNtU4YXX7gDGGEtYl9EH3BSWzKZNsYRxxVg2noglpGcsGf2x783fiNHYWGoH7EtJr5cBB6g/tzpxgHhjHGybU97z/T5zCtuHdLFri6oHTaGrye+6qPlvyOtp+rB/GuS7ltD1vphL6Lol5LSEnFed15HbW64amB6Wq1JhB+rWcKs5HfNcRmOf+b7IKe8nZdsVDrOA71KhT+Qac6bytbU66nYb/PPBlnUb5a9by1DdNvovfW8+xToQO1+brCqxEGs/kZAu6D+UybFwIOxA/9rYzPexYqHKnqcTx3e5ye661WZzPaFz1TgxvTeNE1wblL9uX4P06/Y13/k+sk9lnJisKnESK34T0mWd/zhOOsIO9K+N/eD72DUj0rpNjH8vDv+R+aIrfIE2mXzOCzaveuPFcyar61ZxF2OPqmwLrXMX9OF6qHh1N+TVEXMx1rQTsBvl9wO6KjuSGn3yKvG6S3WzaPyu4BD02qWmfrFBTUU/c01VNQHpuaYa/R++jxxnsqaarCOh7wvaPw0Ys+g/zmfOLWtqV9iB/rWxP32vairnfh4L1VSj61fwXaR6OElIXhPs6Ak7TJ9+HH0WufzQrfoVfdAn3+H6JWt648VzJqvrosbPMGRbKLdinuKcoXgdbshrn2uKvu6TbX1Br2LL6JrzVV7WpzB3SHPZfNUnRaz/mJT9EykGZ1yPsPXdqi+4jt0DvdCf3FQdQ3u3rWO8bioPh+qY0f/l+8j+lnXMZKk6xs8+seprQrqg/9T+qiH8hDk7o7G/fV9HHcuEPuqsBGNVvcfY9RkrpF/R7DyCre0ecuBibS1WcW1R5iHYw7F9D2zKaOwf36u13bRG9IQ+ffCJNfNr8a77X1eWmYKeTboXMZIR/YNkyfM/PxaKyYR4V805Rv+/72OfW1I5x2SpuNkV/8p2tYa7ylF4iOzLicoXjmzkbz44x+c+nCvbyPY7oDGbijj7pUK9PHLaFyhfYTf0jdjon/o+8rdYiV3O3bExpfzIdUe9zw19w95Wv9B70btw1kph/kD4pirm8azVvjHf9oLuAuZNx6IZTmPGA8qMfM5zrOLGkf3se5xb992fm8Kb2VQVbz23uo94I1ny+JUwE+kb6OI5V51rwD0V15+2oFf1S8VVm+bUuYOqcji3Ws5oraE3fvyt9k3w/W/+Wj03sB9SoR/i43x+03OM4b24F128T50v6epa7+nZzZ7+Wtf50g+MZ5SfEf07ngE/s5s9j7bU82qaD69G+VU+yS8vx7Occ1nRLMb4zHDMelm0UJ7E54njZMkXcVP1ecLoR8mS59Bfh95V91z4+3AoxtU5EY691hr6Fulv9GeBWErF/ewv1K9qLGWg63EkjObT0dnsZDybPp6M8tHpVhiNvecM1fnCN+eEUfXMi/fauxCuVZ8CRi8CGDUdEaOhPZbCqPJB1fpg9Co+2hVkq31zKD4Uvjk+Pg/ER1PcH6o1uFYcH+grrDXnIP9F51C1Drw/fFnPPn4Fft31HEtD6HNb/bmsqf58A7H9dcX6wzy+BV/chb0s+nPXvazKIWovm24oh/PLtnvZ7wP5pcr/EqF+29RfxGHR2vMy3+sexjLge6030tNcB+bSeVlO1/+2uGZepkdG9D8Dxq9tgHvs/vtCfovkl/QWY4hB5tUUY0Zf+PQnfxPvKwx36nlbvVfFelz3/mg2OX08G0/ywZNh8fPktv1R3fKfi57O8ulw+HA8fDIeTm6T/wwrSIBIMT8AAA==",
  "debug_symbols": "tdzbbuM4DAbgd8l1LiRRFKW+ymIw6CEdBCjaoocFFkXffZVBbWdMOsbPjm8KuchHI6Icy7Tsj93d4eb918/j4/3T6+7qn4/dw9Pt9dvx6bFvfXzudzcvx4eH46+f5//ehdOfFH9//vX5+vG0+fp2/fK2u4op7XeHx7veIur+/vhw2F1x+Pyx36UEC4JFhgXDosBCYFFh0dZEmQkKsIiwSLAwc55i+xKJ4lxkWDAsCiwEFhUWDRU5wCLCIq2JPBcEiwwLhoWZcyrlS5C0uTBzTiyDqGEuKiwaKjjAIsIiwYJgkWHBa2L+K8oFFgKLCgsz5znTl8h5PnZLgEWERYIFwSLDgmFRYCGwqLCAcy5wzgXOucA5FzjnYudchjlDFp4LhkWBhcCiwqKhogZYRFjYOS+TmM/hKsEiw4JhUWAhsKiwaGtiPstoARYRFgkWZs45DrMljkpkWDAsCiwEFhUWDRUxBJyYWecwkhQUsdPeJhIVIZxknDBOCk4EJxUnbY3Mz4gxBpxEnCSc2Ec9D78TzKxIxgnjpOBEcFJx0mCSAk7iCikqlXZ57jIhnGScME4KTgQnFScNJhRwgmef8OwTnn3Cs0949gnPPuHZJzz7hGc/49nPePYznn27Zsd5IqJIxgnjpOBEcFJx0mBil+4uk7hCRM367OLdZUI4yTgxs1/CUCkrUZOCE8FJxUmDiV3Eu0wiThJO7Oy3iahJr13IOyP6YsSu5F0mBSeCk4qTBhO7nHeZRJwknBBO8OwLnn3Bsy949gXPvuDZr3j2K559u7THdSKkCOEk44RxUnAiOKk4aTCxS3znpCgScZJwQjgxs99kuPHamjpZ2HW+y6TgRHBScdJQkuxa32UScWJmv5WJZEUIJ3b2OY7kj9rFXn00ZRk+25tJxeeN45eN48u3448HX282Fb9uHL9tG9+ufP7F+HHj+Gnj+LRx/Lxx/I3Hf/r2+OHEQ3xOVcW3l8SFONzf7k1RKHkQeVD2IHtJZCAZEemOKB4kHmSvjQzjfYre1N+pOdDCCskVZI+I/k0GFNUkKS2sk1xB5EHZg9iDigeJB9kjIo61pd7Ua4vbOlJ7ssuxayh6UPKghQXTcfi56001BbHLsmuIPWhh5XRuI+Kg0MLiaTpDanKbqwc1B+LgQQsLqWOdkOo9Th5EHpQ9iD2oeJB40MKIKBMqavbAbRXpKX0JHhQ9KHmQPSKohQHloFH2IPag4kH2iCAZ5xFZlaSTXcZdQ82B7FLuGooelDyIPOj7F94XJ+5SNo6/8YWHbHzhLRtfeNeNL7zrty+8p5Vsvanjp78ZP+oHtGjj+Hnj+Lxx/LJxfNk2vl0d7vWu4TzUm+pH0a4Pr6GGIwoLD1mF8XmmqO7bUlh4BiqPHRFzU2jhQbY0Ht2R9J7qOsoKNQeKwYOiByUPIgeyi1bp7GG1pO7lkV2JWkPJg+xh1C/DR0RqGNlVm14BmvZU5/M6ooWO4HHA9im6QgsdMS5e701RKHkQeVBe/U4GYg8qHiQeVD2oOdDCo6I0Vgx7syqUPYg9yO5yYhqRWqxLdoVjDVUPag5kVzjWUPSg5EHkQZ488ULvtfEGH6kboFQ8HVE8HVE8HVGyB7EHebq8LBwa4+NqvalRXUfqrFGaA0nwoOhByYPIgewVLr1+No5y1idqe43LJfTZt/69fjle3zwcvl42cv/+eHv27pG3/54Ps9eQPL883R7u3l8OpxeSTO8iOX1NkrKnWn6cHrDpm6nPnlPj0+apu/uBuadW+l77nv8H",
  "file_map": {
    "50": {
      "source": "use std::hint::black_box;\n\nfn main(a: u32, b: u32) {\n    // This version unrolls into a number of additions\n    assert_eq(loop_(5, a), b);\n    // This version simplifies into a single `constraint 50 == b`\n    assert_eq(loop_(5, 10), b);\n    // This version should not simplify down to a single constraint,\n    // it should treat 10 as opaque:\n    assert_eq(loop_(5, black_box(10)), b);\n\n    // Check array handling.\n    let arr = [a, a, a, a, a];\n\n    assert_eq(array_sum(arr), b);\n    assert_eq(array_sum(black_box(arr)), b);\n\n    assert_eq(slice_sum(arr.as_slice()), b);\n    assert_eq(slice_sum(black_box(arr).as_slice()), b);\n\n    // This doesn't work because by calling `black_box` on a slice the compiler\n    // loses track of the length, and then cannot unroll the loop for ACIR.\n    //assert_eq(slice_sum(black_box(arr.as_slice())), b);\n\n    // But we can pass a blackboxed slice to Brillig.\n    // Safety: testing context\n    let s = unsafe { brillig_slice_sum(black_box(arr.as_slice())) };\n    assert_eq(s, b);\n\n    let mut d = b;\n    // This gets completely eliminated:\n    let mut c = 0;\n    set_ref(&mut c, &mut d);\n    assert_eq(c, b);\n\n    // This way the constraint is preserved:\n    let mut c = 0;\n    set_ref(&mut c, &mut black_box(d));\n    assert_eq(c, b);\n\n    // A reference over the output of black box is not the original variable:\n    let mut c = 0;\n    set_ref(&mut black_box(c), &mut d);\n    assert_eq(c, 0);\n\n    // This would cause a causes a crash during SSA passes unless it's a Brillig runtime:\n    //  > Could not resolve some references to the array. All references must be resolved at compile time\n    // The SSA cannot have Allocate by the time we start generating ACIR, but `black_box` prevents them\n    // from being optimised away during SSA passes.\n    // If we use `--force-brillig` then the it doesn't crash but the assertion fails because `mem2reg`\n    // eliminates the storing to the reference.\n    //let mut c = 0;\n    //set_ref(black_box(&mut c), black_box(&mut d));\n    //assert_eq(c, b);\n}\n\nfn loop_(n: u32, k: u32) -> u32 {\n    let mut sum = 0;\n    for _ in 0..n {\n        sum = sum + k;\n    }\n    sum\n}\n\nfn array_sum<let N: u32>(xs: [u32; N]) -> u32 {\n    let mut sum = 0;\n    for i in 0..N {\n        sum = sum + xs[i];\n    }\n    sum\n}\n\nfn slice_sum(xs: [u32]) -> u32 {\n    let mut sum = 0;\n    for x in xs {\n        sum = sum + x;\n    }\n    sum\n}\n\nunconstrained fn brillig_slice_sum(xs: [u32]) -> u32 {\n    let mut sum = 0;\n    for x in xs {\n        sum = sum + x;\n    }\n    sum\n}\n\nfn set_ref(c: &mut u32, b: &mut u32) {\n    *c = *b;\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
