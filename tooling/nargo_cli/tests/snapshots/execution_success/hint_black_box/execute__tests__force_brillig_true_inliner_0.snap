---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "a",
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 32
        },
        "visibility": "private"
      },
      {
        "name": "b",
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 32
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "pZnBbhs7DEX/xWsvRqIoSvmVoijS1C0MGE7gJg94KPLvj3eoO84r0C40m9zjeHg9osiRLP86fDt9ffvx5Xz9/vzz8PDp1+Hr7Xy5nH98uTw/Pb6en6/+31+HBX9yOjyk4yHnEAkpIRpSQyykhfTDQz4eZAlJITnEXcSlhGhIDbGQFtJXKUtICnGX4iIhJURD3EVd3KW6tJC+ii4hKSSHSEgJcRdzqSEW0kLcpR0PdQlJITlEQkqIhtQQC2kh4WLhYuFi4WLhYu7SXTSkhlhIC+mrtCUkhWCOFlcZWobq0DrUhrahbpZ8yvoyNA3NQ+Hn09bLUB1ah9rQNrSHpmUhwFEAsCwAIRSCEirBCI0AZ5/elBZCImQCnCugEJRQCUZohD4gLwQ4GyAThFAISqgEIzRCH4BWCKCz0FnoLHQWOgudhc5CZ6FzoXOhc6EzmiQ1QCEooRKM0Ah9AFomAM4dkAlCKAR3zgugEozQCH0A2iggETLBnXMCuHNG/aChAirBCI3QB6C1AhIhE4RAZ6Oz0dnobHQ2Ojc6Nzqj5TIKGz0XUAhKqAQjNEIfgNbLqHD0XkAmCAHOqHD0X0AlGKERekBGDwYkApwrQAhwbgAlVAKcO6AR+gD0YEAiZIIQCoE+6C9ZAHiYrytLJgihELA0ZEAlGAELhAD6APRXAJwLIBOEUAhKqAQjwBmJWhcf5GddflZIhEyAswEKQQlwRg7RX4Kxo78C+gD0V4A7F6QF/RUghEJQQiUYwZ3LuiK7c0F+0F8BiZAJcEai0F8BSqgEOCMb6K+APgD9FZAImSAEHdO9ttUKLABjIRkLqbGQ0FYFmUdbFaQXbRVQCEqoBBuALijIPLogoAcIar40AMI7wC/WBeAXawL0ASjsgETIBBmAMtZ1R5MImeAfodi7oES1YLuDixWAiysgE4TgA1TcKiozoBKM0Ah9AMpPMS6UX4ASEI6RovwCGqEPQPkFJEImCIE+KK2KjFVeXHlx5cWoqAAlMBwVVZE6VFRFolBRK6CiAhIhE2QAnpl13RgiSt7fjwduVr+83k4n7FU/7F59T/vyeDtdXw8P17fL5Xj45/Hytl708+Xxuurr483f9QGdrt9c3fD7+XICvR/v0cufQxOWgDXYF/AtXKfi60R8xqq7xvsjb2d8mYj3uR3xYn0mHiUc8W3ZGT+T/4In3Rpfysz4i3H+iulMfL3H153xM/nXxPnTNBW/bPF5Zv5Kv8ennfEz86fK/Knqvvg69fnlHm/74m0m/3Vh/9Q0E6/9Hp/2xU/Vj7Z7vOyMn+m/bnx+9j4z/l7v8TP107ETGfF/rN9sf1kAitHBMc9ZbEl07FMWiq8lYaG5zSykS+KT3NGmHMQ2B5m7h+1p5Dh1D/7JdEhTBelHHtuOwr/573aYuoecWFOOecqh9M1BlykH+eCQ5kbR7g5zo6h3h9r3OtjUPUjn9tbPiOYcbOuL8ueH/N/be9smOPbdFmmmrv3UgplwnNssL9tuOU0tl34Yso3CT9imHPL2sPXjxN0OM4tO/vCtIU8t237O0zYHmcpDtvs9tDzloNtc+JnJlMO2+3a0vfcw5yDbquXYphxUNoepTbDP4LaHkKltjJ+8bZkU090OU7OpbRuF/lZRn/3V49P59r8fx97hdTs/fr2cxsvvb9enD+++/vvCd/jj2svt+en07e12gtP9FzY/4fgkVo/S6mf8xuEvsz+tcle8THi3l6P0+vkdN/Mf",
  "file_map": {
    "50": {
      "source": "use std::hint::black_box;\n\nfn main(a: u32, b: u32) {\n    // This version unrolls into a number of additions\n    assert_eq(loop_(5, a), b);\n    // This version simplifies into a single `constraint 50 == b`\n    assert_eq(loop_(5, 10), b);\n    // This version should not simplify down to a single constraint,\n    // it should treat 10 as opaque:\n    assert_eq(loop_(5, black_box(10)), b);\n\n    // Check array handling.\n    let arr = [a, a, a, a, a];\n\n    assert_eq(array_sum(arr), b);\n    assert_eq(array_sum(black_box(arr)), b);\n\n    assert_eq(slice_sum(arr.as_slice()), b);\n    assert_eq(slice_sum(black_box(arr).as_slice()), b);\n\n    // This doesn't work because by calling `black_box` on a slice the compiler\n    // loses track of the length, and then cannot unroll the loop for ACIR.\n    //assert_eq(slice_sum(black_box(arr.as_slice())), b);\n\n    // But we can pass a blackboxed slice to Brillig.\n    // Safety: testing context\n    let s = unsafe { brillig_slice_sum(black_box(arr.as_slice())) };\n    assert_eq(s, b);\n\n    let mut d = b;\n    // This gets completely eliminated:\n    let mut c = 0;\n    set_ref(&mut c, &mut d);\n    assert_eq(c, b);\n\n    // This way the constraint is preserved:\n    let mut c = 0;\n    set_ref(&mut c, &mut black_box(d));\n    assert_eq(c, b);\n\n    // A reference over the output of black box is not the original variable:\n    let mut c = 0;\n    set_ref(&mut black_box(c), &mut d);\n    assert_eq(c, 0);\n\n    // This would cause a causes a crash during SSA passes unless it's a Brillig runtime:\n    //  > Could not resolve some references to the array. All references must be resolved at compile time\n    // The SSA cannot have Allocate by the time we start generating ACIR, but `black_box` prevents them\n    // from being optimised away during SSA passes.\n    // If we use `--force-brillig` then the it doesn't crash but the assertion fails because `mem2reg`\n    // eliminates the storing to the reference.\n    //let mut c = 0;\n    //set_ref(black_box(&mut c), black_box(&mut d));\n    //assert_eq(c, b);\n}\n\nfn loop_(n: u32, k: u32) -> u32 {\n    let mut sum = 0;\n    for _ in 0..n {\n        sum = sum + k;\n    }\n    sum\n}\n\nfn array_sum<let N: u32>(xs: [u32; N]) -> u32 {\n    let mut sum = 0;\n    for i in 0..N {\n        sum = sum + xs[i];\n    }\n    sum\n}\n\nfn slice_sum(xs: [u32]) -> u32 {\n    let mut sum = 0;\n    for x in xs {\n        sum = sum + x;\n    }\n    sum\n}\n\nunconstrained fn brillig_slice_sum(xs: [u32]) -> u32 {\n    let mut sum = 0;\n    for x in xs {\n        sum = sum + x;\n    }\n    sum\n}\n\nfn set_ref(c: &mut u32, b: &mut u32) {\n    *c = *b;\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
