---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
