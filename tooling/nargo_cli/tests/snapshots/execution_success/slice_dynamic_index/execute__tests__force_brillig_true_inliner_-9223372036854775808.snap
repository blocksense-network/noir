---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
