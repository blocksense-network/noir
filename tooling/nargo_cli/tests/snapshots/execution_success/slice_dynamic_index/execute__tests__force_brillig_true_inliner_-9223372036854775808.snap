---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/+1dfYxkWVV/9dXd1TM93bszy4qoBIQofpCa6dmd2UCkF1qWxd2Vlf2SgGFmdtcoXyEGcCPKC0SDaFBEQf5QiASIfCiaCAS/EGM0UYmigOgmwkrkI8QgfgQjLnJn36n6vV/93qn7ut59VTXTN+l01bvnnXvuOeeec+65H9XJJqVT/O/T90zA7BX/R/OVkw3iGklCvWIwt24+9H9YfO9Cfa/Bzg6p3Sbxnx1dc24o+tcg/bvDAmdK/hjOBPhH6wWeH8wn+LkvoWwV31GH7J2Nr/8dzSafv7X4PKR3Usg2Ie9HxwX9XehbKE/J07Rt+PcL/FkC3N8LtDeIfzymn5qGN2P8NzTPmzHup6Wh/ZThv7F52se4n56G9l3D/31p8J82/Dc1z5sx7pvT0H6N4b+ledrHuL8/De3XGv5npMF/xvDfmgb/WcP/A2nwX2f4n5kG/zhGua3AnyXAfXvzuO813Hc0jvvkeLze2Tzusb7f1Tzue45kD8VAj5+gnopROI5CP8axHsOabUwZW329nLZ4r59NF6sbiP5Z3VpFf7j06Dv2KfDxNOBlOCtHskk81s/L7e4Vz0dzlDNnRyNrr1fgH2TTtGP7A4LfLb5vEv3G470D0nnvmXMn7909d++5a87dfffpC+euJPyhdIFPqJumQyjHpmPYgHM9Df5d05U16GtP9MnaVzrdqfhvuLjO2tokXE3HuF7fkH6T7U42Pe6QB1W41mriGmZ6fO810++xTAdOv7H9LQFfR6aq34jL5nds15poB3nYp/70BA0B/kZ4B98ze8TvWrw7IPhHdSY4byqebWfT9npAdUoG29m0vhlcYn0ZGR9sjPezad1G2rrZtE2yz8gne3Zb8T/YzbOdyTtVOorPWN59QQ/jQvo9ORr8s4r/iW3tiP0KtqX0huWfysd48uc2Q6kr/+cW/5X8UT5KZp78e8SfRPm9M1uij1asbgOemZ5ZHeZn2UZhLNOhuiNQh7EvFxX/2bNA1xM6E7wMZyVG/1KNC+u78RD1j9vMson+bUAd8n9Az14MvFhB/TurdMwK61gorH+oY6x/qGOsf0ehbh79e0dD+rdB+PeK76M5i/V9PP/JJrrAbWbZRP9wXCP/B/TslcCLFdS/65SOWWEdC4X1D3WM9Q91jPVvC+rm0b/N7gQvw1mJ0b8h4d8rvo/mLNZ34yHqH7eZZRP9w3GN/B/Qs9cDL1LoX9X3Lny3/MxQ0N4gL8+zzmFhnQuFdRV1jnX1GNSxrm5Tf7IsXleNF0E+n29IVxPxd6yrxl/UVW4zlG42bQNQNgN69jbgxQraytb17yD28FxvgpfhrDCfQtkr/o/mK7uKRx1q9yjR3lDb1yq+qRyVtb+ZTetvihzVUaKH+cO54S1B6w7VhbKfT+C4rieedR1cNzSI68aGcPFYnpcuXhtIZCcuKFtgRcn4CNU1ZQveGGELYvxNovEx4vGB/obbDKWbTdsP5PGAnv0V8GIF/U0tPQqF/Q3qEfsbjGnm0bG/aEjHEvmEEdsN1DFuM5RuNj0+sW8DenY/8GIFdexupUdWWI9CYR1DPWId28nK/Miyg+nYsD/By3BWYnSM/cpe8X00Z7H+GZ9Qx5Qv62bT4xN5PKBnXwRerKCO3aP0yArrUSisY6hHrGNXZGV+ZNnBdOzNgwlehrMSo2PHCP9e8X00Z7H+GZ9Qx7jNULrZ9PhEHg/o2VeBFyuoY/cqPbLCehQK6xjqEesYru3Mo2Mn1yZ4Gc5KjI5xPmKv+D6as1j/jE+oYyoH0s2mxyfyeEDPjnYmvFg9HTs5UnpkhfUoFNYx1CPWseNZmR9YdwLq5smVDtYneBnOyiEPy4V5ePXGBC/DWQlzF7UfgPcK4PoX7xXAtQmDW5ZctdFWN1f9OGf84/pXTzzj8b8u6OH32IZw//AdtWfIZGx71FgWofTzclt7xfPRfOVk6MO/gK4F/KXcal6uwzniWlG3Q3XIG97Lg3xR+294LRH5pez1U4k+5c9wv07T+/7Ondk9e+HU6Qtnzl+ze2732lr7/prcM2W8qdrvafWoW4OK9zpQj/BPhnH1iEIxE9uKXW/con0dEv1DAY/jle3gusCV0XvMj1As18f7BZ7eaYU/cj/QkPqNfeN4hsfZoOI91gmDv+US0gneR9UXuLJM6wTaKctxs07csQQ6oXyN8SzQ+S3DCRz3q5+3Qr8rXyWTuvLdEfD7ebnO20OZaA/JLtvnqn5vUL8Vn7yYrytwMY8GBBsK2zqDvbfTCn+kXjMvukC/+T88/9ip6N+PCDsWI49Q7Bye4i++O4u/+3m5zmBftAT8VXrF8UVvRv8Vji7hqJIj43om8crgf6ogPuj8S4rPyuaZ/JTNQ5n0i3faOkOh8hOKn55uolxs7O8I+P28XKfOEYX3X5+Aj4uwocru1bWhOwLe1qGZJ0qmFhsoWdWJzXrUhtUj/GuETWvS/y/iPBHyKGYsqPmQGgsmQ8//41hQtp7PElh76IvwTDjLzWDe6PgiNR/GcWZnk738Ln/n9kMxfrBO/Rr5olTnCZQviuEvnomv4u9bHP569jcUO5u9TW3wu+zDEDYU5q/Bvp34m2gdQ/LX2lr1PMVvCfke5inKdQb7vk4r/Fl4nuKDl5BOpM5TfHgJdOIwT3GYp2g6T/HRTiv8SZqn+JgTuyw6T/FPS8DfRecpQsH7aar4+IWC+KDzny4+H+Yp5stTfC0BHw/zFNOyajpP8d/Cph3mKebLU9hYOGieImYe3SuQLnIevZ+X6wx2WHy4VOfRTd6DEuMz2f7Ezr8M/rjQlcTnDMfjU8XbOB74/gS1bwdjeJ5/bQhcGb3H/AiF41SDfUS3Ff5I3d2kfmPfquw+9lG9xzph8I90dCLRWaBdT8aoE7wP6YiAR7lYf7ezaX3hM4qbFfwIhefkBvtt3Vb4I3UCz41d7H8+qfN8Mvarn7dC/27sGD6ofHcE/H5ermP/inXo542etuzgxgyexNhBLw+lbGqWTfsNhA2lKjd5dgnsYCebjkHqzNef4MRInjxC8ebrnA/x+Lufl+sM9vol9TMx83VvHy/DevN1xlW1r+DW4kMYvzcUn5U9NPnVnWcmur8wer7Oc0Fv3y2O/R0Bv5+X62LtIc7l35KAx4uwr3XjTC8PjPDePDCGx1mm7UbM+sAPw1h4jiMnLzZAfewX77SVc5ml2zE5FzW/VzkXuze5rpyMHhwLGbWt1u3t3nOW5y+AzH70UGauzOz+b+V3rc3Edtu9TxHbNNq6BI+fQ+Fc/csgLuEzMl3BO3zWJd71BD0ero7ApXQReR1Kn+r2iuej+Yo8A1PiXV6uQ11Zy8u8wLrbqU7lrdXY57i6I+pS57V4HKH+qZxuN5seh8gL9iGvdvQP9cPTGXVGq5NpXEi/2i/FucXXUmyc6t5K7z7XoBO/TLbf4EyXMKd/Z0VfXk996bbYl67oi9JrPrOINPKen4Pmq9+0BPlq8y08v3jzEuSrMdZYlIze5sho1t5HlpFas+LvKoZiGRnsu5bAJqi+jdc8iN5FxSRGW92Y5Hccn6DGJz5jn6BiNsaF9OMYZZ9g8O9fIvkrG9tWTKDk78UEsfL/wwZjAo5D8bO35h6K/T6SF3/xd2XrLf7jfv4Z6dEi9snE6NGi7+pmPYqNLf+yJT1iXKGY7UBc3jx7EXObEu/ych3mn3lug3V3UF1sXoP1T+V0U58t6BBdVb9VwHNr7Aeuuw/o2f0Nzq2rctr4vcqPWTzEseYDZH9S/SaIsj9rFX1AfqB+2m/JefaKvytbfEcFLz63BLxY9fMWXxIx++F5i3KdwX6l2wp/GjtvcdD9Pl91dOJy3e/DZ77Gvr/XCn/cddi6awHYr37eCv27sWP4oPJV62z7ebkO4wOOV1LbuvUZ/Y6xdbHnLdjWHeS8xYleK/xxbR3HGZiPwt+W7lT07+oCOPa8BY6Lm/OH/qc6b/HNS8BfpVccX/Rm9F/h4PxNlRwZF569YL7G5CEN/3cXwGGMPKb4rGykyVvZSMMdSr94J3GOZpf5lGXTcwNuH78jvMrv7gj4/bxcp+aC4f07E/Axtc2dxccYm+vxEeFj9nRk2fQ4CN+9fRsGewvo9Nmejw/le1MFvicAvn1Htkb7pb4nimWL8LYvY9YZJuOjt/7CfuAGx0epPqIu8ZqJyptnmW8rsX88976ZfNSi1rXuPNRPVz+9fUqon3ceQD+ftcT6+dwl0M+q/A+vWar/Webnf9Q91nVyQyov6v1+NcOiTFE/egKXxW51clY9B6fSCaPhx8F3vaBXhjGcLxJ629aZQsz9efFzh74jvJKZWj/muYgXC+zn5TqDfRmNo1S5e+9eoNDHn++V+VJXPwz+Jy5T2Q8q+BEKx4EG+6peK/xx18Wb3Mu6CPkqmdSVb8x5YbVPA8eN8rNV58Tr7u35xZpxgLe3R/nRLNP2qwP1VfduvWGJ4wDun/qfZXFxAM/77T3WKY6zDEb9zkAVjjr3BCAujgM8ujrZtMwVTsvF8Xz5PRAHvJXiAMP5NkdvVcyt+G/PZ90VELPHLsv0OPNyhgb7btLzVHvFlJ7j/QQfIj9dV34G/94llQ3vL/Ty5Qb7fpLNItaivflx4r0q117cL+HMvwdE06z9oAeV746AZz+KdhTnxx9y5sdse2fNfb31gzpzX/Z5Bvvnh3Pfhc19Q8G1irUadLH+zJrb2Of1mvAbkfA8H/gy+NSPV8yt/8GZX6XO6c+aX8Xk9GPnV7yOepD51ad6rfDHXefjnN4Dl/n8WNlwtrM2fj4veLVKZy9n3d0Wc/Yy5o4y5YOr5qsPNpTn+a/DHN+Ufu3n5TqD/b8lyfE92EKuolsgWsZcxUZB2+UUt3WonUGD7aj8grJbVfGhOrtbhYPjug49n7Wvxeo2HLo8m8i22uqRhtMF48P3b+iXYQznN4rx0ZbdVDF4XbvpnUnw7OZapvkRyn5erjPYR/db4c/c5wZT5RtYDnheQc1zuoJP3rmxbwddbOPcIOLqCFzLdt6nibsM+LyPisuUPcWz7K8ZTJ4fxD4Z/BnH9qSeO86yPTFzx1jbw3NHz/bw3NFgn9RvhT+N3uXvzXUWIV8lk7ry9fb7xdwzk9o2j+1SRT+Mtq7gA/aJzzbc5NjmruCdyt9eyvfMlHiXl+vwHALbZqy7LS/zAu2msqtVc467hF2te/8a8rxfvNPWuRDPP3P7zEMvr+HxXNltazO1zeV+VP2OOsdVsb+jfk+DcVVH0NMR35UdeGpehjf61uBdhOlW9Od50J9bhhrnINO6UIXzhU4scpT6tVd8H81Xxvqu7qxFPmP7+B3h+R7eULazaT3BdxGW+REK359isC+lWGQRdxjHjNdU5+9Ybjheuc1QuoJPKPMBPXt5y+M19k4tg3/lEsi/yf3fqe+w9vKM3H6VPfD8GcLb/K5urN7Jlos/SuZN8Oeu/KH/KlZn+5EqH9shOqvu3+FYPfbelDc0GKt3BD1D8d5eM7w5z7wxOkOJvZMF5RhKH+qangfcSuOoZNfzch36Xp4HoI9nnbT+4NrHU/IJDN9fYPBvddY+vBgiFPt9W7X2wTHE0Yr2VbxlsL9JPmQL3kntQ6wt1TfjAet4Khtg/FA+GGnrZtN6gnJg/v62YwM68J43x2b7ybzC70g/jl2+u8bgf4/knyjGlvLneFqtc+NY8O4Rw3e9sRjKXcQLg/39JeBFzFhItD/BHQsqj1x3LPxJ4rEwFO/tNcObC1X2OhQbW0in8ocox1D6UJfaH25NSJzyh8egjv2h1SmbY/2p8ofsjwz+I44/RFp6gnb2h6gH+C5+H2TVOjMg2L8nG7AN76S2AdaW6pvxYJhNyyWFDTBa0AZgm0ZbV/DJPiN/7dk/OjZAzSfwGduALUEP40L6ceyaL2Hd+NQSyL/K1vBY4LvckAezYkM1F2N7/a8rMhZS+WlvLGCbBx0LX2x5LBh/QjH9R1zKZyGvQ+nnZVx7xfPRfOWiz3o1+awS7/Jy3RVQZz7LdGUH+mtw29k0n7ahbwibSo9Mz1GPsE2jrUvw+PkiL+jZ/zp6hPZC2RDWo21BD3+39negnnPUYz4XexSGok+pbYg9i5H9TiK6PNnvCN7Wlf16wd9UsmdcSD/aI55fGvzWEsjfs4MqdjdaT6ShdZxvPT5pesxTlIG1r/TX3lU2G3U7lH6epB8XbfZ7yGaXdDWffEa6pmxENh2PG+zDSX+OZ0n6IvXH2lJz8iuzMl2p8mZeDKL4VzcGeaRjPzrwXsycnMebwlVlP6p+N+axJP9FxuMdajv8x72AfP+h9Q/X1RGG7yg0+MeBTHhdnefcLBO2wwb/XYCT19UTjamTbOe6QDO2ybrCsW8osWsOV1JdH+qszfEZrDxNvwOPP+HEshavWt0JqFsv6nZE3R1AL9tMpV+oKwh/ndAFjlOybNonhcJnaJVN5O8qB8v3hxvsk5bA3nv8NT30+PvkOfjr3c9eh788pzfYpy2pP+V4PFWcyDYJ/ZHyX13BJ4zbBvTslgb9KfsfhSs2Hjf421ZE/qn2snjyV/nhuvJ/Vsvy72Q6FuE9fkZf1R6/9Yr+PNeJRdT5d+wP66DBX3BikURzrnEsYvgxFsE2mc/qvJo3Z7w6Df3jOePDJk3LOePVRL+CfxjA8BzzKqgzOG+OqeKsE8CTUAZ5Ep5cjLO+aXNCB49NzgsqW5R6XsF6h/ZGje9uNq2TGAMO6NlLGrQ3KiZX55P4fv8B1CH/EY/RfRXU35CX6wz2J8lHJbIJ0kfxePB0JhVdHeIV6oyyVd1seuwin5n3r0qsM4xL/R5ZKFVz/p9dghgFz9cpXbDxoPYvDqhO7SUcZtPjKoUODYQM1FnDbjY9lvFMON+h8kuODvXgvZi90by3S+Gq+9uSv0o6tIi7FTx+dOGZt68J38X3YuZ8BvvrxItU+2kP7zdY3P0GoeD9V+s16GI9HVS8x/Z9oyb8MBKez9zeXzA8fH/voAxjNP+uM6dIfU5u1hnmmHNy3u/V9wSuLJvWA7YXVWeYPzhohT/u72Px3ss/cOSX+j6mWfKLuY8pVn68T7Xqd75Dqfp9sz8VvFqlM+GKf8ijmDPhKBOej+D73m9yWZvLcl8HnzOJva/jb5xYrO45ExWrerg6AteynQlv4r6O26hO3YE5676Of4+4r8Pzhwb/z5e5rVS+bj8v1xnsZwet8Mf9bfBVuptw1n0dB5WvGlPeXfodeo/nb1lWHlMp5+ireo/T/yz5HP1rNDYXeY8X1rH8U82XPfkzj7OsvvwHhRI1kefjWAA/qzlsbH6D74PjdSikifeYjn+rpOjnIm18jB6l0m+2xSrfqvQo9hzz8Zb0iHGFErvvB3kdSh/qUseXJd7l5Tqcu3B8iXXefXCeL2T9U7HYsuSaeX4Tm2t+jKN/dec36t4mxlXlx3g92+C/g+zPInPNih+on97+InwXv8fs3zLY0RLw4jDXvPy55lS5Y/u8GQnP88UXFh/CvyevlWGM5n2wRzz/Tn1Hi5pvoR2LuaNF5c62s2kdwHdZZggbCueaDfamtVb4495RxPnTWxz5LSL3ifI7aO5TyQ/f5fdYfpxrtvFzu+BV3XwGttMv3mlrbUbxD3kUszaDMuF8Br7vxWLW5rLMBTgWi50LnG8wFlO5bw9XR+BSuoi8DqUPdaswFzhortnaDv1/1drkufLhsf7wxZe5rVS+bj8v1xnsfWut8KfRu6E927wI+SqZ1JWvdzd03fm10YNjat5cs7J7y+IXjLa6fuHnHL/g/cabtRWKyhHx+viaoL8DuDjXbPCvW5EcYeq1BiV/5nGW1Zf/G1vKEXo+IZQ6d4R5+Q3ONRvsm5dAj7JM+2xcv+H8jMH+Bsxv39eQPbsU187e6ehzirUzxKXGxuFvoEzqcE/FoQ5PCuvwHx3qcHIdvr2o89Y227rDVPl25Uvr+va/btC3eznbjqAfdavqTOvfLWlsx/JPvY9gw+HfPPL/ZEvyV7EdjlFv7YpjI56/I002Zrmfn16C+XuMHqXS7w7REnv/61D0A/lrzz7bsh0xXKHE3tGKvA6lD3Wp/VGJd3m5Lva3iw66j4D1ry/qUq/pGo0qHsI2jba68dBXHP3DteGeeMb6NxT0MK6qHAXfPWrwD5L9WcR+OI8fqJ+2/uvF3fw9Zh/BmHfri+dF1T6CVOv7HWpnrcF2VM7RvvOeO8TXhzaU78HP7D8Gme8/eA0wlL3i/2iusnuKx/4Tiw+BD1eul/tr9J4ons+z1on2p5+X+5l6b4DKj+O4idkbgHbNZKbuXDeZqbk1xyup4ijuR9XvtfFaZ+zvPz0K9GHetU619urh6ghcyxavNPEbK5yjQfvGv3uQev+iijtU/FQ37hg5esR2vEr2dX4DBHEpnVz0bxPUycPE6pGXL+xQndoTF549Z738DsYtnh/j2OVJwo+0tabq7cXn9vE7wqNec35DzQsy8R7ChmLrr3X9KeLoF+8s0p9i/5v0p7w3AWVmbba1Rqzm/97eodj5/60N+lO1J8bD1RG4lC4ir0PpQ90i5/+oW2wH1b3W3v5hZQetbbSDyifzuolaq1e2ou19DrN0mHMIsTp8j6PDdXMIaox7uGJ1eJFrKvPqcCh3UZ3K/Xg6rPSWc1ip12LUnMRbi4mdk7y0wViSYwGFS8XCoXAOy+BfTnmbRez35j7V2R/xCsgTvI7soIqj2lrbUTlFtWbdzabtCcqNY9WfbtAnqzl3Fa5QYn+DBnkdSh/qUtuzEu/ych3G2mzPsI5z8rE+2dqepYveXgbPJxvcqvvkNzXok1Xu08MVO79GXofSp7q94vlovpLMJ99OdXV9MtvZD4CdfbsTb7btt01OsX6b7X5G/bVn727ZbyMupe/LZmdLvMvLdTF2NnzeJD7F5oCs7fDsAw3Nfbz9ZIvOYx50P9mHHB1uYj/ZULy31whvdi8wb5BONdYutXkV8tXbU7ns8yp1x4Bnn2PvGPhoYvs8zKZ51yB/znv8UXtluP+fpHlbqj2vat7G5w8GQGNM3t3g73fy7oliW/feLNQDloGyQ8gHzrurscr8GwhYvm/TYD+zBPsrVN/Ynix677XRVtdXfsGxJ2iHeuKZZ084plF65O3T8fSI94EgTXy3tMF+mfRokXtvPT1KPbedda6O9Sh27+1XWtIjtfdW+THF61nnkpAm3ntrsIZkGfTIi29S731UeqTmMXX1aG1jwuYVjG/G8fusNVbWU+TPrPwwwrLfHOMlPV1Efjsxr+/uEA8Owmu+p9zjdS/TvH4Y8TrVPjJvP/7hHtDp/bsG+/JCPgHvozYmdCAM40L7gmc0YuYqBv9YsGUH3aeJtrJfvMP7URvWM3dfiRo7seOQ5+4If0v+0P+Y+wFXdV/JKce31V3D2hD0eLjUeFO6iLwOpQ91i8wdxZwrQRsQEyOlPp9kdMWeT8J+YH/5rqvrE8dIHq7YdaRF5uhLvMvLdXVzkMoebULfUvr7DtHV9L7xZzRojzYFPYyr7n2ldyxBDKvsCMt/VffoPLtBO8KxgMKF4yr2nCPyOpR+Xsa1VzwfzVcu2pFXU+zlnRvYgjqzI6YruN/b4LbpO+I3PTqWJenbWI/sdzxRj44JWrsEj58v8oKePc/RI+RTTzxjPToSyTseg6l/F3VH8G7b4d0O1Nln5J09+7EGebcp6GF+WfvqTALHGfeR/d2id/aK76M5i7K/W9S32DVy05/w7LUF/aY/KoZvKxZUcwps02irO6d4paM/KueOz7y17ph1oI7AtUrr0bFzinnXo5Uuoq7X2a9xKerwGw51OKkOh+LtVV+VPRVqPu3FwbHz6Xe0PJ9WeaVQqu4Neg/54UX8Dib3qc5e9fdC/vXDjh28VPZQvm9B+ZlQYudVq7yHMhRvr7rxZdYeyg/P6ZNZj+zzsvoVnt+W9pnl5TolB3UvMO+RUTxsazyrPTLeeI7dI/O3DY5npaf8nfdAhcL7Wgz2E+QbFrE/inmB40DtrVXjAHUllH6epB9yHCCfeRzg+huPA3X+HGm+iE/A8jqlwT5Asky1h2PWbxJZXmM9n/QJZXURDusIJhSTteHagLojEbiOOLiGDq7NSFxe20hrn/AfLb6vVeAfEvxW8b0P8OuCngHh/zeImb62UYYxnF8CmP8EH3sRNp+0wbI7hnUCHm0Ww1tfQ5sPgr6Gsg3tNL0eXUU36oK1r3jQqfiPuPCZtbVJuJq2R03KxMN1LBKX8RPlGz4fgX3KoSSS9SnuQzfT48zaN3p20tAz1r3t3Oeptd+E7llbbeme6punewjPuqdwbUfiMn4qfdtKw4NdtutZBQ+wffyOdh39n73LNvvhwzIexS/0YeaLxvlwqNukuiug7ijRe2U+TS/i2iZ6ryR6zfcqnd8R7R+j9rEt1T775SsE/BUC/uI9ecTTNfEuytd4GmIdzKXY/8CjveL7qGa5cM215y+cvubc6J6T4espjrWQdoy1PH9t/UHZqfE5IPhHF3wJPHoMxLwXcYn2AtwZGncbQEsKO1+KMYkebF/FpPY5Ma27Hq3rglbF47o+YD0vPxuKtpFP69R2KQ6mOvSjfWrHxgnqGuIyOjhevYbsBMbQ9v6OaB9lxm2p9mPidxXvB91+fEHjOI8MbTfpV3Ec4Rgv2SVoOxSTH/J9TfRjQPBPhDH+PTTGlU0JcDc7cHX1tJ+Xn83SU4Ovq6cYA4VyUD19+gro6VNIT1PHf2uEH58xbTeDXjftO0+dPXvtdafOj06fufvCvXef3o31nYd5isXlKZ4N9ucFwzKM4fwhgDkfYaOazlM8v52562GeIltMnuL5oF/3HeYpMo+nh3mKalwHyVPctyJ5CoRHHH2CP0b0h4J+hv2S4iO2GZMH2HTg7fsg03mDTahH+J+hOA9zB5y3wD5cUUFvJ4vLW2wLeKVXQXdeQb4QYy6T0ZFseo6QZXGxjJorGy6eKzN8Py/jKsX1hMtkgLHDUNBlY+Qotb1XPB/NV3ZjYz5rf0D0vw78yK/UiFNmjUm2JSoXFdp81xLYEhzr1n4TvsLaastXNCETD9fRmriW1T+oGEzNe8d78aHuCNWhXeT8s9lVtBHKpw4I/p1kx9G32Ps7on3uZ6y/r5uvDuP2rWA33hWRi1b8jc0TqXljrA/YjMC16eDacHANI3F1xPue/2GbHpsfM/j3g2z+mGRTsun236FB+Uw1B18FG8fya8LGBR5/fAl8GOrd5erDmpSv4VqlOQ7aoz7Bz5qz8Lqq8isp11w/tgJrrh8Bu/pxsdaBdjEmXvZ8GMryaASuow6uTQfXkUhcXttIK9qHUEx31irw85g1eaL+qLk451sfANn8B+VkDednAOZzzjyUZafGjvLDam6NOekvk59YRF4MdYHzYtinefNia2n6drJJmTSRFzN+onwv7l9sR9anuA+Yk8VxZu0bPVekoWfXs8Mq59SE7llbbeme6pune94cMdZfKVzGT6Vvx9LwYNeLP5AHVTnNqr1j9i7b7K3NMh7FL7W3Q8UqPHe/Euo4vjqeT9Or8qkDgjd6zfcqnd8R7WMOldvy4pKOwNUTzzCOWSOeKvvn7ZdROdktB17JDHFwzMC2KRQvtr1SwHu8Oi7oQRoRXygnBPy2A2/fMX+POKpi4EeQ7lwF79j7O6IPV1XQ26lov4ofCH9cwAfdOVHQuKgcvenK5ZSjf2zB88D/7yw+x8Sts2w0+xaEX4YcLtKK84jrN8u0LcLX4Zxk7KsE3XVjGWurrVimCR3xcG3VxLVs+sbxC8J7cUfbawZ75DuWcc3gOrBj11MMonTHi0Fm6RrHFEp+3p4Ataa9XhN+26FHxXdKZl6sanXoqznuNr+P+oS4jI4BwT+D9EnFRyoWwXkut+XFpV5sVhWL3AixyP8D/UlinEGdAQA=",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
