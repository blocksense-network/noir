---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
