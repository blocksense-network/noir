---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "directive_integer_quotient",
    "directive_invert"
  ]
}
