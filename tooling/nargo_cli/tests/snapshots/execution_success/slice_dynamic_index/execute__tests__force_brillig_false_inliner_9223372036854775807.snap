---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "directive_integer_quotient",
    "directive_invert"
  ]
}
