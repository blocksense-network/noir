---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "directive_integer_quotient",
    "directive_invert"
  ]
}
