---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
