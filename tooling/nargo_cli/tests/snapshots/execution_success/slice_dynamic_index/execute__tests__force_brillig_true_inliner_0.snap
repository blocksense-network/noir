---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
