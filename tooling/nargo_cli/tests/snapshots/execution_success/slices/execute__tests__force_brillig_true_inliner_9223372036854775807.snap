---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "50": {
      "source": "use std::slice;\n\nfn main(x: Field, y: pub Field) {\n    let mut slice = &[0; 2];\n    assert(slice[0] == 0);\n    assert(slice[0] != 1);\n    slice[0] = x;\n    assert(slice[0] == x);\n\n    let slice_plus_10 = slice.push_back(y);\n    assert(slice_plus_10[2] == 10);\n    assert(slice_plus_10[2] != 8);\n    assert(slice_plus_10.len() == 3);\n\n    let mut new_slice = &[];\n    for i in 0..5 {\n        new_slice = new_slice.push_back(i);\n    }\n    assert(new_slice.len() == 5);\n\n    new_slice = new_slice.push_front(20);\n    assert(new_slice[0] == 20);\n    assert(new_slice.len() == 6);\n\n    let (popped_slice, last_elem) = new_slice.pop_back();\n    assert(last_elem == 4);\n    assert(popped_slice.len() == 5);\n\n    let (first_elem, rest_of_slice) = popped_slice.pop_front();\n    assert(first_elem == 20);\n    assert(rest_of_slice.len() == 4);\n\n    new_slice = rest_of_slice.insert(2, 100);\n    assert(new_slice[2] == 100);\n    assert(new_slice[4] == 3);\n    assert(new_slice.len() == 5);\n\n    let (remove_slice, removed_elem) = new_slice.remove(3);\n    assert(removed_elem == 2);\n    assert(remove_slice[3] == 3);\n    assert(remove_slice.len() == 4);\n\n    let append = &[1, 2].append(&[3, 4, 5]);\n    assert(append.len() == 5);\n    assert(append[0] == 1);\n    assert(append[4] == 5);\n\n    let mapped = &[1, 2].map(|x| x + 1);\n    assert_eq(mapped, &[2, 3]);\n\n    assert_eq(&[1, 2, 3].fold(0, |acc, x| acc + x), 6);\n    assert_eq(&[1, 2, 3].reduce(|acc, x| acc + x), 6);\n    assert(&[2, 4, 6].all(|x| x > 0));\n    assert(&[2, 4, 6].any(|x| x > 5));\n\n    regression_2083();\n    // The parameters to this function must come from witness values (inputs to main)\n    regression_merge_slices(x, y);\n    regression_2370();\n\n    regression_4418(x);\n    regression_slice_call_result(x, y);\n    regression_4506();\n}\n\n// Ensure that slices of struct/tuple values work.\nfn regression_2083() {\n    let y = &[(1, 2)];\n    let y = y.push_back((3, 4)); // [(1, 2), (3, 4)]\n    let y = y.push_back((5, 6)); // [(1, 2), (3, 4), (5, 6)]\n    assert(y[2].1 == 6);\n\n    let y = y.push_front((10, 11)); // [(10, 11), (1, 2), (3, 4), (5, 6)]\n    let y = y.push_front((12, 13)); // [(12, 13), (10, 11), (1, 2), (3, 4), (5, 6)]\n    assert(y[1].0 == 10);\n\n    let y = y.insert(1, (55, 56)); // [(12, 13), (55, 56), (10, 11), (1, 2), (3, 4), (5, 6)]\n    assert(y[0].1 == 13);\n    assert(y[1].1 == 56);\n    assert(y[2].0 == 10);\n\n    let (y, x) = y.remove(2); // [(12, 13), (55, 56), (1, 2), (3, 4), (5, 6)]\n    assert(y[2].0 == 1);\n    assert(x.0 == 10);\n    assert(x.1 == 11);\n\n    let (x, y) = y.pop_front(); // [(55, 56), (1, 2), (3, 4), (5, 6)]\n    assert(y[0].0 == 55);\n    assert(x.0 == 12);\n    assert(x.1 == 13);\n\n    let (y, x) = y.pop_back(); // [(55, 56), (1, 2), (3, 4)]\n    assert(y.len() == 3);\n    assert(x.0 == 5);\n    assert(x.1 == 6);\n}\n\n// The parameters to this function must come from witness values (inputs to main)\nfn regression_merge_slices(x: Field, y: Field) {\n    merge_slices_if(x, y);\n    merge_slices_else(x);\n}\n\nfn merge_slices_if(x: Field, y: Field) {\n    let slice = merge_slices_return(x, y);\n    assert(slice.len() == 3);\n    assert(slice[2] == 10);\n\n    let slice = merge_slices_mutate(x, y);\n    assert(slice.len() == 4);\n    assert(slice[3] == 5);\n\n    let slice = merge_slices_mutate_in_loop(x, y);\n    assert(slice.len() == 7);\n    assert(slice[6] == 4);\n\n    let slice = merge_slices_mutate_two_ifs(x, y);\n    assert(slice.len() == 6);\n    assert(slice[3] == 5);\n    assert(slice[4] == 15);\n    assert(slice[5] == 30);\n\n    let slice = merge_slices_mutate_between_ifs(x, y);\n    assert(slice.len() == 8);\n    assert(slice[3] == 5);\n    assert(slice[4] == 30);\n    assert(slice[5] == 15);\n    assert(slice[6] == 50);\n    assert(slice[7] == 60);\n\n    merge_slices_push_then_pop(x, y);\n\n    let slice = merge_slices_push_then_insert(x, y);\n    assert(slice.len() == 7);\n    assert(slice[1] == 50);\n    assert(slice[2] == 0);\n    assert(slice[5] == 30);\n    assert(slice[6] == 100);\n\n    let slice = merge_slices_remove_between_ifs(x, y);\n    assert(slice.len() == 5);\n}\n\nfn merge_slices_else(x: Field) {\n    let slice = merge_slices_return(x, 5);\n    assert(slice[0] == 0);\n    assert(slice[1] == 0);\n    assert(slice.len() == 2);\n\n    let slice = merge_slices_mutate(x, 5);\n    assert(slice[2] == 5);\n    assert(slice.len() == 3);\n\n    let slice = merge_slices_mutate_in_loop(x, 5);\n    assert(slice[2] == 5);\n    assert(slice.len() == 3);\n}\n\n// Test returning a merged slice without a mutation\nfn merge_slices_return(x: Field, y: Field) -> [Field] {\n    let slice = &[0; 2];\n    if x != y {\n        if x != 20 {\n            slice.push_back(y)\n        } else {\n            slice\n        }\n    } else {\n        slice\n    }\n}\n\n// Test mutating a slice inside of an if statement\nfn merge_slices_mutate(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n    slice\n}\n\n// Test mutating a slice inside of a loop in an if statement\nfn merge_slices_mutate_in_loop(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        for i in 0..5 {\n            slice = slice.push_back(i as Field);\n        }\n    } else {\n        slice = slice.push_back(x);\n    }\n    slice\n}\n\nfn merge_slices_mutate_two_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n    slice = slice.push_back(30);\n\n    slice\n}\n\nfn merge_slices_mutate_between_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n\n    slice\n}\n\nfn merge_slices_push_then_pop(x: Field, y: Field) {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(slice.len() == 4);\n    assert(elem == 30);\n\n    let (slice, elem) = slice.pop_back();\n    assert(slice.len() == 3);\n    assert(elem == x);\n}\n\nfn merge_slices_push_then_insert(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n        slice = slice.push_back(15);\n    }\n\n    slice = slice.insert(1, 50);\n    // Test that we can use slice insert the same as slice push back\n    slice = slice.insert(6, 100);\n\n    slice\n}\n\nfn merge_slices_remove_between_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    let (mut slice, elem) = slice.remove(2);\n    assert(elem == y);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice\n}\n// Previously, we'd get a type error when trying to assign an array of a different size to\n// an existing array variable. Now, we infer the variable must be a slice.\nfn regression_2370() {\n    let mut slice = &[];\n    slice = &[1, 2, 3];\n}\n\nfn regression_4418(x: Field) {\n    let mut crash: [u8; 32] = x.to_be_bytes();\n\n    if x != 0 {\n        crash[0] = 10;\n    }\n}\n\nfn regression_slice_call_result(x: Field, y: Field) {\n    let mut slice = merge_slices_return(x, y);\n    if x != 0 {\n        slice = slice.push_back(5);\n        slice = slice.push_back(10);\n    } else {\n        slice = slice.push_back(5);\n    }\n    assert(slice.len() == 5);\n    assert(slice[0] == 0);\n    assert(slice[1] == 0);\n    assert(slice[2] == 10);\n    assert(slice[3] == 5);\n    assert(slice[4] == 10);\n}\n\nfn regression_4506() {\n    let slice: [Field] = &[1, 2, 3];\n    assert(slice == slice);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
