---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/+1dW4gt2Vmu3V21e3p3795973OdEUIgQWbo7t1nzpyMhDYa8RIMSqKoE7TPyRkcJHh7iAMh7IBKXiQPY2DMQxD0xQnEgUQfRkUjIURmkBgTMBEiQlQSBS8vkgS8VE/93d/+9lf/ruq9Vu3dl4Kmqmut+m/rX9/6179W1W4lrx+t4i8/0uI8l4weVuewOO9OduwFpLUbU85WJDlPBMXrVlJu+C8vvH5eTIYbKS+fD6jwopApFP2ndg+eXBT6BZS/vwg0I9DfN/ppHPq7RTMn3z8Ypp8Q324y3HnxGSvDjvz2ouyRotyuV4rrRaIXo91RptB22xDyG6+lQtcvt4d1TcE+oeQw2u04ep743yNx6PfNhgtgm3mhk/E3X8ugfqvkbLS4zHh1iFZobPN0Q/nNb1apPtugjNZCTVqLoixGm7YdvZF/15FV6ZEGtElKNkGZD8PY44j1zZJRbGpTmdV9I8kXqR/urgPdJNF9DvG9Tp9L4Fnle0k4PfZWhW0XGrKh0V+MQ3/P6Hfi0N/vAs2EbJX75xNwP/9bKv7PktN+h892oBzr/3X7lOZeca9X1FmG5+foeSu7kwy3Z6wxXvWJOZIXeWck13Ikucz+Flelyan9lf3mqD5eo33t3tPFOW/7v2+fPsMYMC/uMdZmQh7+PwP6VsZjFcp7WJx3Jzr2DozXiiNHl+RYhbIY84j1SPRNrzWw47zQyfgbFvSgfh3MR14dohUrzlK6ofzsm2sgD9qgjNZaTVqLoixGm646eiP/riOr0iMNaJOQtBgbYvVJjtN+vjjn/N9dXFsdw5D7UOcni2sbK7Bv90iHjTg6nIwVmwU9HCuQ5zrYHevjNepr995TnNVYsQ7PzYt73MY9IY/5LI5rq1SGvmE0clEeOjQ6Do3MoYE4t0xlS1C2BjR+waHRcWhkgoaKk+yZyHizy+2KvrQm7DKXjPo9tn9G9365OCtfWobn5sU99qUlIQ/TQvmxTVZJPqv//uIceayWcec68Y6Ub7zj9d0l4pkfyh/xWXwuE3V53mt1P5hM39a9pLxPNhXjq76m+n7dvvbrxVn1tSV4bl7c82J8q9cVz7VKzsaH73l9mnFzPSAftCG3d6Rc4QHHGp8sznnTfIRkiITvB0Z/Mw79k3jV4g5rD9bJ+PO4beXqbLS4zHh1kqj9dc/TzRunMAZDG5TR2qhJK3J86c4r0dbGv+vIqvRIA9okJK12QFrmrzbeqFhqVuYJa6APY4U3T/iD4qzGm7pzwWUhjxojMipDXDcauSivFtex5+tX+Hrm4wpfHb0vIr5eBkz8XHFuEhM53zcOE718g5of8dxpTTwXe07H/oftti7sNJeMtin6aUb3/rY4h2g3lTNiWmVzv4zks/pfKc6x+4eaO28Q70jjwZMexqjcj/JHlhXnqodh5LzDvLKkvF+wn/0jyRcpbpDtuEm8I/nQyf6irTj0+4zhSaIx3PhzPpjtgmejVWa7TjLa1jFiIqWbhznoRzzmKlqbNWnNapyrZFV6pAFtwvsnUeY6fqX4YNtxPmwzIB/Ux+zL+artgkA+HH6LZME2wf0k34H7ODbjfhLuO8jb6v8v0PwfuO4XMqn1N7OdlSH+mL4mw7bQH+XegXveOpftJZgfnD5vfG3PUDoY1vewuL872bGX2/1r7VM5cvrXQMZsMFx2HcraRdkqlaFtlI2vgW4RMf4k3jNZMF5CnrzGuS30OLYF61b4UYg1zmtCHtWfd6gM+yDSKJMB+435luqP9iz2x9h7UYz+diT6ZpctYRfUabvELlauzkaLy4xXU2O+0s0b81U/8Ght1aTVVBw3ztc5jlOyKj3SgDYJSct8TOEr56DOK74+ERBfFbYpfOU8iIpxVAyh5o+qbTapTO21iT2vY//DdlOx8Fwy2qbopxnde9ppt7q5PxWbRZ573vXso9qZ9X9ba1jOSOOZnJ9vk40ijTf3uO8niZ9LU/E0y4r99zCMnAfMK0vK8Ynx54epHXfi2FK24w7ZJhKG70fWre/5yZbQd9J9G8irk4z6Y4yYy+sD+cGYhnjAY7qitV2T1qzG0UpWpUca0CacZ0GZ6/iV4oNtx3mW7YB8UB/GKqv7oYJAPtzeJ9yKFEec7Au6Fof+iZ+pPIqa94bADuPVFHZUzRGtJqM4jTYoo7VTk1ZT48Gmo7caD5SsSo80oE1C0moHpGX+ajEV+gHPIWLFLCaH9b1U6IGyzSWjWDGUZ6R7HyiUVHOIunl3Nf9SGM77ghTu5qJ8vBl87V/h65mPK3x19L6I+HoZMPF3poCJnA8bh4n83tvvtk7rfLq4Vnkx46naD3nW6dNqXQ37YX6kUHYe1tW6ZCdvXS12/tDkKssfct4X9UB9M7r3h46fh1xXU/kH5edGI4QPMwblx2Fx3p3seJbxZ5yNZq1/DPnEYLjsBpRx/7AytKtqn+ugWxP9w+Sq2j9QD9Q3o3ufDdg/rgt54uVj9x6ybVDOa0JO5aPYjvmRQllsH70JMrKP3oIy9lErQ7v2klGMugm6cfvE8FGTC30UeZpsc0IP1Deje19yfFThk2r7VbIJ1lMYfoPKEMONhlqHYJvHWq9h/dHmKjdaNz78mmPzumvNN4U8TAvlR+xaJvms/tcL+SLPa+V6Cu+NUT54U+ig/AWfxf/V2hLv4bW63yRb3GjQFjdq2mIjkC12SmzxHzNgi8jrbE95457qa2psuEG2vlFiTxxjOHb4b7L1zTj6SlszzkZq55M1zVtx6J/kWDAWUDho/NX8r1VyNlpltuskUbFzz9Ot6hjN+KJo3axJK7K/9r3+qeKzriOr0iMNaBNe02RcUGfjw/eYD7Ydr2neDMhHxXS8pvlEcZGHMr3iOnKMdhA57u57Yy7qZPwn3bePvDpEKxZ2KN28XCT2L8711Z0rKFpNraNsO3oj/64jq9IjDWiTkLTaAWmZv1rcg37Aayex5g0mh8prqraqm9d8c2EANT+ru8dF5RYVhvOaJuKu0chF+ZFm8LV/ha9nPq7w1dH7IuLrZcDEH5gCJvKa5jhMVOs5Rk+1DdKr019Vrhv7WH6kUDbN9Ziz5rrRhrweEzvvqnLdqk/VzXX/tOPDddflrwt5lA9zHhx97jrJaWvxPwfzqV+ZGy/neViPGXp/aDBcVtVHeU3dG+PO63rM+xwfrTtGqbVx5aPsv+ijRgN98Qpnz+7DvO59EXH2QzOKs4uC32Fx3p3o6O8zhn8MMPzDhOEqXjoPGD7U5oPhsttQxv5vZWh7heG3QLcmMNzkqorhqAfqm9G9jwbE8FtCHuX/HEej/xuNXJSPEYZjf2cMr7LfIT8Oi/PuREf/AeMS2kjNJ1T/wL11+ZFCWez+MeQTg+GyR6GM+4eVoV1V+9wG3bh9YvQPk6vqXBL1QH0zuvdSwLnkbSGP6h+3qAz7h9GoYvNYa94tkqtszwbbHPUY2vNE9z4d2eZMC+VHDNsi+az+K5TXnMZ6N7cB2gN15j0nKtbl/zNRl/ecWN2/IFtEWh+XtrhV0xYbgWyxXmKLz50jW2wFssVOiS1eO0e2WAtki80SW3xxBmwReZ525MVDCoN7SXnsx3UzUZfzUVb3KzNk60hzgqnuRbou9J30/XTk1Umi+qm7F8mLI5TvebSq7rvh+X7svUjXHb2Rf9eRtem9SChzHb9SfLDtmtqLxDh2UrcglIe4/0m4FWm+dNAUdozb8xYSO4xXU9ihdPOwQ+X+PFo3atKKPN+rvP/B+HcdWZUeaUCbhKTVDkjL/LXKelDsebvKpau2qptLXyo6Z+z1IMRwby8Srgc9XsgWe1/JFb6e+bjCV0fvi4ivlwET3zQFTPT2IilMVHkPzu2r9ZW6/XXW1kBCrBHyXiS0IecDYq+BqDVCbw2k6hrh9zg+XDcff0vIo3zYe+/lFslp69hvg/nUu+bHy6lwSvkotmN+pFAW20e973tU9VHei+SNcbHyZZ6PIk+Tra6PvtPx0bpjlHo/Uvmot46N3/d4VyCc5XzirOLs9sKpHGxr9mG1F8nLDXt7AZrCWRUreDhbNVZ4EBBn1Tos0yrbS8K/9WX1n6M51DRy66yTWhso+/by+0j+WHt2lPzXS9oA+3KWnB5eX0Z/z490EEUP2Zfr7iv0+jLjc9nePotn+b3zXzsn/tiiMqv7AZJ/mt8ouGzvzV+WtaqL9t581bWqq/fmq/Opslb1KZhb/XYzudTG1qrUmmisXKrxago7vPXe/PDWRzmXqmhdr0lrVt/VVbIqPdKANglJqx2QlvnrRX536ZMN5WWrvjePedkvXLC1qit8vcLX846vlwETX50CJlZdq/qCk0Ot8i5Q3f56tVYVRbfoa1X/0NBaFfqwty+ybK3qn2A+1U7Hy6lw6jKsVXlj3LTXqky2uj76X46P1h2jrgl5zjvWhXg3kd9dv4jvJrYK3Gjy3UQP64wGYlrM8Tq/XqT6+P6wF5dy7LMMtnx6QdPMgOZiBZo9oPnWgqb5HNo7xrzE6M+BzLcdu4XACitLoQz72rGNBnH0zm38vbRWpdajFI4sFGUKR/gbABcxZnosII6omKlKXKN8EvFE1d8u0eeNTl++Dc8YzeUKNN/k9GXU67A47050PHmS+34MZIuBE0YfcQJ5om3Yj84amyqcMJ7TwAkVU1jZd0EZ44SVoQ+ouPVR0I37SAycMFtWjVuxve06PzK6d8/Bibpxq/qOhIo3blMZxgdGo4rNp/0tBLZ51W8hfF9kmzMtlF+9O8/fWvyhQr5Z/RYC6mz5d+Uv497zVt924rZ6J9kiUownbXG7pi3mA9kiLbHFu8+RLbZq2GLLsQXvO7O6PzNDfWRrjC34Wwjqt+i4bibqchxldY/IFpF+G0Xagn/LPtLvxO5zXBiYft9rS9UGXWoDtguejVaZ7TpEK3R85umG8vPYhn6ENiijtVWTVmR/PWnTdUdv5N91ZFV6pAFtwnuezvrbzYoPth3vedoKyAf1YRyzui8WiuZh1/OEW5H69sz+Vsgk2MHfso+NHUo3Dzsu8rfs0daYpyuTVelx2X8rxGx43r+L/0LAPN+akEdhOO95Uribi/JHzeDrzP5WyBW+XuHrrOHrZcDEl6eAibznaRwm9gR93suj5ukt+h/XPDqCJ+ctXnHWPCK19wjG4LoE8uyU6NhKfEya5rsr2EZVvqGg3tNWOSr8Lsjx84PTsnUqSwejNJtYc/lNWnPBfsTvCqp+FDln4/6ONvI02eaSUZ8c2v9E915zcAb9tMp4qnB40jhC8fHyDtcC8lE4bv97uec2lVndv6NYchrvhfJ+v69CLuHfaL+fyvmoXMx5+o0RxDPep4W4xvv9ulDG38aMlSvm8R77/paQdS4Z7Yfot/ye7784fb8Lz82Le96e9C6VqfjA2yeIvqjs760FcJy4VVEPb4yatd96Qv9mH8Z24L2GaMOmxy+TpWz8Yh/eEXoc24LufSegD28LebwxxxsnGGc3ioRDLmIrGy/necBZHB/YR7HN2EexbXkfG/6WU0NrHJVxln/LqSrOrhTtHeK3nNaFPMpH2X/RR41GLor5pbI/0sP/UyGrtQnqb/WvFTxmYW010u/VTnVtVf0W6GVbW0UblNGquo7Ivzcbe21109Eb+XcdWZtaW2W+GdC3Mv5NFqv7gzAGfnc2XOfkW3lQ53HCjdjvG8f+juq49435O6o7ZHN1Nlpcxu8b78TRzX3fGOX35gsX7X1jtPVFe994ifRBjFilMhwLzSZ5v357Vk6j49BYc2jg3IbxUu09Ov7Na4dGx6GxJmj0hC4cv0aKDdw51rawS9051o858WvdMaXuesAjUKdL8ln9nwD53krvVewI+dSah2o/xt+dEv7Yx9h2zzQzhsnYtywXUva+WJl9f3YC+/LeZs++ZftUlX2t7kOyb6RxTtoXeaFM2P8UprAOz83A/MjLszWVI9oS9vNyRFtCD7Sv3ftFB7/q5ojUHLsrnmuVnI0P32M+3ljU1H5Di9tfhJj8efLVSD5xELk/u3snUCfjH2I+bbyamk97+0Lyw8t/8l7lunsOFK2mciTj9ipzjkTJqvRIA9okJK2lgLTMX9XaCo8H045n10Efxgovnn3BGQ+U76w7tvPWthDDK+83bAZf+1f4eubjCl8dvS8ivl4GTHx5CphYeb8h5VhUDK7mLzy3UXOJWVlb5Harurb4ZwHbrSvkYVpV92pa/b90cgeqT6IMhvGq/Xg/VreEP8ZHGdX9PI21sfqumnczvpzsg0w0pq6W6PBaM/GC1IHHnUjj7f6sjmtnne8jr06i/f4wjG57nm5enkONcWfFFW+8jBXftoif0hv5e3l+pUca0Cb83mqsvbJlaxoh+KixlfNIrWJ8yk9fd9ZeLOef1/tn2iuF687emMG8vwk5rG/A9aOFTN7+F29tR8VgjAv5n8qTq30+ao8X7mHJj3QwrO9hcX93sqP2tzOr7kPkbxChjXm99rzu8fp2wD1e14Q8qj/vUJm3D1bJgP3GfEv1R3sW+2Pk/VT9Wd1PNcmYz/upYo/5Vfc+X4b9VN7+gGnupwpBy3xM4euszXPPiq/XC0wNga8K2xS+cn5CxTgqhvDeVVC5kRb9XzbHLpvjvgFsw3PscXsLvTk2PovPVZljW903F7JFHi/k/JQxTO1fVvko1uFx0mGac+woY8be7q7SLQmomze3iesb+3st4pckenw2/k2tH3h9Mz/43eA42L2/m/M0jEN7KJxkOXgOyRiF9HgPj9V9C8wL78H1W5rBjpndu3/W+Tny6iRRMcuNNb38x0WONdUex1mINfk7Yj8Ffe0d7VM6WCe/XhG8N0W52VjFfXNUx/TC72Mo2vw9hY6or/Yge+2zLeivJOXYll/3hL5eriaPxf6Evi3QAVnSwXCZGod4zEQaeXM90y6n0XForAsaFv9hO3GuFtsixtzB7IrxGfI02eaSUb9DH+V3Su47c4c5eG5e3PPyqZiz4+fq4LXig+3QIj4rAfmgDTnP3yNarRJaqh+g7+RHCmWxc5bee6mIB5yzRNwpWzP8LcDMX6W+g23AcXvsvqPWDxk782OO6uO10vd5p++wr5X5h5o/t5LxtHqC1qy9pz9ku8FwGcby7GvY1+x7Ib1kdKzh/E2kOcmJH6k97MjTZJtLRtt0qN/RvQ87fqRwRrW9yt/0qEzhpsI6zN+8eAn68QuR+7GyP7cN2h9jELa/GvNVfLJCcoyzHa8NWv2P0zyT49nD4v/dCQ+V3ynTIUlG45FWMvq+ksoP8v+ZqFs2F//9c2SLrIYtshq2sLovkS0irddIW3TJFlni24LzuKnQnetmoi5/u8rqvky2yBq0RUa2SMfYYplsgXEwv8eeluibXy+V2OmPz5EtNmrYYs6xBfuF1f1TskXaoC1430ys+dcC8UGauFflMzSuYj+bF8/yeoPV/yuYY3zWiU24vazs89QmjBOHxf+7Ex6qTYzXUqJ9zrMz1sP/k0Tbj/cstAQtbBeTZ9mxofX5vxFrakpm/h0yex5lnndkVniTs36iuI45p7n71Otx57Gsg1M7oN0T4p9R/a8WdsLx1M7pBHI+e/do79n+0bNHd47e+96DB0fsa/mBvhaa/9Hd/lMP9g8e3L1/p3/Uf3Isf4t1Fwan5ThHPa6HZVQH6RmtR6BsqQKtJYfWokOrU5GWxxtlTYn+cvF/u4T+ItXvFv+nUH9ByJMR/W8Abn67PVzHaP4r1Pl3mMsf1x2c8uC2W8EyUR9xjeubrjm7bwE250cP+IRenyiTG33B+Csb1B1DjVeHaAXWbS9km3i0VirSMnti+x7/1jB8mzo/IrX1PutgayOoJ/I3eVbjyHPie72Bb1PjH8L3jFdTvqd083wP67PvKVq9irTMnsrfunFs0GdcT0psgPzxf8R1HP/sWcbszYVhOspeOIbZWGR+tQplHSpbg7Jlknd9MCov0uqRvOskr429yudXBf8V4o+8FH8el9dE/TVRP/eVLtm0LZ7F9jWbLsEzC+IZL57B+nbdIvoYE2P9dDBMC8cwHqutjbHdFoVc1k+WifdhcX93sqNfNe4z/hnJ/1jRRnl7vQHWko/rDsr1H9cvGU9UOx/vxZkBPMG40viHGC+MV1PjRYg28Wgt16Q1q2OEisOWhPwn7/1C2RKVIVYythsuIkaocTWj+k8RtnfhGXt+VfBnPauO+XXHgrzf7gFu3KuA88q+MebUB3eO7j44uru3d+9g7+HB3p2m5/QP7jx5/8H/C7H7cC//d7/qnB4xqArWemMgjkPLFWgtO7Q6Dq2lirQ83igr4mN+mD+3S+h3qL71J+xvjwh5OPZ7B/jyexaG6xjNH4U6P07j5JC/k0yqD7aFTCruxpzGMzROTmNehb7A8yrUadJ5VTuObnsh2yTEvMrsie2bXz/XTFvvsw44p8d+ZvxNnrU48vS9cQjtZvxD+J7xasr3lG6e73nxRdXxWtEyeyp/W4ljgz7jelJiA56jKlzH8c+eZcx+P8Ulyl44hqXFtZq3c9y3DmUcd20MRuVFWqsk7wbJa2Ov8vlVwR9zfszLm6O3BK15cQ/jvl+qkCdRNvXm812nvmozpMExA2NTfiw69NdFfc9WG0IelBHp5cemqN9z6tv/uEaGNMryQb9BvrMFz9jzq0KHrRJ5WyX8y+yB9TdE/dx3PljIOK38jvnKZcrvfATiio/WiFvHYTSPLVh/Fub/KCvOIz4xA2MdzkmMf4hYxng1FcuE8BGPVrcmrVnzt6r5prS4nla+6aVzkG/6PcCxT1AMonzHi0HG+RrHFKr9lh36vAabHws16/cceVR8p9rMi1WtDMdqjrtt3Ed/QlomR0b1XyF/UvGRikVwnsu8vLjUi83KYpFPQSxicmLOmMdD699oC5Vbz6j+n4PffobG31Twy+t9icYojmsOi/u7kx37VWMw4+/FYJFl7XuyLghZlY3rjqccXw7Fi3YejNY33kN7nqjMwyfDFvQ1pGVy8N6kL1K/wzjDnl8V/HksVnu18F6VvVpqb1fu268WMlqMkgLvkDEK9qO8j/8fnVmKdhlJAQA=",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "50": {
      "source": "use std::slice;\n\nfn main(x: Field, y: pub Field) {\n    let mut slice = &[0; 2];\n    assert(slice[0] == 0);\n    assert(slice[0] != 1);\n    slice[0] = x;\n    assert(slice[0] == x);\n\n    let slice_plus_10 = slice.push_back(y);\n    assert(slice_plus_10[2] == 10);\n    assert(slice_plus_10[2] != 8);\n    assert(slice_plus_10.len() == 3);\n\n    let mut new_slice = &[];\n    for i in 0..5 {\n        new_slice = new_slice.push_back(i);\n    }\n    assert(new_slice.len() == 5);\n\n    new_slice = new_slice.push_front(20);\n    assert(new_slice[0] == 20);\n    assert(new_slice.len() == 6);\n\n    let (popped_slice, last_elem) = new_slice.pop_back();\n    assert(last_elem == 4);\n    assert(popped_slice.len() == 5);\n\n    let (first_elem, rest_of_slice) = popped_slice.pop_front();\n    assert(first_elem == 20);\n    assert(rest_of_slice.len() == 4);\n\n    new_slice = rest_of_slice.insert(2, 100);\n    assert(new_slice[2] == 100);\n    assert(new_slice[4] == 3);\n    assert(new_slice.len() == 5);\n\n    let (remove_slice, removed_elem) = new_slice.remove(3);\n    assert(removed_elem == 2);\n    assert(remove_slice[3] == 3);\n    assert(remove_slice.len() == 4);\n\n    let append = &[1, 2].append(&[3, 4, 5]);\n    assert(append.len() == 5);\n    assert(append[0] == 1);\n    assert(append[4] == 5);\n\n    let mapped = &[1, 2].map(|x| x + 1);\n    assert_eq(mapped, &[2, 3]);\n\n    assert_eq(&[1, 2, 3].fold(0, |acc, x| acc + x), 6);\n    assert_eq(&[1, 2, 3].reduce(|acc, x| acc + x), 6);\n    assert(&[2, 4, 6].all(|x| x > 0));\n    assert(&[2, 4, 6].any(|x| x > 5));\n\n    regression_2083();\n    // The parameters to this function must come from witness values (inputs to main)\n    regression_merge_slices(x, y);\n    regression_2370();\n\n    regression_4418(x);\n    regression_slice_call_result(x, y);\n    regression_4506();\n}\n\n// Ensure that slices of struct/tuple values work.\nfn regression_2083() {\n    let y = &[(1, 2)];\n    let y = y.push_back((3, 4)); // [(1, 2), (3, 4)]\n    let y = y.push_back((5, 6)); // [(1, 2), (3, 4), (5, 6)]\n    assert(y[2].1 == 6);\n\n    let y = y.push_front((10, 11)); // [(10, 11), (1, 2), (3, 4), (5, 6)]\n    let y = y.push_front((12, 13)); // [(12, 13), (10, 11), (1, 2), (3, 4), (5, 6)]\n    assert(y[1].0 == 10);\n\n    let y = y.insert(1, (55, 56)); // [(12, 13), (55, 56), (10, 11), (1, 2), (3, 4), (5, 6)]\n    assert(y[0].1 == 13);\n    assert(y[1].1 == 56);\n    assert(y[2].0 == 10);\n\n    let (y, x) = y.remove(2); // [(12, 13), (55, 56), (1, 2), (3, 4), (5, 6)]\n    assert(y[2].0 == 1);\n    assert(x.0 == 10);\n    assert(x.1 == 11);\n\n    let (x, y) = y.pop_front(); // [(55, 56), (1, 2), (3, 4), (5, 6)]\n    assert(y[0].0 == 55);\n    assert(x.0 == 12);\n    assert(x.1 == 13);\n\n    let (y, x) = y.pop_back(); // [(55, 56), (1, 2), (3, 4)]\n    assert(y.len() == 3);\n    assert(x.0 == 5);\n    assert(x.1 == 6);\n}\n\n// The parameters to this function must come from witness values (inputs to main)\nfn regression_merge_slices(x: Field, y: Field) {\n    merge_slices_if(x, y);\n    merge_slices_else(x);\n}\n\nfn merge_slices_if(x: Field, y: Field) {\n    let slice = merge_slices_return(x, y);\n    assert(slice.len() == 3);\n    assert(slice[2] == 10);\n\n    let slice = merge_slices_mutate(x, y);\n    assert(slice.len() == 4);\n    assert(slice[3] == 5);\n\n    let slice = merge_slices_mutate_in_loop(x, y);\n    assert(slice.len() == 7);\n    assert(slice[6] == 4);\n\n    let slice = merge_slices_mutate_two_ifs(x, y);\n    assert(slice.len() == 6);\n    assert(slice[3] == 5);\n    assert(slice[4] == 15);\n    assert(slice[5] == 30);\n\n    let slice = merge_slices_mutate_between_ifs(x, y);\n    assert(slice.len() == 8);\n    assert(slice[3] == 5);\n    assert(slice[4] == 30);\n    assert(slice[5] == 15);\n    assert(slice[6] == 50);\n    assert(slice[7] == 60);\n\n    merge_slices_push_then_pop(x, y);\n\n    let slice = merge_slices_push_then_insert(x, y);\n    assert(slice.len() == 7);\n    assert(slice[1] == 50);\n    assert(slice[2] == 0);\n    assert(slice[5] == 30);\n    assert(slice[6] == 100);\n\n    let slice = merge_slices_remove_between_ifs(x, y);\n    assert(slice.len() == 5);\n}\n\nfn merge_slices_else(x: Field) {\n    let slice = merge_slices_return(x, 5);\n    assert(slice[0] == 0);\n    assert(slice[1] == 0);\n    assert(slice.len() == 2);\n\n    let slice = merge_slices_mutate(x, 5);\n    assert(slice[2] == 5);\n    assert(slice.len() == 3);\n\n    let slice = merge_slices_mutate_in_loop(x, 5);\n    assert(slice[2] == 5);\n    assert(slice.len() == 3);\n}\n\n// Test returning a merged slice without a mutation\nfn merge_slices_return(x: Field, y: Field) -> [Field] {\n    let slice = &[0; 2];\n    if x != y {\n        if x != 20 {\n            slice.push_back(y)\n        } else {\n            slice\n        }\n    } else {\n        slice\n    }\n}\n\n// Test mutating a slice inside of an if statement\nfn merge_slices_mutate(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n    slice\n}\n\n// Test mutating a slice inside of a loop in an if statement\nfn merge_slices_mutate_in_loop(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        for i in 0..5 {\n            slice = slice.push_back(i as Field);\n        }\n    } else {\n        slice = slice.push_back(x);\n    }\n    slice\n}\n\nfn merge_slices_mutate_two_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n    slice = slice.push_back(30);\n\n    slice\n}\n\nfn merge_slices_mutate_between_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n\n    slice\n}\n\nfn merge_slices_push_then_pop(x: Field, y: Field) {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(slice.len() == 4);\n    assert(elem == 30);\n\n    let (slice, elem) = slice.pop_back();\n    assert(slice.len() == 3);\n    assert(elem == x);\n}\n\nfn merge_slices_push_then_insert(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n        slice = slice.push_back(15);\n    }\n\n    slice = slice.insert(1, 50);\n    // Test that we can use slice insert the same as slice push back\n    slice = slice.insert(6, 100);\n\n    slice\n}\n\nfn merge_slices_remove_between_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    let (mut slice, elem) = slice.remove(2);\n    assert(elem == y);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice\n}\n// Previously, we'd get a type error when trying to assign an array of a different size to\n// an existing array variable. Now, we infer the variable must be a slice.\nfn regression_2370() {\n    let mut slice = &[];\n    slice = &[1, 2, 3];\n}\n\nfn regression_4418(x: Field) {\n    let mut crash: [u8; 32] = x.to_be_bytes();\n\n    if x != 0 {\n        crash[0] = 10;\n    }\n}\n\nfn regression_slice_call_result(x: Field, y: Field) {\n    let mut slice = merge_slices_return(x, y);\n    if x != 0 {\n        slice = slice.push_back(5);\n        slice = slice.push_back(10);\n    } else {\n        slice = slice.push_back(5);\n    }\n    assert(slice.len() == 5);\n    assert(slice[0] == 0);\n    assert(slice[1] == 0);\n    assert(slice[2] == 10);\n    assert(slice[3] == 5);\n    assert(slice[4] == 10);\n}\n\nfn regression_4506() {\n    let slice: [Field] = &[1, 2, 3];\n    assert(slice == slice);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
