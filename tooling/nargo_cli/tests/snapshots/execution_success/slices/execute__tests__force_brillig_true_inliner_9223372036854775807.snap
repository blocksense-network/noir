---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "50": {
      "source": "use std::slice;\n\nfn main(x: Field, y: pub Field) {\n    let mut slice = &[0; 2];\n    assert(slice[0] == 0);\n    assert(slice[0] != 1);\n    slice[0] = x;\n    assert(slice[0] == x);\n\n    let slice_plus_10 = slice.push_back(y);\n    assert(slice_plus_10[2] == 10);\n    assert(slice_plus_10[2] != 8);\n    assert(slice_plus_10.len() == 3);\n\n    let mut new_slice = &[];\n    for i in 0..5 {\n        new_slice = new_slice.push_back(i);\n    }\n    assert(new_slice.len() == 5);\n\n    new_slice = new_slice.push_front(20);\n    assert(new_slice[0] == 20);\n    assert(new_slice.len() == 6);\n\n    let (popped_slice, last_elem) = new_slice.pop_back();\n    assert(last_elem == 4);\n    assert(popped_slice.len() == 5);\n\n    let (first_elem, rest_of_slice) = popped_slice.pop_front();\n    assert(first_elem == 20);\n    assert(rest_of_slice.len() == 4);\n\n    new_slice = rest_of_slice.insert(2, 100);\n    assert(new_slice[2] == 100);\n    assert(new_slice[4] == 3);\n    assert(new_slice.len() == 5);\n\n    let (remove_slice, removed_elem) = new_slice.remove(3);\n    assert(removed_elem == 2);\n    assert(remove_slice[3] == 3);\n    assert(remove_slice.len() == 4);\n\n    let append = &[1, 2].append(&[3, 4, 5]);\n    assert(append.len() == 5);\n    assert(append[0] == 1);\n    assert(append[4] == 5);\n\n    let mapped = &[1, 2].map(|x| x + 1);\n    assert_eq(mapped, &[2, 3]);\n\n    assert_eq(&[1, 2, 3].fold(0, |acc, x| acc + x), 6);\n    assert_eq(&[1, 2, 3].reduce(|acc, x| acc + x), 6);\n    assert(&[2, 4, 6].all(|x| x > 0));\n    assert(&[2, 4, 6].any(|x| x > 5));\n\n    regression_2083();\n    // The parameters to this function must come from witness values (inputs to main)\n    regression_merge_slices(x, y);\n    regression_2370();\n\n    regression_4418(x);\n    regression_slice_call_result(x, y);\n    regression_4506();\n}\n\n// Ensure that slices of struct/tuple values work.\nfn regression_2083() {\n    let y = &[(1, 2)];\n    let y = y.push_back((3, 4)); // [(1, 2), (3, 4)]\n    let y = y.push_back((5, 6)); // [(1, 2), (3, 4), (5, 6)]\n    assert(y[2].1 == 6);\n\n    let y = y.push_front((10, 11)); // [(10, 11), (1, 2), (3, 4), (5, 6)]\n    let y = y.push_front((12, 13)); // [(12, 13), (10, 11), (1, 2), (3, 4), (5, 6)]\n    assert(y[1].0 == 10);\n\n    let y = y.insert(1, (55, 56)); // [(12, 13), (55, 56), (10, 11), (1, 2), (3, 4), (5, 6)]\n    assert(y[0].1 == 13);\n    assert(y[1].1 == 56);\n    assert(y[2].0 == 10);\n\n    let (y, x) = y.remove(2); // [(12, 13), (55, 56), (1, 2), (3, 4), (5, 6)]\n    assert(y[2].0 == 1);\n    assert(x.0 == 10);\n    assert(x.1 == 11);\n\n    let (x, y) = y.pop_front(); // [(55, 56), (1, 2), (3, 4), (5, 6)]\n    assert(y[0].0 == 55);\n    assert(x.0 == 12);\n    assert(x.1 == 13);\n\n    let (y, x) = y.pop_back(); // [(55, 56), (1, 2), (3, 4)]\n    assert(y.len() == 3);\n    assert(x.0 == 5);\n    assert(x.1 == 6);\n}\n\n// The parameters to this function must come from witness values (inputs to main)\nfn regression_merge_slices(x: Field, y: Field) {\n    merge_slices_if(x, y);\n    merge_slices_else(x);\n}\n\nfn merge_slices_if(x: Field, y: Field) {\n    let slice = merge_slices_return(x, y);\n    assert(slice.len() == 3);\n    assert(slice[2] == 10);\n\n    let slice = merge_slices_mutate(x, y);\n    assert(slice.len() == 4);\n    assert(slice[3] == 5);\n\n    let slice = merge_slices_mutate_in_loop(x, y);\n    assert(slice.len() == 7);\n    assert(slice[6] == 4);\n\n    let slice = merge_slices_mutate_two_ifs(x, y);\n    assert(slice.len() == 6);\n    assert(slice[3] == 5);\n    assert(slice[4] == 15);\n    assert(slice[5] == 30);\n\n    let slice = merge_slices_mutate_between_ifs(x, y);\n    assert(slice.len() == 8);\n    assert(slice[3] == 5);\n    assert(slice[4] == 30);\n    assert(slice[5] == 15);\n    assert(slice[6] == 50);\n    assert(slice[7] == 60);\n\n    merge_slices_push_then_pop(x, y);\n\n    let slice = merge_slices_push_then_insert(x, y);\n    assert(slice.len() == 7);\n    assert(slice[1] == 50);\n    assert(slice[2] == 0);\n    assert(slice[5] == 30);\n    assert(slice[6] == 100);\n\n    let slice = merge_slices_remove_between_ifs(x, y);\n    assert(slice.len() == 5);\n}\n\nfn merge_slices_else(x: Field) {\n    let slice = merge_slices_return(x, 5);\n    assert(slice[0] == 0);\n    assert(slice[1] == 0);\n    assert(slice.len() == 2);\n\n    let slice = merge_slices_mutate(x, 5);\n    assert(slice[2] == 5);\n    assert(slice.len() == 3);\n\n    let slice = merge_slices_mutate_in_loop(x, 5);\n    assert(slice[2] == 5);\n    assert(slice.len() == 3);\n}\n\n// Test returning a merged slice without a mutation\nfn merge_slices_return(x: Field, y: Field) -> [Field] {\n    let slice = &[0; 2];\n    if x != y {\n        if x != 20 {\n            slice.push_back(y)\n        } else {\n            slice\n        }\n    } else {\n        slice\n    }\n}\n\n// Test mutating a slice inside of an if statement\nfn merge_slices_mutate(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n    slice\n}\n\n// Test mutating a slice inside of a loop in an if statement\nfn merge_slices_mutate_in_loop(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        for i in 0..5 {\n            slice = slice.push_back(i as Field);\n        }\n    } else {\n        slice = slice.push_back(x);\n    }\n    slice\n}\n\nfn merge_slices_mutate_two_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n    slice = slice.push_back(30);\n\n    slice\n}\n\nfn merge_slices_mutate_between_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n\n    slice\n}\n\nfn merge_slices_push_then_pop(x: Field, y: Field) {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(slice.len() == 4);\n    assert(elem == 30);\n\n    let (slice, elem) = slice.pop_back();\n    assert(slice.len() == 3);\n    assert(elem == x);\n}\n\nfn merge_slices_push_then_insert(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n        slice = slice.push_back(15);\n    }\n\n    slice = slice.insert(1, 50);\n    // Test that we can use slice insert the same as slice push back\n    slice = slice.insert(6, 100);\n\n    slice\n}\n\nfn merge_slices_remove_between_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    let (mut slice, elem) = slice.remove(2);\n    assert(elem == y);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice\n}\n// Previously, we'd get a type error when trying to assign an array of a different size to\n// an existing array variable. Now, we infer the variable must be a slice.\nfn regression_2370() {\n    let mut slice = &[];\n    slice = &[1, 2, 3];\n}\n\nfn regression_4418(x: Field) {\n    let mut crash: [u8; 32] = x.to_be_bytes();\n\n    if x != 0 {\n        crash[0] = 10;\n    }\n}\n\nfn regression_slice_call_result(x: Field, y: Field) {\n    let mut slice = merge_slices_return(x, y);\n    if x != 0 {\n        slice = slice.push_back(5);\n        slice = slice.push_back(10);\n    } else {\n        slice = slice.push_back(5);\n    }\n    assert(slice.len() == 5);\n    assert(slice[0] == 0);\n    assert(slice[1] == 0);\n    assert(slice[2] == 10);\n    assert(slice[3] == 5);\n    assert(slice[4] == 10);\n}\n\nfn regression_4506() {\n    let slice: [Field] = &[1, 2, 3];\n    assert(slice == slice);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
