---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "46": {
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n",
      "path": "std/slice.nr"
    },
    "50": {
      "source": "use std::slice;\n\nfn main(x: Field, y: pub Field) {\n    let mut slice = &[0; 2];\n    assert(slice[0] == 0);\n    assert(slice[0] != 1);\n    slice[0] = x;\n    assert(slice[0] == x);\n\n    let slice_plus_10 = slice.push_back(y);\n    assert(slice_plus_10[2] == 10);\n    assert(slice_plus_10[2] != 8);\n    assert(slice_plus_10.len() == 3);\n\n    let mut new_slice = &[];\n    for i in 0..5 {\n        new_slice = new_slice.push_back(i);\n    }\n    assert(new_slice.len() == 5);\n\n    new_slice = new_slice.push_front(20);\n    assert(new_slice[0] == 20);\n    assert(new_slice.len() == 6);\n\n    let (popped_slice, last_elem) = new_slice.pop_back();\n    assert(last_elem == 4);\n    assert(popped_slice.len() == 5);\n\n    let (first_elem, rest_of_slice) = popped_slice.pop_front();\n    assert(first_elem == 20);\n    assert(rest_of_slice.len() == 4);\n\n    new_slice = rest_of_slice.insert(2, 100);\n    assert(new_slice[2] == 100);\n    assert(new_slice[4] == 3);\n    assert(new_slice.len() == 5);\n\n    let (remove_slice, removed_elem) = new_slice.remove(3);\n    assert(removed_elem == 2);\n    assert(remove_slice[3] == 3);\n    assert(remove_slice.len() == 4);\n\n    let append = &[1, 2].append(&[3, 4, 5]);\n    assert(append.len() == 5);\n    assert(append[0] == 1);\n    assert(append[4] == 5);\n\n    let mapped = &[1, 2].map(|x| x + 1);\n    assert_eq(mapped, &[2, 3]);\n\n    assert_eq(&[1, 2, 3].fold(0, |acc, x| acc + x), 6);\n    assert_eq(&[1, 2, 3].reduce(|acc, x| acc + x), 6);\n    assert(&[2, 4, 6].all(|x| x > 0));\n    assert(&[2, 4, 6].any(|x| x > 5));\n\n    regression_2083();\n    // The parameters to this function must come from witness values (inputs to main)\n    regression_merge_slices(x, y);\n    regression_2370();\n\n    regression_4418(x);\n    regression_slice_call_result(x, y);\n    regression_4506();\n}\n\n// Ensure that slices of struct/tuple values work.\nfn regression_2083() {\n    let y = &[(1, 2)];\n    let y = y.push_back((3, 4)); // [(1, 2), (3, 4)]\n    let y = y.push_back((5, 6)); // [(1, 2), (3, 4), (5, 6)]\n    assert(y[2].1 == 6);\n\n    let y = y.push_front((10, 11)); // [(10, 11), (1, 2), (3, 4), (5, 6)]\n    let y = y.push_front((12, 13)); // [(12, 13), (10, 11), (1, 2), (3, 4), (5, 6)]\n    assert(y[1].0 == 10);\n\n    let y = y.insert(1, (55, 56)); // [(12, 13), (55, 56), (10, 11), (1, 2), (3, 4), (5, 6)]\n    assert(y[0].1 == 13);\n    assert(y[1].1 == 56);\n    assert(y[2].0 == 10);\n\n    let (y, x) = y.remove(2); // [(12, 13), (55, 56), (1, 2), (3, 4), (5, 6)]\n    assert(y[2].0 == 1);\n    assert(x.0 == 10);\n    assert(x.1 == 11);\n\n    let (x, y) = y.pop_front(); // [(55, 56), (1, 2), (3, 4), (5, 6)]\n    assert(y[0].0 == 55);\n    assert(x.0 == 12);\n    assert(x.1 == 13);\n\n    let (y, x) = y.pop_back(); // [(55, 56), (1, 2), (3, 4)]\n    assert(y.len() == 3);\n    assert(x.0 == 5);\n    assert(x.1 == 6);\n}\n\n// The parameters to this function must come from witness values (inputs to main)\nfn regression_merge_slices(x: Field, y: Field) {\n    merge_slices_if(x, y);\n    merge_slices_else(x);\n}\n\nfn merge_slices_if(x: Field, y: Field) {\n    let slice = merge_slices_return(x, y);\n    assert(slice.len() == 3);\n    assert(slice[2] == 10);\n\n    let slice = merge_slices_mutate(x, y);\n    assert(slice.len() == 4);\n    assert(slice[3] == 5);\n\n    let slice = merge_slices_mutate_in_loop(x, y);\n    assert(slice.len() == 7);\n    assert(slice[6] == 4);\n\n    let slice = merge_slices_mutate_two_ifs(x, y);\n    assert(slice.len() == 6);\n    assert(slice[3] == 5);\n    assert(slice[4] == 15);\n    assert(slice[5] == 30);\n\n    let slice = merge_slices_mutate_between_ifs(x, y);\n    assert(slice.len() == 8);\n    assert(slice[3] == 5);\n    assert(slice[4] == 30);\n    assert(slice[5] == 15);\n    assert(slice[6] == 50);\n    assert(slice[7] == 60);\n\n    merge_slices_push_then_pop(x, y);\n\n    let slice = merge_slices_push_then_insert(x, y);\n    assert(slice.len() == 7);\n    assert(slice[1] == 50);\n    assert(slice[2] == 0);\n    assert(slice[5] == 30);\n    assert(slice[6] == 100);\n\n    let slice = merge_slices_remove_between_ifs(x, y);\n    assert(slice.len() == 5);\n}\n\nfn merge_slices_else(x: Field) {\n    let slice = merge_slices_return(x, 5);\n    assert(slice[0] == 0);\n    assert(slice[1] == 0);\n    assert(slice.len() == 2);\n\n    let slice = merge_slices_mutate(x, 5);\n    assert(slice[2] == 5);\n    assert(slice.len() == 3);\n\n    let slice = merge_slices_mutate_in_loop(x, 5);\n    assert(slice[2] == 5);\n    assert(slice.len() == 3);\n}\n\n// Test returning a merged slice without a mutation\nfn merge_slices_return(x: Field, y: Field) -> [Field] {\n    let slice = &[0; 2];\n    if x != y {\n        if x != 20 {\n            slice.push_back(y)\n        } else {\n            slice\n        }\n    } else {\n        slice\n    }\n}\n\n// Test mutating a slice inside of an if statement\nfn merge_slices_mutate(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n    slice\n}\n\n// Test mutating a slice inside of a loop in an if statement\nfn merge_slices_mutate_in_loop(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        for i in 0..5 {\n            slice = slice.push_back(i as Field);\n        }\n    } else {\n        slice = slice.push_back(x);\n    }\n    slice\n}\n\nfn merge_slices_mutate_two_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n    slice = slice.push_back(30);\n\n    slice\n}\n\nfn merge_slices_mutate_between_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n\n    slice\n}\n\nfn merge_slices_push_then_pop(x: Field, y: Field) {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(slice.len() == 4);\n    assert(elem == 30);\n\n    let (slice, elem) = slice.pop_back();\n    assert(slice.len() == 3);\n    assert(elem == x);\n}\n\nfn merge_slices_push_then_insert(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n        slice = slice.push_back(15);\n    }\n\n    slice = slice.insert(1, 50);\n    // Test that we can use slice insert the same as slice push back\n    slice = slice.insert(6, 100);\n\n    slice\n}\n\nfn merge_slices_remove_between_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    let (mut slice, elem) = slice.remove(2);\n    assert(elem == y);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice\n}\n// Previously, we'd get a type error when trying to assign an array of a different size to\n// an existing array variable. Now, we infer the variable must be a slice.\nfn regression_2370() {\n    let mut slice = &[];\n    slice = &[1, 2, 3];\n}\n\nfn regression_4418(x: Field) {\n    let mut crash: [u8; 32] = x.to_be_bytes();\n\n    if x != 0 {\n        crash[0] = 10;\n    }\n}\n\nfn regression_slice_call_result(x: Field, y: Field) {\n    let mut slice = merge_slices_return(x, y);\n    if x != 0 {\n        slice = slice.push_back(5);\n        slice = slice.push_back(10);\n    } else {\n        slice = slice.push_back(5);\n    }\n    assert(slice.len() == 5);\n    assert(slice[0] == 0);\n    assert(slice[1] == 0);\n    assert(slice[2] == 10);\n    assert(slice[3] == 5);\n    assert(slice[4] == 10);\n}\n\nfn regression_4506() {\n    let slice: [Field] = &[1, 2, 3];\n    assert(slice == slice);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
