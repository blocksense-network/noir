---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "46": {
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n",
      "path": "std/slice.nr"
    },
    "50": {
      "source": "use std::slice;\n\nfn main(x: Field, y: pub Field) {\n    let mut slice = &[0; 2];\n    assert(slice[0] == 0);\n    assert(slice[0] != 1);\n    slice[0] = x;\n    assert(slice[0] == x);\n\n    let slice_plus_10 = slice.push_back(y);\n    assert(slice_plus_10[2] == 10);\n    assert(slice_plus_10[2] != 8);\n    assert(slice_plus_10.len() == 3);\n\n    let mut new_slice = &[];\n    for i in 0..5 {\n        new_slice = new_slice.push_back(i);\n    }\n    assert(new_slice.len() == 5);\n\n    new_slice = new_slice.push_front(20);\n    assert(new_slice[0] == 20);\n    assert(new_slice.len() == 6);\n\n    let (popped_slice, last_elem) = new_slice.pop_back();\n    assert(last_elem == 4);\n    assert(popped_slice.len() == 5);\n\n    let (first_elem, rest_of_slice) = popped_slice.pop_front();\n    assert(first_elem == 20);\n    assert(rest_of_slice.len() == 4);\n\n    new_slice = rest_of_slice.insert(2, 100);\n    assert(new_slice[2] == 100);\n    assert(new_slice[4] == 3);\n    assert(new_slice.len() == 5);\n\n    let (remove_slice, removed_elem) = new_slice.remove(3);\n    assert(removed_elem == 2);\n    assert(remove_slice[3] == 3);\n    assert(remove_slice.len() == 4);\n\n    let append = &[1, 2].append(&[3, 4, 5]);\n    assert(append.len() == 5);\n    assert(append[0] == 1);\n    assert(append[4] == 5);\n\n    let mapped = &[1, 2].map(|x| x + 1);\n    assert_eq(mapped, &[2, 3]);\n\n    assert_eq(&[1, 2, 3].fold(0, |acc, x| acc + x), 6);\n    assert_eq(&[1, 2, 3].reduce(|acc, x| acc + x), 6);\n    assert(&[2, 4, 6].all(|x| x > 0));\n    assert(&[2, 4, 6].any(|x| x > 5));\n\n    regression_2083();\n    // The parameters to this function must come from witness values (inputs to main)\n    regression_merge_slices(x, y);\n    regression_2370();\n\n    regression_4418(x);\n    regression_slice_call_result(x, y);\n    regression_4506();\n}\n\n// Ensure that slices of struct/tuple values work.\nfn regression_2083() {\n    let y = &[(1, 2)];\n    let y = y.push_back((3, 4)); // [(1, 2), (3, 4)]\n    let y = y.push_back((5, 6)); // [(1, 2), (3, 4), (5, 6)]\n    assert(y[2].1 == 6);\n\n    let y = y.push_front((10, 11)); // [(10, 11), (1, 2), (3, 4), (5, 6)]\n    let y = y.push_front((12, 13)); // [(12, 13), (10, 11), (1, 2), (3, 4), (5, 6)]\n    assert(y[1].0 == 10);\n\n    let y = y.insert(1, (55, 56)); // [(12, 13), (55, 56), (10, 11), (1, 2), (3, 4), (5, 6)]\n    assert(y[0].1 == 13);\n    assert(y[1].1 == 56);\n    assert(y[2].0 == 10);\n\n    let (y, x) = y.remove(2); // [(12, 13), (55, 56), (1, 2), (3, 4), (5, 6)]\n    assert(y[2].0 == 1);\n    assert(x.0 == 10);\n    assert(x.1 == 11);\n\n    let (x, y) = y.pop_front(); // [(55, 56), (1, 2), (3, 4), (5, 6)]\n    assert(y[0].0 == 55);\n    assert(x.0 == 12);\n    assert(x.1 == 13);\n\n    let (y, x) = y.pop_back(); // [(55, 56), (1, 2), (3, 4)]\n    assert(y.len() == 3);\n    assert(x.0 == 5);\n    assert(x.1 == 6);\n}\n\n// The parameters to this function must come from witness values (inputs to main)\nfn regression_merge_slices(x: Field, y: Field) {\n    merge_slices_if(x, y);\n    merge_slices_else(x);\n}\n\nfn merge_slices_if(x: Field, y: Field) {\n    let slice = merge_slices_return(x, y);\n    assert(slice.len() == 3);\n    assert(slice[2] == 10);\n\n    let slice = merge_slices_mutate(x, y);\n    assert(slice.len() == 4);\n    assert(slice[3] == 5);\n\n    let slice = merge_slices_mutate_in_loop(x, y);\n    assert(slice.len() == 7);\n    assert(slice[6] == 4);\n\n    let slice = merge_slices_mutate_two_ifs(x, y);\n    assert(slice.len() == 6);\n    assert(slice[3] == 5);\n    assert(slice[4] == 15);\n    assert(slice[5] == 30);\n\n    let slice = merge_slices_mutate_between_ifs(x, y);\n    assert(slice.len() == 8);\n    assert(slice[3] == 5);\n    assert(slice[4] == 30);\n    assert(slice[5] == 15);\n    assert(slice[6] == 50);\n    assert(slice[7] == 60);\n\n    merge_slices_push_then_pop(x, y);\n\n    let slice = merge_slices_push_then_insert(x, y);\n    assert(slice.len() == 7);\n    assert(slice[1] == 50);\n    assert(slice[2] == 0);\n    assert(slice[5] == 30);\n    assert(slice[6] == 100);\n\n    let slice = merge_slices_remove_between_ifs(x, y);\n    assert(slice.len() == 5);\n}\n\nfn merge_slices_else(x: Field) {\n    let slice = merge_slices_return(x, 5);\n    assert(slice[0] == 0);\n    assert(slice[1] == 0);\n    assert(slice.len() == 2);\n\n    let slice = merge_slices_mutate(x, 5);\n    assert(slice[2] == 5);\n    assert(slice.len() == 3);\n\n    let slice = merge_slices_mutate_in_loop(x, 5);\n    assert(slice[2] == 5);\n    assert(slice.len() == 3);\n}\n\n// Test returning a merged slice without a mutation\nfn merge_slices_return(x: Field, y: Field) -> [Field] {\n    let slice = &[0; 2];\n    if x != y {\n        if x != 20 {\n            slice.push_back(y)\n        } else {\n            slice\n        }\n    } else {\n        slice\n    }\n}\n\n// Test mutating a slice inside of an if statement\nfn merge_slices_mutate(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n    slice\n}\n\n// Test mutating a slice inside of a loop in an if statement\nfn merge_slices_mutate_in_loop(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        for i in 0..5 {\n            slice = slice.push_back(i as Field);\n        }\n    } else {\n        slice = slice.push_back(x);\n    }\n    slice\n}\n\nfn merge_slices_mutate_two_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n    slice = slice.push_back(30);\n\n    slice\n}\n\nfn merge_slices_mutate_between_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n\n    slice\n}\n\nfn merge_slices_push_then_pop(x: Field, y: Field) {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(slice.len() == 4);\n    assert(elem == 30);\n\n    let (slice, elem) = slice.pop_back();\n    assert(slice.len() == 3);\n    assert(elem == x);\n}\n\nfn merge_slices_push_then_insert(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n        slice = slice.push_back(15);\n    }\n\n    slice = slice.insert(1, 50);\n    // Test that we can use slice insert the same as slice push back\n    slice = slice.insert(6, 100);\n\n    slice\n}\n\nfn merge_slices_remove_between_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    let (mut slice, elem) = slice.remove(2);\n    assert(elem == y);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice\n}\n// Previously, we'd get a type error when trying to assign an array of a different size to\n// an existing array variable. Now, we infer the variable must be a slice.\nfn regression_2370() {\n    let mut slice = &[];\n    slice = &[1, 2, 3];\n}\n\nfn regression_4418(x: Field) {\n    let mut crash: [u8; 32] = x.to_be_bytes();\n\n    if x != 0 {\n        crash[0] = 10;\n    }\n}\n\nfn regression_slice_call_result(x: Field, y: Field) {\n    let mut slice = merge_slices_return(x, y);\n    if x != 0 {\n        slice = slice.push_back(5);\n        slice = slice.push_back(10);\n    } else {\n        slice = slice.push_back(5);\n    }\n    assert(slice.len() == 5);\n    assert(slice[0] == 0);\n    assert(slice[1] == 0);\n    assert(slice[2] == 10);\n    assert(slice[3] == 5);\n    assert(slice[4] == 10);\n}\n\nfn regression_4506() {\n    let slice: [Field] = &[1, 2, 3];\n    assert(slice == slice);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
