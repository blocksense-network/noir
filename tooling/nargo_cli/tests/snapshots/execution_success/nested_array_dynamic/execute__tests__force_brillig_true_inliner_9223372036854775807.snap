---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "struct",
            "path": "Foo",
            "fields": [
              {
                "name": "a",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "b",
                "type": {
                  "kind": "array",
                  "length": 3,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "bar",
                "type": {
                  "kind": "struct",
                  "path": "Bar",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "array",
                        "length": 3,
                        "type": {
                          "kind": "field"
                        }
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "struct Bar {\n    inner: [Field; 3],\n}\n\nstruct Foo {\n    a: Field,\n    b: [Field; 3],\n    bar: Bar,\n}\n\nstruct FooParent {\n    array: [Field; 3],\n    foos: [Foo; 4],\n}\n\nfn main(mut x: [Foo; 4], y: pub Field) {\n    assert(x[y - 3].a == 1);\n    assert(x[y - 3].b == [2, 3, 20]);\n    assert(x[y - 2].a == 4);\n    assert(x[y - 2].b == [5, 6, 21]);\n    assert(x[y - 1].a == 7);\n    assert(x[y - 1].b == [8, 9, 22]);\n    assert(x[y].a == 10);\n    assert(x[y].b == [11, 12, 23]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n    // Check dynamic array set\n    if y != 2 {\n        x[y].a = 50;\n    } else {\n        x[y].a = 100;\n    }\n    assert(x[3].a == 50);\n\n    if y == 2 {\n        x[y - 1].b = [50, 51, 52];\n    } else {\n        x[y - 1].b = [100, 101, 102];\n    }\n    assert(x[2].b == [100, 101, 102]);\n\n    assert(x[y - 3].bar.inner == [100, 101, 102]);\n    assert(x[y - 2].bar.inner == [103, 104, 105]);\n    assert(x[y - 1].bar.inner == [106, 107, 108]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n\n    let foo_parent_one = FooParent { array: [0, 1, 2], foos: x };\n    let foo_parent_two = FooParent { array: [3, 4, 5], foos: x };\n    let mut foo_parents = [foo_parent_one, foo_parent_two];\n\n    assert(foo_parents[y - 3].foos[y - 3].b == [2, 3, 20]);\n    assert(foo_parents[y - 3].foos[y - 2].b == [5, 6, 21]);\n    assert(foo_parents[y - 3].foos[y - 1].b == [100, 101, 102]);\n    assert(foo_parents[y - 3].foos[y].b == [11, 12, 23]);\n\n    assert(foo_parents[y - 3].foos[y].a == 50);\n\n    assert(foo_parents[1].foos[1].b == [5, 6, 21]);\n    if y == 2 {\n        foo_parents[y - 2].foos[y - 2].b = [10, 9, 8];\n    } else {\n        foo_parents[y - 2].foos[y - 2].b = [20, 19, 18];\n    }\n    assert(foo_parents[1].foos[1].b == [20, 19, 18]);\n\n    assert(foo_parents[1].foos[1].b[2] == 18);\n    if y == 3 {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 5000;\n    } else {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 1000;\n    }\n    assert(foo_parents[1].foos[1].b[2] == 5000);\n    // Set a dynamic array value\n    foo_parents[y - 2].foos[y - 3].b = foo_parents[y - 2].foos[y - 2].b;\n    assert(foo_parents[1].foos[0].b == [20, 19, 5000]);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
