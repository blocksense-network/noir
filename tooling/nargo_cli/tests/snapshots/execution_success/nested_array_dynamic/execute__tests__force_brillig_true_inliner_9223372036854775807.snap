---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "struct",
            "path": "Foo",
            "fields": [
              {
                "name": "a",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "b",
                "type": {
                  "kind": "array",
                  "length": 3,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "bar",
                "type": {
                  "kind": "struct",
                  "path": "Bar",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "array",
                        "length": 3,
                        "type": {
                          "kind": "field"
                        }
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/+1dXYhk21U+1d3V3dU1c6umu6d77nT3TFf/Tt/565r+mb6EkDFGAwqCL4IxRvvO3AtR8cFAlOTBRpGgQaMBQR8kgkoQck0eQsKN+CIqii+RvEQf5OZFQuSKoCioQT1zz+r+6quvVu3q2buraqYONHV6/6z17W/vvfbaP+ecUvbutfz/f6XifqL4HSt+S0U8Xpb2UfG7+2xXM6Ks3VQYS0OAcWwIMI4PAcaJIcBYHgKMk0OAcWoIME4PAcbKEGCcGQKM1SHAeGkIMF4eAowvDQHG2hBgrA8BxitDgHF2CDDODQHG+SHAeHUIMC4MAcbFIcB4bQgwvjwEGK8PAcalBBhT4FxOhLNlsSoHnS+K5IsO+aQ+nzTnk9J80pdPqvJJSz4pyJ3u3KnNncbcKcudntypyAftfFDMB53cqOdGMzdKeafPO1XeaPNGsQQE8WIZkve90+/+Vor/xyA+4sJIs0J6Y8o/2j08lZ+lwb9XAZnx5TefmPyJNPh3pwo5HzhplZ+RXsORpp729xOX8/FlKlsGZTHd5TS6n5RIX0YcZ6R/JkvZpt5dIEZ9hof5GSN+ptLg2TX504nkW3krorzIv5WvVvw/CXFopzrJwvZjZamL/JMXw2szMa/NXnk1PNU0ePasj88AHu7jl9Lo3g/t46Z/hrCmqptLWXvdID/Wxy9bmpMzPBWKmzhpL4fFlSHO6jdvd38I5cM4xOP1G2wrhjtxv9lP3G8ejPrN6TXqNxA35P3mYeJ+s/eCjuNHiXndH9mjVi5Qn3GRZSN7ZOFDYo9eS9xvDkb95vQa9RuIG/J+83rifnP4go7jbyTm9eHIHp1eI3sEccNtj5oPEvebo1G/Ob1G/QbihrzfHCTuN6++mON48zAxr8cje3R6jewRxA25PXo1cb95bdRvTq9Rv4G41P3mctbexsYpbgz0/OTJGZ4vArYvFfdpz1ocnu4LJzrTszsn8KOu/Jo6yVp4f/oLYVZ/Vp/TmJ7iKhA3cdKqZ6b4fwL0oCzDUab0f1L8Xyt+JyGP5a8L/ZOkvwW3CGNeKiJ9RaTPfZ3PF/fV4i9vQ42iwVq7mzjLmpU6/KIuDDNddZKFdWs+XVnEWTtDfy/FuQ6z51bHrLMM5eHxze6zIh2Gfa34zSndnm4tnzo7U3a4Kwk8FZHvURxu9jJRVu6HZcI/LXixOku9585jd7kLLsOD41VE/pplwvMXxW+O5ZXpVgyVNJzs8Rg11oETnkOZXcyydv/H5GD6l0T6y5DG9FtfR5/F8lZEvhT+g8KKY/JlKls9642LKyJ9XZTXuKhB3BXiop6GiwceVuSiTmWbzXrjYk6knxXlrQndcxSH+WrE01wank7Hh/lCHo4PqHMWyo/p8T6/yhT298WvGh9mHe5MV37Vs/Z2NOtwVyXu5hNzd1VwN+9wdxXi7B65s7BvZfG4qwo8FZHvURxumlw+K9slgYPL/W3CtwB5YtYftpmMdCk7zn3yaiJcJcKC7Qp1GrYxwZPdI78W9i/Fr2pXau6JYV6fvORwx30yVZ1aORYFdwsOd4sQZ/fInYX9RxaPu6rAw+stWTxuHlQEpjiym/uXBXclKtM1CO/HOo7pn8na6zyFH3aN8DA/uI6Tx70ssNZFHLYbjEM9Lws9SlY5oqxLVB4sf6nDr+nhMNaDbYfXYhFDTFvCz8OgrnzuXC2dhZeys/k0zsswL87bMP389JnMlwqZah/oWof8s6VWPmqJ+FDjpelSeHldBXHlf+hLW5tWvieXp0Th5Q75pogvS3+tKADOU1nmWAeZPI9E/43XVUwOpl8Q6a+Kshqf6EcuBOhGrnied61HrNdFeuyHVwkr4rseoBux1gN0e1iXRHrEcI2wou4lisM2bGWqCJkp/BbDMtGhHJNQfkzPHJQp7BVo8+y3TAruFNf1rL2eJx3u2F9eSszdsuBuyeFuGeKWBXcW9iAidzWBpyLyPYrDzT6Xj+fnPG5h2ldpXFmBPKnHFdPl2cFK1l6PKdqVYcF2hToN25jgye6RXwt7n9OucE1lXIR5fXLe4Y77ZKo6tXLcyNq5W3G4uwFxdo/cWdgHI3JXE3jYl8ricXNQEZgiyT49d3MjuuzmgfnDN0F2ifhahfB+zPFM/wxhjYzndI63SniYH57jNQTWuohjX7kh9DSEHiVrPqKsG1QebMOlDr+mh8NYD+LkcwOd5mAfLp2Fo68UOgez9FMwB/uJQqbya+cpv8U9prEy1ZqzGis9e89zMJ5DoB9tspXfyet1JQovd8g31YGvj4L95jmYpRnrIJPnYOi7efaex3NMvyzKanyiD7kSoBu54jnYjR6xror0OEYuE1bEtxqgG7HWA3R7WBsi/SqkuUFYUXeD4rANW5kSjzG7XI6JDuVgn6UhypFfZQr7JLT5Z/VZlA8V4is3EnO3lrVz13C4W4M4u0fuLOyXI3Kn7HlCn+whl4/n5mpcsbS/RuPKOuRJPa6YrpA+mXpur9qV4q/XdvWbA9An1xJzty64W3O4wzZm98idhf3O8PbJI96HjCj7Ve6r8WQ3D80f3gDZJeJrE8L7MQcz/TOENTKe0znYJuFhfngOtiWw1kUcz5u2hJ4toUfJWogoa53Kg+2s1OHX9HAY68G+HzoHe7N0Fo52OXQOZun/a+pM5pcKmcoHX++Q/8s0VvZzvRLx2hxMrX/x+XLjcDVr5xDz8bzK0r8FNpnnVZZmrINMnlc1srOLx1yTg+nXRPoGpFkt7tVcZS1A9yqk4XnVeo9YN0R6bPsNwor4NgJ0r0Ianldt9ohV2Qq08eynIb4tisN2aWVKPG7scjkmOpRjCcqP6ZmDMoX9LbR59kPUvqDiup611/OSw90GcbeVmLvtrJ27LYe7bYize+TOwr4RkbsNgaci8j2Kw80xl4/3V3gswrT/QGPFLciTeqwwXZ4drGTt9ZiiXRkWbFeo07CNCZ7sHvm1sLeddqXW3zDM65MrDnfcJ1PVqZVjJ2vn7pbD3Q7E2T1yZ2HfjsjdhsBTEfkexeHm9H1SG/FlP64I7uLIbj40H/cVkF0ivm5DeD/mVaZ/hrBGxnM6r7pNeJgfnlfdEVjrIo7X0O8IPXeEHiVrI6KsHSoP9o9Sh1/Tw2He2lDovOq7pbNwLGvovMrSvwPzKgOm/NoVyn+65lbkGYR5FermZy2VT69so6X31g3y+0bWmavNAFme7pg+vec/9Nun5zEw1Ke/UhDWT/8h9bqs4m4tAncvR+TuYv2Hwyc8n4oo+3X2qSPKfsNsOfrE7D+g/9cP/8H0zxDWVP7DDuFhfth/uC2w1kUc+w/KT7kt9ChZWxFlbVN5+u0/3BvLWsqG+48h/oOlfxv8hyb5D5if/QeLOxgA/yEjTIYRx2V+rkbZygakOX23BvGVRSvT4X66+dTeA66nHy3IyOv5PVTPOKaz37UteEJ/iH0fZRdwzcE4Nt3YR3cCZHm6Vf9Gmex3IS7Lq967YzqtD01AXMQ2/iQfzu/S+0ta1hJOwsur+FHzJ7Rxq8W9NxdT/Oz0kZ/NHvnZfAZ+Gg4/Ww4//Ww/Ww4/qn+pfcrQ/rVC/KjxU71Lx3TmtunnR7ZpZJuy3mzTmsPPyDaNbFMq26TWqxKvzRx7tg/xmH5ly7YvButrXl16WNH27VwM1sdeO/KwYhu7TXErF8/5LpcjdO3utihHfpUp7FMR15/UXqTijttA6n1Txd12BO4+E5E7Zdv4f147zO83KM7S/jbN4xOtZ8l5PPtW3Z7h4Ll5gvXEg3T7kYeHvCaGfJjeO2n4D15PNP0zWXsbT7Ge6Pk3+cXriXcF1rqIwzV3jEM9d4UeJWsroixrV2r/ycp9UeeP1FmHLcFhr2cd/tixd2uCuzWHu9sCD69x/Q2scb3p7IXyPHIrEIvneyFf/CwUjrvbFIf5uN5Tj3Oq3lHnFpS/l3r/qlPvvZ6NVuv5ah6De6NPywRxwzSPUXYQeV8mftS5DMXPVh/5WeuRn7Vn4GfF4YefB0A7YDpz2/GdAbcd6fyevb10+6h7+2rdaND9nkR+cDOkPefXef0ePjs1KH4P7qM+zX9yFjeoNtzrs1her05xXPVsOJ5TY34G1YYrfjwb2G0dnm049sGYNjzxWsxRCD+ov49rda+GjMcKq1qrU5xvXUw5XN8WdZ53TvOfEec0ao6luOM2kGpthu0XcrfjcIf2647gzsL+NyJ32wKPslWlDr+mh8NYD9YDn83BNUo8mzM5nrWUzdpdp+f9+GyOpf8GnM2pFDKVX7jWIf/lIk/qM49qTc9rz6l9aP5GgfKhU41d/E0AtYfsnTkelLn/ee3j9aLNxejjqo0/z2PLWkTu1NgyKPZxJ5J9/Cuwj3fOYR93X1D7yO/2vUj7yO/qfdHs43tH9vHc3H1fYvtYEfkeReHm8GHC/cQjXjuLKPtVXncyzpCvexDejzU70z9DWCPjOV2zu0d4mB9es7svsNZFHPZZjEM994UeJWsnoqw7VJ5++w8fiuQ/vAX+w4+fw384fkH9B34v5UX6D7w/8qL5Dz878h/Ozd3Hh9d/OE7oP7yW0H94PPIfTq+R/5BlA+E/fDqS//AF8B9+4xz+w2dfUP+hkXXmKrX/sE66XzT/4XMj/+Hc3H0+sf+guLuVtXI3rHt/X4zI3S2BZ1DGlq9EGls+B2PLW+cYW/5sAMaWdP7w2fcb8Zm5EulNdG462K80/TNZUrvX9MZp9UyhcafO+nr7696YvC30KFmzEWXZOx3U99cnKG5C5KsITClsqvGHNnVWYB3L2vnGvsPv7vi6Y1Px2zDjIox5DeWO/aBUdoXbdKf3KDF3oe9R+mZE7jYDueN2l/q5jm7vlWXuQt8r+3bidndZ5GPbnsj/Drbtpn8ma6/nFLZ9O5BXflcV5lX+UxnuMQ71qPc6KVmTEWXZN9LUt0e5H+H31C6qH6lvffbaj/7N6UeTWTt3kw53VYFHccdnX/v9DmLmLvQdxP8dkbuJQO643fX7HcTMXeg8dnwiHneh7Y79hn7PY5m70HlsNSJ3m4HccbtL9IzMKXd3BXd3HO5wvfyu4M7C5vrQ7tjeJVrbP+XunuDursMd7n3cE9xZ2FJE7s5r7xLt05xyd19wd8/hDvcY7gvuLGw9cbu7LPKViLv7abg7KJE+KweGof6ZrL2eU/ir9wN5Ne52Bda6iEObiXGoZ1foUbKqEWVNJMDlzYNC6l3pUX2/RHpxrXIa0tQhHtMfQf/i7xJVAYcn09JvUnk6tRuvnWEb4TUi1H0/QDe2Ef4u0W6PWJsivWrbNYGvSXFYd1amipCZwk4blokO5WA73RTlyK8yhX1/RDs9LfAo7u4Td9N94G46Anc/FJG7+wKP14bVOQBL/0CkxzLxszqo70GALE/3nkiPMvlZHcS1R3GKk4qQmaLNGJaJDuW4D+XH9MxBmcI+7LSZXs97qD7l2bGKwJqCu/2snbs9h7t9iLN75M7CnkTkrhnI3WLWyl2zD9w1I3D3MxG5WxR4Lot8pQ6/pofDPJsYuhf8sYmspWxm50P3gi39Z2Ev+OOFTM+f4fyfKPKkXi9Ve8G8jot42We2/FnWPjbmF9v3RZEeMbDvh+VeDJDl6VbvqEOZ7MshLn7XIXJiGCtCZoo+blgmOpRjGsrP7RU54PcJfsrp49OCO8V1PWuvt2mHu1niLvW+gOKuFoG7z0Tkblbg8drwrJBl6ddEeiwTP1eI+tYCZHm6t0R6lMnPFSKuLYpTnAzKfvYslB/TMwe8n/17TptRdlVxreZOsw53/M2gfu9nM3eh+3B/FJG7lUDubmat3KX6borH3UoE7t6MyN1NgeeyyFfq8Gt6OMyziezL4TwGfbkvky9ndh59OczLvpyl/xXw5b7q+HKzlN/i/nTky7WVe+TLdfZHYvhyfz3y5c7N3deH1JfjZzw9Xy62bn7Gc1noDvHlUo+phjN0TL0hyphfZQr7xz74csvE3Y3E3KkzsTcc7kLPxP5TRO6WBZ5B8UfeieSP/AL4I/96Dn/k30f+SHR/ZFmkD/VHPLt90f6IYQn1R5ZFOfKrzPHFodXn2R9R3NUicFeJyJ3nj6g27PkE3b750SjuVd2sBMjydN8Q6VHmOulGXOyrPI/+yKLTZkb+iO+P3IzI3XIgd69krdwt94G75QjcbUfk7hWBZ1B8uXvlrKVs5/Xlfhq/5VzI7MWXOyjyjHy5s7jFxLrZl6sK3aqPD5ovx3081B95f8Q+XhN4VJ1e9POfijtVl71y9wMOd7Wsnbuaw11V4CkJDHwuEmVZ+m6+3Gpxr+omxJfzdHfz5RqkW/lynixP96pIjzLZj0RcqxSH9XHRvpBh6eQL4ZleTM8clCnsx5z2WhXcKa6VL+Q9B857lKl9odWsnbvlCNw9jsjdisDD/7Nvkd9vUJyl/Sj5DanmOcpvYHuh7B76EuY7qbbCdm+li6wpkqXsmPJnePxJPS9cLeR1mhfyWsIqxNl9fnGb/FjEtYSqwBOyhlXtA3fVCNx9MvEaVuLz7AeGtSGwemtqqxDXIKyNNFgPDet6F6wNworzVB67Md8qlWM9TTlO26TZYWyTqJP9yQ2Is/v8KlPYr0b0J1cFHsXdGnG3kZi7TcHdhsMdPku0KbizsN+KyN1aIHd8hij12TXF3VoE7n43Inc3BZ7LIl+pw6/p4TDP5oau8/w+rfOo5+28dR5L/xFY5/kDWufB/DXKb3GfJ38t1Riq/DV+5nJScDAHafj5QPU8oZdetZ+rkIa/JY7rC4+i8NA8/abmXHzZD6zN4TpTicqUaM4T/K4c0z9DWCPjOX322Ns/zS/ry+r5Df42I8ZdgnuMQz0rQo93NjSGrDmS5a3XYJv3dHvpb/SY/maP6Vd7TL/WY/r1HtNv9Jg+9Dlis8vWZ75T2OXcJv452XXsVxOU32zoX8I4ys9hzwtM4xDGa1kLIv08pOFzBli+hQBZ3jrakkiPMvmsP+JaojjMx8/PLUHcRa37Lgmeel33/TvHX1pwuDNd+aWen7N06tuzuGbxtEwQF5E7+e1ZxF8+aS3vcmB5Lb16jgR5v0r84PMFiw4/C33kp9ojP9Vn4Kfm8DPv8DN+MfwcKH7mHX48O6f48dobjqXeOrV6F4fpzG35QmHQe7H97zi2P4Y/4I0Vqs14Z4lR91aALK+9dnvXvPdcGH6LnHWXit9Bfd9kometmiG85hf70LcEVvVeRxz/MA713BJ6lKyFiLI829XPsS+m7ermV/HYh3W15fAz30d+qj3y8yx+Z83hZ8Xh53kZ+7rxs+zwc96xT70fOKR+83ve68N5wkJA2VAW7/Vhfp5zVEXZBmXOwfvPoXOORlEvMfaf5wUebx5ZEfkuirv5CNztRORuQeApCQyqf/JenDpjYrJWushqkCzMz3vfCvNF7X2r5+1RJ8/BQ5+3P3DqtNc5uGrzijs+B9Tv5+2Zu9Bnxt8bkbtlgUetG5Q6/JoeDvP6He/3YH7c7/nAZNZSNrMluNeBeXm/x9L/MOz3fNCZGy5Qfov7wSJPP/d7vLks85N14ccbZ712hLJ4PFe+gcLM9gvbRYo+aGtO2AdZZ36NUXq8z68yhf2I0wfHHe5MV34p+zXucMe+UOqzO4q7agTuPhKRO/ZpUJY6O47peTwfF/hN1lIXWQ2ShfnZv1WYB8W/NWy9+mg/5dTpvMOd6cqveta5zSvueD8i9dlU9Y6DZYe70Hcc/FxE7hYFHq8/eOOD4jqjfGWRdo7iLO0naBxN9cyFGke74ce5ehnuMQ79jutZO28Vyp9FKlNz7+iIufxCwWX+84vnWO/+JWhzvN6N5yxC1q9VG8U99dWsFZ/ndyhZ3ppTt31Wfqca4nrWfVbVn0L3WS0vt79fF/VSoTT59aj43X2Wa+/1I7XeZhwlXm/b73Wv0uM7y9rr55pIjzbH+nCd0iPXg7aePebwo/rtmMOP4hP7B69nh+51j/WRn2qP/PRqW5AfXs/Gvj+oe7le+1Fn/bz2o/hUZ5PrWTt33nq26clN4TfPMbZ98QLHNn5/wWhs6zy2fU3Uy6CNP17/UBz2al+RQx5/0L6aDzlo489cj/zMPQM/3vjjjc8X1H56Hp/VXoXXfrrtzw3j+OONzzWnvIqfbuPPTeIH7SPPm9V3ZkPHHw+/t2aq6jLkeXssR4p1Dms7uM6h/J6xrN32t+yXU9i3nHWOmM/be+NsKWtf96sJ/F6fxfS8ZqKeU+X/yyJtmeIs7T/Tmkk/3inSdlbO8a+sTMiX518pfpGX9eJePZ9TDZDlfU/Kszf5PX/fRj1HG9L3le4rIr16VrwWgMuzFVcg7qJsxRXBU6+24n8GwFagLG9M9nxy1OfNmfGbSPk1AXH9nDP3ys/VzOfHvldVp/SqbtR3t16CNMbjoPnILwFu5rPmlCm/QuafyJNxpPbDph1++ukDTjr8qPHDs+Hdxo9N4gdtAbdF79uOEw6u/J59O+Un1oQe3v+bpLhHxf+7z3iVCOdEh3IYtjFKj/f5Vaaw1eJG2WvFHYZ5+3/sY08JWZjenl9VXFtePndi8flVydrLHXPNoUT6MsLPWGdEGSPiaYbwml9jxJ16j4t6RyU/89nruzlQ1mxEWWUqD+7ZlTr8mh4OYz24f8hnndB+4Vmn/amspWzquW7My2edLP0H4KzTw+K+JvLzfMPi3lPksX6QqN3J+YbpUni5f6bCxTYL7STqNGxjWbudQdtWprDvcezkGJUJw7KsvZ2VBJ5qpudKvKet+o6yyaHjrKU33Wg/Q+Zp3lzpkkhfdXQr+8NYygLnNOmdEnjU/FP1+ymSpXxZlIu+bKmDTrQTIWfyY793kPunen7Dk7Xo6N4S6Vcc3YiLnzuzfGWBk89pLwk880KWWmPlZ7G6nb/kOh4XOvHcq7dOaDrVGvoqhDHP3d6Nb23NdKt3Snuybjq6u7Uv1o24MC/mKwucnd45i3jU2X3vPaie7UKbwHWs7AW+y6YWoFPxrPycmDx7sl5xdHd7fyjrVu8PZSxlgZPb4qLAUxOy1Humub2oOXpoHVtefC/1MNbxbUf3qI7fvfA7MiF17L0Pk8uV/62J9B7PWMa1AFmerVbj8ZqjW30vlLGoOua22K2O+UzJRdTxlwO+Gc1jjdLJ5epUL9738RQXnqxefa41Rzfi6lbHXj+oCTzTQpb6djj7P2oeg22K61i9tzWvn49RHW8KPKZzR+hUz/Zb+jsi/Q6kYZ7xObA7AbJuObrvivR3HN2IC/NivrLAuUN6twWeTSFLvbNxm2Sp90GF1rHlzev4K+OtZR2mOr7r6L4n0ofWMeZ9Hur406M6fu7r+ENDXMeeXz2y1e9eeR3vjOr4ua/jSapj5XuaTuWr4nslxzqUF9Pz8/6oe9Mpr5Ll+VyqPW47uhEX5sV8ZYFzi/RuCjyqHtU7UDdJlppLhK5lWt6nayBjrWXFd4WH1DHiuOg69ta51LuyQusY88ao4w0hK6SO1XtZQ+vY8uZ1/N1Sa1lxXXyddDaETvWeXq8dNiAN87wKcSHzY8+GKDu35uhGXJgX85UFzgbpXRV4loQsq2PkeJVkqefWQ+vY8uZ1/CbVMT7/ymdme32naOp9J2+dq9taprfv1G0ts9d9p+tCljrXxftO17P2MoTWseXN6/jDVMe4HnaNdHrn0rhc+V+3c4HMs3oO0ZPlrXOpM5tXHd1qT5WxlAVO7gdzAs+kkKWeP+V3kqv949A6xv3jalHHKc/9PTx69xzFU6wnZ3zhHn9G+suUfqtYnJuBctjvxDPgfOPhcfONveM3jg+OnzzZf3zM51DyC89SxNZ//HDv6PGD/ccPXzvYO947vHD9jw8OX3u8f3C8+3oz//dBN/2n6+AnZ/F4jjS/por/7awMpzd5ZUrfLOo4b5d79DxgWejL073fSVfq8PtUhgibOGkNq5y0px8/aU9vumdO2jFaXBXiyqTnUvE/8oWyDEeZ0r+vKLvVyTTksfx1oX+a9LfgFmFor1jWuAiz9Hn9HFG/xbLHsi+7xbnFpzpJPoYxNms7ebv+P91wWbcRbAEA",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "struct Bar {\n    inner: [Field; 3],\n}\n\nstruct Foo {\n    a: Field,\n    b: [Field; 3],\n    bar: Bar,\n}\n\nstruct FooParent {\n    array: [Field; 3],\n    foos: [Foo; 4],\n}\n\nfn main(mut x: [Foo; 4], y: pub Field) {\n    assert(x[y - 3].a == 1);\n    assert(x[y - 3].b == [2, 3, 20]);\n    assert(x[y - 2].a == 4);\n    assert(x[y - 2].b == [5, 6, 21]);\n    assert(x[y - 1].a == 7);\n    assert(x[y - 1].b == [8, 9, 22]);\n    assert(x[y].a == 10);\n    assert(x[y].b == [11, 12, 23]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n    // Check dynamic array set\n    if y != 2 {\n        x[y].a = 50;\n    } else {\n        x[y].a = 100;\n    }\n    assert(x[3].a == 50);\n\n    if y == 2 {\n        x[y - 1].b = [50, 51, 52];\n    } else {\n        x[y - 1].b = [100, 101, 102];\n    }\n    assert(x[2].b == [100, 101, 102]);\n\n    assert(x[y - 3].bar.inner == [100, 101, 102]);\n    assert(x[y - 2].bar.inner == [103, 104, 105]);\n    assert(x[y - 1].bar.inner == [106, 107, 108]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n\n    let foo_parent_one = FooParent { array: [0, 1, 2], foos: x };\n    let foo_parent_two = FooParent { array: [3, 4, 5], foos: x };\n    let mut foo_parents = [foo_parent_one, foo_parent_two];\n\n    assert(foo_parents[y - 3].foos[y - 3].b == [2, 3, 20]);\n    assert(foo_parents[y - 3].foos[y - 2].b == [5, 6, 21]);\n    assert(foo_parents[y - 3].foos[y - 1].b == [100, 101, 102]);\n    assert(foo_parents[y - 3].foos[y].b == [11, 12, 23]);\n\n    assert(foo_parents[y - 3].foos[y].a == 50);\n\n    assert(foo_parents[1].foos[1].b == [5, 6, 21]);\n    if y == 2 {\n        foo_parents[y - 2].foos[y - 2].b = [10, 9, 8];\n    } else {\n        foo_parents[y - 2].foos[y - 2].b = [20, 19, 18];\n    }\n    assert(foo_parents[1].foos[1].b == [20, 19, 18]);\n\n    assert(foo_parents[1].foos[1].b[2] == 18);\n    if y == 3 {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 5000;\n    } else {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 1000;\n    }\n    assert(foo_parents[1].foos[1].b[2] == 5000);\n    // Set a dynamic array value\n    foo_parents[y - 2].foos[y - 3].b = foo_parents[y - 2].foos[y - 2].b;\n    assert(foo_parents[1].foos[0].b == [20, 19, 5000]);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
