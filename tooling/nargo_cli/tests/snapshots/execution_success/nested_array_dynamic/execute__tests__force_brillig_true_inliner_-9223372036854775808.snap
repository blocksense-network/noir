---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "struct",
            "path": "Foo",
            "fields": [
              {
                "name": "a",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "b",
                "type": {
                  "kind": "array",
                  "length": 3,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "bar",
                "type": {
                  "kind": "struct",
                  "path": "Bar",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "array",
                        "length": 3,
                        "type": {
                          "kind": "field"
                        }
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "struct Bar {\n    inner: [Field; 3],\n}\n\nstruct Foo {\n    a: Field,\n    b: [Field; 3],\n    bar: Bar,\n}\n\nstruct FooParent {\n    array: [Field; 3],\n    foos: [Foo; 4],\n}\n\nfn main(mut x: [Foo; 4], y: pub Field) {\n    assert(x[y - 3].a == 1);\n    assert(x[y - 3].b == [2, 3, 20]);\n    assert(x[y - 2].a == 4);\n    assert(x[y - 2].b == [5, 6, 21]);\n    assert(x[y - 1].a == 7);\n    assert(x[y - 1].b == [8, 9, 22]);\n    assert(x[y].a == 10);\n    assert(x[y].b == [11, 12, 23]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n    // Check dynamic array set\n    if y != 2 {\n        x[y].a = 50;\n    } else {\n        x[y].a = 100;\n    }\n    assert(x[3].a == 50);\n\n    if y == 2 {\n        x[y - 1].b = [50, 51, 52];\n    } else {\n        x[y - 1].b = [100, 101, 102];\n    }\n    assert(x[2].b == [100, 101, 102]);\n\n    assert(x[y - 3].bar.inner == [100, 101, 102]);\n    assert(x[y - 2].bar.inner == [103, 104, 105]);\n    assert(x[y - 1].bar.inner == [106, 107, 108]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n\n    let foo_parent_one = FooParent { array: [0, 1, 2], foos: x };\n    let foo_parent_two = FooParent { array: [3, 4, 5], foos: x };\n    let mut foo_parents = [foo_parent_one, foo_parent_two];\n\n    assert(foo_parents[y - 3].foos[y - 3].b == [2, 3, 20]);\n    assert(foo_parents[y - 3].foos[y - 2].b == [5, 6, 21]);\n    assert(foo_parents[y - 3].foos[y - 1].b == [100, 101, 102]);\n    assert(foo_parents[y - 3].foos[y].b == [11, 12, 23]);\n\n    assert(foo_parents[y - 3].foos[y].a == 50);\n\n    assert(foo_parents[1].foos[1].b == [5, 6, 21]);\n    if y == 2 {\n        foo_parents[y - 2].foos[y - 2].b = [10, 9, 8];\n    } else {\n        foo_parents[y - 2].foos[y - 2].b = [20, 19, 18];\n    }\n    assert(foo_parents[1].foos[1].b == [20, 19, 18]);\n\n    assert(foo_parents[1].foos[1].b[2] == 18);\n    if y == 3 {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 5000;\n    } else {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 1000;\n    }\n    assert(foo_parents[1].foos[1].b[2] == 5000);\n    // Set a dynamic array value\n    foo_parents[y - 2].foos[y - 3].b = foo_parents[y - 2].foos[y - 2].b;\n    assert(foo_parents[1].foos[0].b == [20, 19, 5000]);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
