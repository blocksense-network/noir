---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "struct",
            "path": "Foo",
            "fields": [
              {
                "name": "a",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "b",
                "type": {
                  "kind": "array",
                  "length": 3,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "bar",
                "type": {
                  "kind": "struct",
                  "path": "Bar",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "array",
                        "length": 3,
                        "type": {
                          "kind": "field"
                        }
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "pdzRzhvHkQXgd9G1L1jdXdXVeZUgCBxHCQwIsqHYCywMvftO1dQ5JQEbwBjeuD9JnnNI/qwhOWzpjw///PiP3//9958//+uX/3z4y1//+PCPLz9/+vTzv//+6Zeffvzt518+X7/7x4dX/Ed8fviL/HCtq1at1WrdtXqt517PdfiIVWodtc5aV61aq9W6a/VaT67j9apVah21zlpXrVqr1bpr9VorTypPKk8qTypPKk8qTypPKk8qT668ea3jVavUOmqdtV55K1at1WrdtXqt517nq1apddQ6a628WXmz8mblzcqblbeuPI1Vah21zlpXrVqr1bpr9VrPvWrlaeVp5emVZ7GuWrVWq3XX6rWee7VXrVLrqLXy7MrbsWqtVuuu1Wu98vxa96tWqXXUOmtdtWqtVuuu1WutPK88rzyvPK88rzyvPK88rzyvPK+8U3mn8k7lnco7lXcq71RezMeJ1Ws9uc6Yj1yl1itPXoEJLEABAzbgwCnEnNwQAMmCZEGyIFmQLEiOeREJnEJMzA0BBjCBBShgwAaQPJA8kTyRHNMjIzCBBShgwAYcOIWYohsCIDkGSWZgAQoYsIFIXoFTiHm6IcAAJrAABQzYAJIVyYZkQ7Ih2ZBsSDYkG5INyYZkQ/JG8kbyRvJG8kbyRnJMmmhgAw6cQkzbjUi2wAAmsAAFDNiAA6cQc3cDyQfJB8kHyQfJB8kxfrIDDpwbKybwhgADmMACFDBgAw4gWZCcM+iBAUxgAQoYsAEHTiFnMIHknMETmMACFIjXwldgAw6cQszgDQEGMIEFKIDkieSJ5InkheSF5IXkheSF5IXkheSF5IXkhWRFsiJZkaxIjhkcElDAgA04EMnXyWHFDN4QYAATWIACBmzAASRvJG8kbyRvJG8kxwyOGTBgAw6cQszgDQEGMIEFINmR7Eh2JMcMjusMsPK9YUKAAUxgAQoYsAEHKlnzXaIGBBjABBaggAEbcOAUBMmCZEGyIFmQLEjOd40W2IADpxAzeEOAAUxgAQogeSB5IHkgOWdwBwQYwAQWoIABG3DgFBaScwY9EMknsAEHTiHnKyEAjsr5SixAAQOQrEhWJBuSDcmGZEOyIdmQbEg2JBuSY6zmKyDAACawAAUM2IADp+BIdiQ7kh3JjmRHsiPZkexIdiQfJB8kxzRNCUTgCChgwAYcODcspumGAAOYwAIUMGADDiBZkCxIFiQLkgXJgmRBsiBZkJwfw66TjOXnsIQAA4jkFYhkDShgwAYcOIWYphsCDGACSJ5InkiOaZoWcOAUYppuCDCACSwgcnbAgVOI+bohwAAmsAAFrB6WmK8bDpxCzNcNAQaARzXm64YCSDYkG5INyRvJG8kbyRvJOV8eMGADDpxCzldCgAFMYAFIdiQ7kh3JOV/XOcFyvhICDGACC1DAgA04UMn79QIEGMAEFqCAAfFZ/xWID/vXvO+YrxsCDGACC1DAgA04gOSB5IHkgeSB5IHkgeSB5IHkgeSB5InkvOQxAgOYwAIUMGADDpxCzNcNJMd8rRmYwAIUMGADDpxCTNwNAZCsSFYkK5IVyYpkRbIi2ZBsSDYkG5Jj4tYKKGDABhw4hZi4GwIMYAJIjtFbGjBgAw6cQozeDQEGMIEFINmR7Eh2JDuSD5IPkg+SD5IPkg+SD5Jj9JYFHDg3PEbvhgADmMACFDBgAw4gWZCcM7gDA5jAAhQwYAMOnELOYALJOYMemMACFDBgAw6cQs5gQgAkTyRPJE8kTyRPJE8kTyQvJC8kLyQvJOcMnoACBmzAgVPIGUwIMIAJIFmRrEhWJMcM6itwCjGDNwQYwAQWoIABG0ByzKBepziPGbwhwAAmsAAFDNiAA0h2JDuSHcmOZEeyI9mR7Eh2JDuSD5JjBnUEBjCBBShgwAYciOTrPHZiBm8IMIAJLEABAzbgAJJjBnUFBBjABBaggAEbcOAUBpIHkmMGVQMTWIACBmzAgVOIGVQLCDCACSxAAQM24MApLCTnlwA7MIAJLEABAzbgwCnktwEJJCuSFcmKZEWyIjlmUD3gwCnkDJ6AAAOYwAIUMGADDpzCRvJG8kbyRvJG8kbyRvJG8kbyRrIj2ZHsSHYkxwzaK6CAARtw4BRiBm8IMIAJIPkg+SD5IPkg+VSyvF4vSqhBTWpRSkWBpDbl1IFiHEtCDWpS0TFSShm1KacOFINZEmpQk2JHTKfNlFGbcupAMaIloQY1qUWxY7JjsmOyY7JjsSOm1VZqUJNalFJGbcqpA8XYltih7FB2KDuUHcoOZYeyQ9lh7DB2GDvy6z1NLUopozbl1IFilEvRYalBTWpRShm1KacOFENdYkeMte3UpBallFGbcupAOd63hGLHYcdhx2HHYcdhR465p05Jcs5vCTWoSS1KKaM25RQ7hB3CDmGHsEPYIewQdgg7hB3CjpzzkxJqUJNalFJGbcqpA012xJzvV2pQk1qUUkZtyqkDxZyX2LHYsdix2LHYsdgRc74l5dSBYs5LQg1qUotSyih2KDuUHcYOY4exw9hh7DB2GDuMHcaOmPMdZ2qJOS8JNahJLUopo6Jjppw6UMx5SahBTWpRShnFjpjzvVIHijkvCTWoSS1KKaM2xY6DjtwwUxJqUJOKDk0pZdSmnDpQzHlJqEFNih3CDmGHsEPYIewY7BjsGOyIOd+WWpRSRkXHTjl1oJjzklCDmtSilDKKHZMdkx2LHYsdix05555alFJGbcqpA+Wc3xJqUOxQdig7lB3KDmWHssPYYewwdhg7jB055ydl1KacOlDO+S2hBhVbZF6pRSll1KacOlBu6Lkl1KDYkRt7JBUdIxUdMxUdOUe5wefWgXKTzy2hBjWpRSllFDsOOw46cuNP3qrc+lOKDk1NKjospVR07FR0eMqhmGk/qUFNalFKGbUpp049krn1p8TbHDNdmtSqxzn3/5SM2pRTB4qZLgk1qEmxY7JjsmOyY7JjsmOxY/F+LN6PxfsRM11SyqhNORSTfF4poQY1qUUpZdSmnDqQsSMm+eTPIya5FB15W2KSS0oZFR35GMQklw4Uk1wSalCTWpRSRrFjs2Ozw9nh7HB2ODuc98N5P5z3Iya55NSBYpJLQkVyzmDM78kpi/ktGbUpp04ptw2VhBrUpBallFGbcoodwg5hh7BD2BEzfSyllFGbcupAMdMloQY1KXYMdgx2DHYMdgx2THZMdkx2THbETJ+dUsqoTTl1oJjpklCDmhQ7YqaPp4zalFMHyum+JdSgJrUodig7lB3KDmWHsSOn+6QGNalFKWXUppw6UE73LXZsdmx2bHZsdmx25D7A1yvpzdyBGqei3IkESnM0cyfqSOZe1JnMsJXMsHyO5wbAotQLYe4/Kk0qk25q05q76c0D5m6k+7bkfiQwb/dOzuZqatOau+nNQ947dbP43qt7czRnczW1ac3d9Gbft9Fto9tGt41uG3jrkduXSkZtyqkD5cv4LaEy2pN5R05Sm1bvenIPU8mp3CccT7LcxwRKczRnczVzN7IkrZk7kkfSm4fMPb5FaY7mbHZb7vYtWnM3vdn3zfq+Wd836/tmfd+s26zbrNus24wPZO61T+Vu+1tCDWpSi1Iqo3M0cvxjk7Dkfqlijn9RmqM5m6upTWvuZrd5t51uO912uu102+m2022n20635SlC8h7nKSKZW6xAaY7mbK6mNq25m97sNuk26TbpNuk26TbpNuk26bZ7c78lD3lv8N9JaY7mbGabJ7WJzye5L6vk1IHyJHFLqEFNalFKsWOyY7JjsmOxY7FjsWOxY7FjsWOxY7HjPkWc5CHvU8RNaY7mbK6mNq25m92m3WbdZt1m3WbdZt1m3WbdZt1m3WbdlieJ/LnmSeLWoKIqtlhfXE1tWnM3vXnIPGUUpTma3ebd5t3m3ebd5t3m3Xa67fCeHd6zfEtxa1FKGbUpp7IlXl5ykxgozdGczdXUpjV305vdJt0m3SbdJt0m3SbdJt0m3SbdlqeK2JcuuasMlOZozuZqatOau+nNbpvdNrttdtvsttlts9tmt81um912/42heFHb998ZuinN0ZzN1dSmNXfTm92WJ5DYCy+5Jw0czdlcTW1acze9eUjrtt0JuxN2J9yTqslD3pN6U5qjOZurqc0Mi1ec3BQmsS9dcjeYxM50yf1gEru6JXeEgbsZtyw2TEvuC7uZO8PAuGWxz1hyd5jEdmLJ/WHgSn79+sMH/B3av//25ePH+Cu03/yl2r/+8eHXH798/Pzbh798/v3Tpx8+/M+Pn37P/+k/v/74Odfffvxy/enV+vHzP6/1CvzXz58+hr7+0Ee//vuhI4YrD74uf/Nw/fPHx8m6jt/vHT/Xk+NjK9h9vD66/cb+Le/17/HkeOfxZz463nj8euv464Lwg+NnvKW7jx9Pbv+c7J/+Xv88T45XHm+vR8dPHi9vHv/o/scF4Pv48+T2rxf6rwuFb/Vflxef9A8e/+j5s8aLx6/3jp9P5nctPH+vy3RPjjc8/66LZ+/1P3r+rP75+ZOfnwpeP66rRG/1X5eWnvQr7v91reLJ8RvP/+vKwoPjLa6m5fHXZ+Qnx0+c/+3R+eub49d47/hHz9898PjvR6/fO74SuY8/Tx7/+C6oAuKLnye3QHEGuN7sPjn+xeNfj34Cmz+BRxO4+Qzee715/H7v+PPkDOSC433Ie8c/ega74Qnkj97B+cEZ4Lze6z+P3oEdvgM6j15BD9/BHn2zX588fsdwBjn7yeN3DvsfPf++6T9PzsCx3xVnoJfqowTrBHuUIHwbExscHyXwNBSby54k9Ee52F71KIEvprEt692E+ej1ZPDlIDZDvXsbHr2ixH4nJri+m/DwdVX4OEwZb96GKY8ehzk6Yem7CbrfTdj+KOHgLW5srXg74dFtWHMyYeq7t2Hao9ugwgQ77yY8eq/yXcKzyVK+3ZNnn3i+SxiPJkunMuHZWe7b2/Doukt8X4WEZ58c4pu2TpB3E+zRGWbz8lNcj3+S4MLXbn90BUHceS+evQMcL+VFxNd+dBX0NSYT1rOfxeZ58vpq7VHCi+9Arm+hHz2r+zZcX/g/SrCeLJ/vJpxHZxg7fB+1n71efJcw30149n7y24RHVzbiCycmPLq29V3Co7n4LsHl7YRH5+rND5jxJdKThCM8y51nP80ztBMe/TT9dMKjz8nfnSefPau/TXj2yuu83Chuz+7F6IQp777irEfvQHz1M+rZZ5xvb8Ozzzh92UGOnncTHl37/S7h0bWH7xP03YRHrzjXS/6rX/3165vvH9y/vvn+4dHzYQi/iBrXtYh3Ex5dPRiy+EjKo8n67jY8+8R6tvy/z6hHAd++ZP35nyW/Urp+luPJLTgd8BpPbsGrA7490//5ANkMGPruLbD/EiDxj+X9icvibm8+iOO7gL9dv/jxp5+/fPfvr3+NqC8///iPTx/rl//6/fNP3/zpb//7K/4E/377r19++enjP3//8jGS4s/uf8T9+s9fr3ca+4frtcr/9sOHGb++rlDKXtevJP9427h+bTt+Q/I3rmfd9Z/5t69xA/8P",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "struct Bar {\n    inner: [Field; 3],\n}\n\nstruct Foo {\n    a: Field,\n    b: [Field; 3],\n    bar: Bar,\n}\n\nstruct FooParent {\n    array: [Field; 3],\n    foos: [Foo; 4],\n}\n\nfn main(mut x: [Foo; 4], y: pub Field) {\n    assert(x[y - 3].a == 1);\n    assert(x[y - 3].b == [2, 3, 20]);\n    assert(x[y - 2].a == 4);\n    assert(x[y - 2].b == [5, 6, 21]);\n    assert(x[y - 1].a == 7);\n    assert(x[y - 1].b == [8, 9, 22]);\n    assert(x[y].a == 10);\n    assert(x[y].b == [11, 12, 23]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n    // Check dynamic array set\n    if y != 2 {\n        x[y].a = 50;\n    } else {\n        x[y].a = 100;\n    }\n    assert(x[3].a == 50);\n\n    if y == 2 {\n        x[y - 1].b = [50, 51, 52];\n    } else {\n        x[y - 1].b = [100, 101, 102];\n    }\n    assert(x[2].b == [100, 101, 102]);\n\n    assert(x[y - 3].bar.inner == [100, 101, 102]);\n    assert(x[y - 2].bar.inner == [103, 104, 105]);\n    assert(x[y - 1].bar.inner == [106, 107, 108]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n\n    let foo_parent_one = FooParent { array: [0, 1, 2], foos: x };\n    let foo_parent_two = FooParent { array: [3, 4, 5], foos: x };\n    let mut foo_parents = [foo_parent_one, foo_parent_two];\n\n    assert(foo_parents[y - 3].foos[y - 3].b == [2, 3, 20]);\n    assert(foo_parents[y - 3].foos[y - 2].b == [5, 6, 21]);\n    assert(foo_parents[y - 3].foos[y - 1].b == [100, 101, 102]);\n    assert(foo_parents[y - 3].foos[y].b == [11, 12, 23]);\n\n    assert(foo_parents[y - 3].foos[y].a == 50);\n\n    assert(foo_parents[1].foos[1].b == [5, 6, 21]);\n    if y == 2 {\n        foo_parents[y - 2].foos[y - 2].b = [10, 9, 8];\n    } else {\n        foo_parents[y - 2].foos[y - 2].b = [20, 19, 18];\n    }\n    assert(foo_parents[1].foos[1].b == [20, 19, 18]);\n\n    assert(foo_parents[1].foos[1].b[2] == 18);\n    if y == 3 {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 5000;\n    } else {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 1000;\n    }\n    assert(foo_parents[1].foos[1].b[2] == 5000);\n    // Set a dynamic array value\n    foo_parents[y - 2].foos[y - 3].b = foo_parents[y - 2].foos[y - 2].b;\n    assert(foo_parents[1].foos[0].b == [20, 19, 5000]);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
