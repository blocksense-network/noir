---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "struct",
            "path": "Foo",
            "fields": [
              {
                "name": "a",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "b",
                "type": {
                  "kind": "array",
                  "length": 3,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "bar",
                "type": {
                  "kind": "struct",
                  "path": "Bar",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "array",
                        "length": 3,
                        "type": {
                          "kind": "field"
                        }
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "struct Bar {\n    inner: [Field; 3],\n}\n\nstruct Foo {\n    a: Field,\n    b: [Field; 3],\n    bar: Bar,\n}\n\nstruct FooParent {\n    array: [Field; 3],\n    foos: [Foo; 4],\n}\n\nfn main(mut x: [Foo; 4], y: pub Field) {\n    assert(x[y - 3].a == 1);\n    assert(x[y - 3].b == [2, 3, 20]);\n    assert(x[y - 2].a == 4);\n    assert(x[y - 2].b == [5, 6, 21]);\n    assert(x[y - 1].a == 7);\n    assert(x[y - 1].b == [8, 9, 22]);\n    assert(x[y].a == 10);\n    assert(x[y].b == [11, 12, 23]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n    // Check dynamic array set\n    if y != 2 {\n        x[y].a = 50;\n    } else {\n        x[y].a = 100;\n    }\n    assert(x[3].a == 50);\n\n    if y == 2 {\n        x[y - 1].b = [50, 51, 52];\n    } else {\n        x[y - 1].b = [100, 101, 102];\n    }\n    assert(x[2].b == [100, 101, 102]);\n\n    assert(x[y - 3].bar.inner == [100, 101, 102]);\n    assert(x[y - 2].bar.inner == [103, 104, 105]);\n    assert(x[y - 1].bar.inner == [106, 107, 108]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n\n    let foo_parent_one = FooParent { array: [0, 1, 2], foos: x };\n    let foo_parent_two = FooParent { array: [3, 4, 5], foos: x };\n    let mut foo_parents = [foo_parent_one, foo_parent_two];\n\n    assert(foo_parents[y - 3].foos[y - 3].b == [2, 3, 20]);\n    assert(foo_parents[y - 3].foos[y - 2].b == [5, 6, 21]);\n    assert(foo_parents[y - 3].foos[y - 1].b == [100, 101, 102]);\n    assert(foo_parents[y - 3].foos[y].b == [11, 12, 23]);\n\n    assert(foo_parents[y - 3].foos[y].a == 50);\n\n    assert(foo_parents[1].foos[1].b == [5, 6, 21]);\n    if y == 2 {\n        foo_parents[y - 2].foos[y - 2].b = [10, 9, 8];\n    } else {\n        foo_parents[y - 2].foos[y - 2].b = [20, 19, 18];\n    }\n    assert(foo_parents[1].foos[1].b == [20, 19, 18]);\n\n    assert(foo_parents[1].foos[1].b[2] == 18);\n    if y == 3 {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 5000;\n    } else {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 1000;\n    }\n    assert(foo_parents[1].foos[1].b[2] == 5000);\n    // Set a dynamic array value\n    foo_parents[y - 2].foos[y - 3].b = foo_parents[y - 2].foos[y - 2].b;\n    assert(foo_parents[1].foos[0].b == [20, 19, 5000]);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
