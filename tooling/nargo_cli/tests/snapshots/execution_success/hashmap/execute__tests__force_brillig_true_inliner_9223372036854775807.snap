---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "955212737754845985": {
        "error_kind": "string",
        "string": "HashMap should have retained 2 elements."
      },
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "5727012404371710682": {
        "error_kind": "string",
        "string": "push out of bounds"
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "6895136539169241630": {
        "error_kind": "string",
        "string": "HashMaps should not be equal."
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "9417307514377997680": {
        "error_kind": "string",
        "string": "HashMap after one insert should have a length of 1 element."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12389747999246339213": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14479745468926698352": {
        "error_kind": "string",
        "string": "HashMap after one insert and corresponding removal should be empty."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16567169223151679177": {
        "error_kind": "string",
        "string": "HashMaps should be equal."
      },
      "16850003084350092401": {
        "error_kind": "string",
        "string": "Load factor is exceeded, consider increasing the capacity."
      },
      "16954218183513903507": {
        "error_kind": "string",
        "string": "Attempted to read past end of BoundedVec"
      },
      "17677620431177272765": {
        "error_kind": "string",
        "string": "HashMap length is invalid."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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Z54gLE++N0//IZnE8pWuX8TpPySTWL7+9WOcOoSfPwRDO7THx23x/eH85osL+efhgYXoBTV9xwmy4sQPxvnziiNO4182Hucn/PlEovva/iHdieGrbUtMM2NMs0BMk+FrhktM02JM02FM02NMkzCmGTCmiWFBhGFBhGFBhGFBAcOCAoYFBQwLChgWxPD1/CWmiWFBAcOCAoYFBQwLChgWFDEsKGJYUMSwoIhhQQyPMS0xTQwLihgWFDEsKGJYUMSwoIRhQQnDghKGBaUlLahGp3WjL2krNfqSBlKjL2kVNfqSplCjL9n9v6LnJTt6jb5kl67Rl+y8Nfq63ZThkemPRV+3m+Z1u2mW3E2TPaKnt7vWntEld9NBdMndtB+9SO6mg+iSu+kguuRuOoguuZsOokvupoPoy9T1/Ff0bARXmGjC6+m86E/RBVeYUXTBFSY6/3ym7fEjnaILrjCj6IIrzCi6YF8fRRfs66Poguv6KLpgXx9FF+zrg+hWcjcdRJfcTQfR1+2mdt1uynEsyaeir9tN7brd1K7bTe263dSu203dut3UrdtN3brd1K3bTRlO9vlY9HW7qRPTTWscMR2yxhHT9WocMZ3sK44X051qHDEdp8YR00VqHDGdocYRU+1rHDEVvMaRVZXlnDVV48iqynLObvqKc/8ZS/n54hJcX0Y8xeef4jxld4pu143u1o3u141O60YP60aP60ZP60bP60Yvy0YP63bTsG43Det207BuN73/7Bu+6Ot207BuNw3rdtOwbjcN63bTuG43jet207huN43rdtP7z1Dhi75uN43rdtO4bjeN63bTuG43Tet207RuN03rdtO0bje9/9wOvujrdtO0bjdN63bTtG43Tet207xuN83rdtO8bjfN63bT+8/t4Iu+bjfN63bTvG43zet207xuNy3rdtOybjct63bTsm43vf/cDr7o63bTsm43Let207JuNy3LdtNilu2mxSzbTYtZtpsWs2w3LWbZblrMst20mGW7aTHLdtNilu2mxYjppl9xrJgOWeOI6Xo1jphOVuOI6U41jpiOU+OI6SI1jpjOUOOIqfY1jpgKXuPIqspOVlV2sqqyk1WVbz87JBl6xkk2d2XERluOGNGZ/vU19vEX0ecjso+fve2LjnGH6Bh6zdC1Qgc6zpKl/P7SipAU4VWEQRFeRRgV4VWESRFeRZgV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0wyfgvvo0f1Hj/7Jq6gpxI8enVqP7varee589PTRo+ePHr317/3Ndc6rab/s077wBERePkNaX8vkjpPU16trQ7FunyzF5Qra8eLLpahc/fZi58L9i713Zf9oybuXa3ILyC998ZOXiVPkTx699SMd4ej+o0cP3f5s3b5flvzL32JyG0r8CsrL7LWjJOqFUqvbO9J6iZJwUHI/lP1ab62BLlAKDkrt+AblAyWdUVqv34f9WXuhnlNF6/X7UPeuqMbz0dNHj54/evTy0aNXvXeVzkfnTx699fq9cPTWz9r2hBfPV+BS6/V74ejxo0dvPVf3a5PRXXhPHz16/ujRy0ePXj96dP7k0Vuv3wtHbz1X9yt3MZ7/3luv3wtHjx89On306OmjR88fPXr56NHrR4/e+h2WtE3uMZ+vNrD76NH9R48ePnr0+NGjp48enX/8bdXsGm3efuMzu/jRo9NHj958NfHmSmh2n7yamN0nv5OZfWulv/vWZPatZ+Ddtyazb62Wd98NzD599Oj5o0cvHz161XtXz2eT508ePbiPHt1/9Ojho0ePHz06ffTo6aNHb/7G5823VXMoHz1667fI7r5Pmls/6bo/enQfPbr/6NHDR48eP3p0+ujRW7/xefd90hzzR49ePnr0+tGjf/Lb2ZncR4/uP3r08NGjx48enT569I+eq/TRc5U+eq7SR89V+uS3s3NyHz26/+jRw0ePHj96dPro0dNHj54/evTy0aPXjx79o+dq/ui5mj96ruaPnqv5o+fqm2843N2nkfPP77nIuf7B7/z8not8/em78Ds/v+cil/AHvxP/4HfoD34n/cHv5D/4nfIHv1P/4Hf4579Tf37PRa7hD34n/sHv0B/8zs/vucg1/8HvlD/4nfoHv/Pzey4yuz/4Hf8HvxP+4HfiH/xO850Ux3fu0/non7yTInP96NH5g0cv7pN3UhTnP3r08NGjx48evXEuuP10snz0s8/y0c8+S/Nnn/dHrx89ere7QNLelWb327eSB74LpPgP3Y2wHj1+9Oj00aN/csFUab4l7e6L46X5lrS7r0eX5lvS7o+ePnr0/NGjF713lc5Hrx89+ie/ll6i++jR/UePHj569PjRo9NHj976hYC7r9SX1g8ZhaOXjx69fvTo/Mmjt37IKBzdf/Torefq3VfqS/MNk/dHp48ePX306PmjRy8fPXr96NE/eQtJSe6jR/cfPfpHz9X00XM1ffRcTR89V9MnbyEpqXz06PWjR+dPHr15Der90f1Hjx4+evT40aPTR4+ePnr0j56r+aPnav7ouZo/eq6Wj56r5ZO3e5USPnr0+NGj00ePnj569PKho/+f5f/5f//jv/23//if/vW//j/LL/z13/73f//P/+u//Y//vv6//+v/+5/bf/lP//bf/vVf/9v//R/+57/9j//8X//L//63//of/vV//Oe//tu/c+v/+b8WVk7//q8HSuSF/K/3M8R/H+NfUfz6z7GW5T9HDn/9T/4f/1MN7q/fCGGhWYj+fw==",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_recursive<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) {\n    if low < high {\n        let pivot_index = partition(arr, low, high, sortfn);\n        if pivot_index > 0 {\n            quicksort_recursive(arr, low, pivot_index - 1, sortfn);\n        }\n        quicksort_recursive(arr, pivot_index + 1, high, sortfn);\n    }\n}\n\npub(crate) unconstrained fn quicksort<T, Env, let N: u32>(\n    _arr: [T; N],\n    sortfn: fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = _arr;\n    if arr.len() <= 1 {} else {\n        quicksort_recursive(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "6": {
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n",
      "path": "std/collections/bounded_vec.nr"
    },
    "7": {
      "source": "use crate::cmp::Eq;\nuse crate::collections::bounded_vec::BoundedVec;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// We use load factor alpha_max = 0.75.\n// Upon exceeding it, assert will fail in order to inform the user\n// about performance degradation, so that he can adjust the capacity.\nglobal MAX_LOAD_FACTOR_NUMERATOR: u32 = 3;\nglobal MAX_LOAD_FACTOR_DEN0MINATOR: u32 = 4;\n\n/// `HashMap<Key, Value, MaxLen, Hasher>` is used to efficiently store and look up key-value pairs.\n///\n/// `HashMap` is a bounded type which can store anywhere from zero to `MaxLen` total elements.\n/// Note that due to hash collisions, the actual maximum number of elements stored by any particular\n/// hashmap is likely lower than `MaxLen`. This is true even with cryptographic hash functions since\n/// every hash value will be performed modulo `MaxLen`.\n///\n/// Example:\n///\n/// ```noir\n/// // Create a mapping from Fields to u32s with a maximum length of 12\n/// // using a poseidon2 hasher\n/// use std::hash::poseidon2::Poseidon2Hasher;\n/// let mut map: HashMap<Field, u32, 12, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n///\n/// map.insert(1, 2);\n/// map.insert(3, 4);\n///\n/// let two = map.get(1).unwrap();\n/// ```\npub struct HashMap<K, V, let N: u32, B> {\n    _table: [Slot<K, V>; N],\n\n    /// Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the HashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, let N: u32, B> HashMap<K, V, N, B> {\n    /// Creates a hashmap with an existing `BuildHasher`. This can be used to ensure multiple\n    /// hashmaps are created with the same hasher instance.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    /// let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::with_hasher(my_hasher);\n    /// assert(hashmap.is_empty());\n    /// ```\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = [Slot::default(); N];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    /// Clears the hashmap, removing all key-value pairs from it.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// assert(!map.is_empty());\n    /// map.clear();\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = [Slot::default(); N];\n        self._len = 0;\n    }\n\n    /// Returns `true` if the hashmap contains the given key. Unlike `get`, this will not also return\n    /// the value associated with the key.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// if map.contains_key(7) {\n    ///     let value = map.get(7);\n    ///     assert(value.is_some());\n    /// } else {\n    ///     println(\"No value for key 7!\");\n    /// }\n    /// ```\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        self.get(key).is_some()\n    }\n\n    /// Returns `true` if the length of the hash map is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// assert(map.is_empty());\n    ///\n    /// map.insert(1, 2);\n    /// assert(!map.is_empty());\n    ///\n    /// map.remove(1);\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    /// Returns a vector of each key-value pair present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let entries = map.entries();\n    ///\n    /// // The length of a hashmap may not be compile-time known, so we\n    /// // need to loop over its capacity instead\n    /// for i in 0..map.capacity() {\n    ///     if i < entries.len() {\n    ///         let (key, value) = entries.get(i);\n    ///         println(f\"{key} -> {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:entries\n    pub fn entries(self) -> BoundedVec<(K, V), N> {\n        // docs:end:entries\n        let mut entries = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries.push(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    /// Returns a vector of each key present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let keys = map.keys();\n    ///\n    /// for i in 0..keys.max_len() {\n    ///     if i < keys.len() {\n    ///         let key = keys.get_unchecked(i);\n    ///         let value = map.get(key).unwrap_unchecked();\n    ///         println(f\"{key} -> {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:keys\n    pub fn keys(self) -> BoundedVec<K, N> {\n        // docs:end:keys\n        let mut keys = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys.push(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    /// Returns a vector of each value present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let values = map.values();\n    ///\n    /// for i in 0..values.max_len() {\n    ///     if i < values.len() {\n    ///         let value = values.get_unchecked(i);\n    ///         println(f\"Found value {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:values\n    pub fn values(self) -> BoundedVec<V, N> {\n        // docs:end:values\n        let mut values = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values.push(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    /// Iterates through each key-value pair of the HashMap, setting each key-value pair to the\n    /// result returned from the given function.\n    ///\n    /// Note that since keys can be mutated, the HashMap needs to be rebuilt as it is iterated\n    /// through. If this is not desired, use `iter_values_mut` if only values need to be mutated,\n    /// or `entries` if neither keys nor values need to be mutated.\n    ///\n    /// The iteration order is left unspecified. As a result, if two keys are mutated to become\n    /// equal, which of the two values that will be present for the key in the resulting map is also unspecified.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Add 1 to each key in the map, and double the value associated with that key.\n    /// map.iter_mut(|k, v| (k + 1, v * 2));\n    /// ```\n    // docs:start:iter_mut\n    pub fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = HashMap::with_hasher(self._build_hasher);\n\n        for i in 0..N {\n            if i < self._len {\n                let entry = entries.get_unchecked(i);\n                let (key, value) = f(entry.0, entry.1);\n                new_map.insert(key, value);\n            }\n        }\n\n        self._table = new_map._table;\n    }\n\n    /// Iterates through the HashMap, mutating each key to the result returned from\n    /// the given function.\n    ///\n    /// Note that since keys can be mutated, the HashMap needs to be rebuilt as it is iterated\n    /// through. If only iteration is desired and the keys are not intended to be mutated,\n    /// prefer using `entries` instead.\n    ///\n    /// The iteration order is left unspecified. As a result, if two keys are mutated to become\n    /// equal, which of the two values that will be present for the key in the resulting map is also unspecified.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Double each key, leaving the value associated with that key untouched\n    /// map.iter_keys_mut(|k| k * 2);\n    /// ```\n    // docs:start:iter_keys_mut\n    pub fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = HashMap::with_hasher(self._build_hasher);\n\n        for i in 0..N {\n            if i < self._len {\n                let entry = entries.get_unchecked(i);\n                let (key, value) = (f(entry.0), entry.1);\n                new_map.insert(key, value);\n            }\n        }\n\n        self._table = new_map._table;\n    }\n\n    /// Iterates through the HashMap, applying the given function to each value and mutating the\n    /// value to equal the result. This function is more efficient than `iter_mut` and `iter_keys_mut`\n    /// because the keys are untouched and the underlying hashmap thus does not need to be reordered.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Halve each value\n    /// map.iter_values_mut(|v| v / 2);\n    /// ```\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..N {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    /// Retains only the key-value pairs for which the given function returns true.\n    /// Any key-value pairs for which the function returns false will be removed from the map.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// map.retain(|k, v| (k != 0) & (v != 0));\n    /// ```\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..N {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    /// Returns the current length of this hash map.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // This is equivalent to checking map.is_empty()\n    /// assert(map.len() == 0);\n    ///\n    /// map.insert(1, 2);\n    /// map.insert(3, 4);\n    /// map.insert(5, 6);\n    /// assert(map.len() == 3);\n    ///\n    /// // 3 was already present as a key in the hash map, so the length is unchanged\n    /// map.insert(3, 7);\n    /// assert(map.len() == 3);\n    ///\n    /// map.remove(1);\n    /// assert(map.len() == 2);\n    /// ```\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    /// Returns the maximum capacity of this hashmap. This is always equal to the capacity\n    /// specified in the hashmap's type.\n    ///\n    /// Unlike hashmaps in general purpose programming languages, hashmaps in Noir have a\n    /// static capacity that does not increase as the map grows larger. Thus, this capacity\n    /// is also the maximum possible element count that can be inserted into the hashmap.\n    /// Due to hash collisions (modulo the hashmap length), it is likely the actual maximum\n    /// element count will be lower than the full capacity.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_map: HashMap<Field, Field, 42, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// assert(empty_map.len() == 0);\n    /// assert(empty_map.capacity() == 42);\n    /// ```\n    // docs:start:capacity\n    pub fn capacity(_self: Self) -> u32 {\n        // docs:end:capacity\n        N\n    }\n\n    /// Retrieves a value from the hashmap, returning `Option::none()` if it was not found.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn get_example(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    ///     let x = map.get(12);\n    ///\n    ///     if x.is_some() {\n    ///         assert(x.unwrap() == 42);\n    ///     }\n    /// }\n    /// ```\n    // docs:start:get\n    pub fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let slot = self._table[index];\n\n                // Not marked as deleted and has key-value.\n                if slot.is_valid() {\n                    let (current_key, value) = slot.key_value_unchecked();\n                    if current_key == key {\n                        result = Option::some(value);\n                        should_break = true;\n                    }\n                }\n            }\n        }\n\n        result\n    }\n\n    /// Inserts a new key-value pair into the map. If the key was already in the map, its\n    /// previous value will be overridden with the newly provided one.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// map.insert(12, 42);\n    /// assert(map.len() == 1);\n    /// ```\n    // docs:start:insert\n    pub fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.assert_load_factor();\n\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let mut slot = self._table[index];\n                let mut insert = false;\n\n                // Either marked as deleted or has unset key-value.\n                if slot.is_available() {\n                    insert = true;\n                    self._len += 1;\n                } else {\n                    let (current_key, _) = slot.key_value_unchecked();\n                    if current_key == key {\n                        insert = true;\n                    }\n                }\n\n                if insert {\n                    slot.set(key, value);\n                    self._table[index] = slot;\n                    should_break = true;\n                }\n            }\n        }\n    }\n\n    /// Removes the given key-value pair from the map. If the key was not already present\n    /// in the map, this does nothing.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// map.insert(12, 42);\n    /// assert(!map.is_empty());\n    ///\n    /// map.remove(12);\n    /// assert(map.is_empty());\n    ///\n    /// // If a key was not present in the map, remove does nothing\n    /// map.remove(12);\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:remove\n    pub fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let mut slot = self._table[index];\n\n                // Not marked as deleted and has key-value.\n                if slot.is_valid() {\n                    let (current_key, _) = slot.key_value_unchecked();\n                    if current_key == key {\n                        slot.mark_deleted();\n                        self._table[index] = slot;\n                        self._len -= 1;\n                        should_break = true;\n                    }\n                }\n            }\n        }\n    }\n\n    // Apply HashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(_self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % N\n    }\n\n    // Amount of elements in the table in relation to available slots exceeds alpha_max.\n    // To avoid a comparatively more expensive division operation\n    // we conduct cross-multiplication instead.\n    // n / m >= MAX_LOAD_FACTOR_NUMERATOR / MAX_LOAD_FACTOR_DEN0MINATOR\n    // n * MAX_LOAD_FACTOR_DEN0MINATOR >= m * MAX_LOAD_FACTOR_NUMERATOR\n    fn assert_load_factor(self) {\n        let lhs = self._len * MAX_LOAD_FACTOR_DEN0MINATOR;\n        let rhs = self._table.len() * MAX_LOAD_FACTOR_NUMERATOR;\n        let exceeded = lhs >= rhs;\n        assert(!exceeded, \"Load factor is exceeded, consider increasing the capacity.\");\n    }\n}\n\n// Equality class on HashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, let N: u32, B, H> Eq for HashMap<K, V, N, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    /// Checks if two HashMaps are equal.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map1: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// let mut map2: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    ///\n    /// map1.insert(1, 2);\n    /// map1.insert(3, 4);\n    ///\n    /// map2.insert(3, 4);\n    /// map2.insert(1, 2);\n    ///\n    /// assert(map1 == map2);\n    /// ```\n    fn eq(self, other: HashMap<K, V, N, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    let other_value = other.get(key);\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, let N: u32, B, H> Default for HashMap<K, V, N, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    /// Constructs an empty HashMap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// assert(hashmap.is_empty());\n    /// ```\n    fn default() -> Self {\n        // docs:end:default\n        let _build_hasher = B::default();\n        let map: HashMap<K, V, N, B> = HashMap::with_hasher(_build_hasher);\n        map\n    }\n}\n",
      "path": "std/collections/map.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "50": {
      "source": "mod utils;\n\nuse std::collections::map::HashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\nuse utils::cut;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_CAP: u32 = 8;\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> HashMap<K, V, HASHMAP_CAP, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> HashMap<K, V, HASHMAP_CAP, BuildHasherDefault<Poseidon2Hasher>> HashMap::default();\n\nfn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nfn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"HashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"HashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nfn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"HashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nfn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"HashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nfn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    for entry in input {\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"HashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nfn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"HashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nfn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"HashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"HashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nfn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = cut(hashmap.keys()).sort_via(K_CMP);\n    let values: [V; 3] = cut(hashmap.values()).sort_via(V_CMP);\n    let entries: [(K, V); 3] = cut(hashmap.entries()).sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nfn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = cut(hashmap.keys()).sort_via(K_CMP);\n    let values: [V; 3] = cut(hashmap.values()).sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = cut(hashmap.entries()).sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib hashmap documentation\nfn doc_tests() {\n    // docs:start:default_example\n    let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> =\n        HashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: HashMap<Field, Field, 42, BuildHasherDefault<Poseidon2Hasher>> =\n        HashMap::default();\n    assert(empty_map.len() == 0);\n    assert(empty_map.capacity() == 42);\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    let mut map2: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    let x = map.get(12);\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries.get(i);\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for i in 0..keys.max_len() {\n        if i < keys.len() {\n            let key = keys.get_unchecked(i);\n            let value = map.get(key).unwrap_unchecked();\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for i in 0..values.max_len() {\n        if i < values.len() {\n            let value = values.get_unchecked(i);\n            println(f\"Found value {value}\");\n        }\n    }\n    // docs:end:values_example\n}\n\nfn iter_examples(mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    },
    "51": {
      "source": "// Compile-time: cuts the M first elements from the BoundedVec<T, N>.\npub(crate) fn cut<T, let N: u32, let M: u32>(input: BoundedVec<T, N>) -> [T; M] {\n    assert(M < N, \"M should be less than N.\");\n\n    let mut new = BoundedVec::new();\n    for i in 0..M {\n        new.push(input.get(i));\n    }\n    new.storage()\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
