---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "955212737754845985": {
        "error_kind": "string",
        "string": "HashMap should have retained 2 elements."
      },
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "5727012404371710682": {
        "error_kind": "string",
        "string": "push out of bounds"
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "6895136539169241630": {
        "error_kind": "string",
        "string": "HashMaps should not be equal."
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "9417307514377997680": {
        "error_kind": "string",
        "string": "HashMap after one insert should have a length of 1 element."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12389747999246339213": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14479745468926698352": {
        "error_kind": "string",
        "string": "HashMap after one insert and corresponding removal should be empty."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16567169223151679177": {
        "error_kind": "string",
        "string": "HashMaps should be equal."
      },
      "16850003084350092401": {
        "error_kind": "string",
        "string": "Load factor is exceeded, consider increasing the capacity."
      },
      "16954218183513903507": {
        "error_kind": "string",
        "string": "Attempted to read past end of BoundedVec"
      },
      "17677620431177272765": {
        "error_kind": "string",
        "string": "HashMap length is invalid."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/+y9CZhkyVUeejOrqrurpqs7e5np6Vl6ep/ppbr2Xma01EhVI42QkOBZbJZBs3SDAAMPZCGxyCkDYjEIDGZ9EjIgNj8WySwCCUkMxhYPnsHoWWaTAOsDIVuWEAYBQth6vtN5Kv/887/nxs2KyMzqvvf7uvPWjbjnnDgRceKcE+fEbWTXr1v+979G536y89uA391Z72Vla53fha1dixFhLaSisbENaGxuAxontgGNk9uAxqltQOOObUDjzm1A465tQOP0NqBxZhvQeEsCGp+8cBHPic4Xi1wY58IuFyb5ZM0nQz7Y8s7MmXVLVnxZw/944/rvdOfvJpRHFPaL04Q3JvzLC6tXp0X7ItK/PA18TwD/sWmAmQD+ws4OnE9td+FzW2wcNLJk/bSUuJ2PzVLbMmiL4Z5Mg/vxBuHLqJ0Z4Z/Jko6pxQbhM3qYP3Y/a3XaXXoaVDbZ7m+HlU21e9uRX7k8OgT1eGw1od5xuF/q3Ccej1cTz+uFA06b7dnOdrZ5Gd8m4Jnx1fi8C+tT2TSUTbZ78cx0/p4EPAjL6Jii+sc6f+/t/O6Ad+z9lsC/g/D30C2eMV+mRf1pUT9f++7o3Odrnq0Fz2x34UXs04sGfz0N/BWDv5EG/rLBfygN/AWD/6wO/CwB7GcD7RHhb+opD6fhzSb856SBv2TwP6kdm/fLlwz2c6PDvvSowX5efNiPG+xPjg778uZcfX502I9cMdgviA/7EYP9KfFhP5rL4HwNP79+HZ6nh6CuZHNub9avI6LOlv+bKoH1HIKF79u70/R3ZFmyYPrODqCLddGd8DyeHFhaDNVFDf8M0ZpKF91J9DB/UBfNy3YJWluiDPsQyxDPLoGnJcps3RonWDHbWPOr5lfNr5pfw4RV86vmV82v8eSX6VqomzUKfg0PP2M8qNfuIDy7IuJBWObPMJ1/WtBgevcMlMX0fVi/2N6L+doYJ+63YH28z68pevaNnd8nfaRkX+EeyIR4xrzbIeiZprJscN4s8oNZQVOD8CIfIvbLasj4QvwzWf8YSmEP3UL0FPWZ8W63oLVFZfnFcmK3wLNb4NkusJRcQV4OKleYzzFgzUaEtScirL0Cls3DFjyP6dsOnYeGf4ZoTTUPW0QP84d5t0/Q2hJl2DYsQzz7BJ6WKOO5EwOWlaHc3Uvv4ZybpjIc2w8TzD3wHusaTXjP1u18Pv8beAfxTWV673Kj3S3H+nvWuzB/rvNM6QW3UBmu0bupDMfgLJXhfDEYNpd4PKx1/l7Y4mU82t+Bh7qGGp9Nqo/3yEN79vbOr9I11HzBZzz2ZgQ9s+I9lkP70/AuWB8w/DNZUrm4yH2JfJ0RfDX+HEhDz4rRc1DQo/o5H297sv4+Q/oMFu4DrLev/yo5xLIG5RDL3FkoY/mFaybuGzJvVft4TwJlxwy9p2i3flE2gKf7cd2JrDtfkOZBdQA1L3lfJJEufrlsDfgdwIv9rtYApHOK6n//M7swf7/zTPXjTipDnuyiMrUWGr9m0/BrU87bOEY5jziNtmbWv/7iHJiiZ+/r/Co5X1U/nxb0MCxlE+eXzTXuxz8D+lY79Km+4v5A/MPqD8Q5Azyq0h8fgvZyfyh5pdYH1R9Wb1hyJKbNomS56bBKP+OxkGjd3hwLpm/hWECce6E9WB/v82uKnn2886vGAtonns2ixoLVC7EFE+mvwTqY4R+WLbgvkK/Gu/2C1haV5Rfbb0rX2y/wbBdY+T37ZJCXg8595nMMWAciwjoYEdatApbNw9vg+Sh8MoZ/hmhNNQ9vI3qYP8y7Q4LWlihjn8whgeeQwNMSZTx3YsBSfqRb6T2cc2zv4Nhmn8xBeC/UJ3Oi0X0HdZxQn4zVb4M+froDU+nV1m4rQx13P5XhWnCAynD93YyPzpKO3QUeu6gPIE72yeDcxnE/Rc/mO3yL4ZOZFfSE+GQSyaFgfYDlUGqfjJJDs4Kvxp9DaejZ9MncLugp88lgnyF9BsvzyaAcsnmq5BD7ZND3wzIK10z2ycyWtI99Mig7Zum9vYJ26xdlQyudWsE3GDH3eNS8DJXRzyIZbe0I9ZlY/aeDjH4OyWhlSyo7fA/B3oy/Btl1uSO7pgXs/N9a5++FLV0rV5QvIB78i1eV7yce/EubeYd70tC/Op31z5OI9C8p+zsi/BVlo0bkz4rah4gHf2lB+fEj8udRg38wDfyLSp+KyP9FpXNEhP+YWrMj8mdzft2eBv7jBv9wGv5szt870sC/ZPDvTAP/msG/Kw38zfF/dxr4lw3+kTTwN8fPPWngb8qfo0ngX9pc348lgb901fSu41n3Mt3NcJ+A5/H0/eXgHB7DP0O0xqWnaw+dIHqYP+yXOSlobYky1gFPCjwnBR4Fa3dEWLMRYe2JCGtvRFitMW3jvoiw9keEdSAirIMRYd0aEdZtEWEdiggr5vi6PSKsmOPrcERYMXkfU07E5NcdEWHdGRHWuPIrpvy6GXg/rnLiroiwYvI+pm4Sk18xx8TdEWHFXNNi8ium7htTNzkSEda48v6eMW3j0YiwjkG9/G+M98//noSyGSqzuu9rXP9NbI+vsD1rOBD3qUS4G4TPeI3PEP+soMfonhFlk1ug9fHVlcWVa1dWH3382vLVxy9daxB8o5Wf4X5U/u+0qH9c1Dde35sl4fWCOgfvNPA1vyah7BSVTUGZ0Yjn4E0TzNj0h/Af8bdEfTyfqkpftjI9tmLBmhkQ1v6sX/aYnFBnBHFM+LRoz7ByiY3OyUznEXAu8QnRxvyaomf/tSM4YuQSTwp6ZqnMypF3ifJrg2NJDP+MaEcK36ni66Tgq/HuhKC1lfX3LcehKR/tCYFnu8DK7zm2VOWRh/Q74mE+x4B1MiKsUxFhnRaw0q6l4bGlhn8mS7k2dufhvUQP84d5d5+gtSXKsG1YhnjuE3haooznTgxYKheA9QCcc5NUhmObY0txnQ6NW9rX7L6D+EJjS63+sWd2YR7svKDWdWu3iltifQDH4Ekqw/nC+b48HtY6fy9s8TIenenAQ31Ajc8m1cd75KE9u7vDN6UPqPmCz3jszQh6ZsV7LIfOpOFdsD5g+GeypHJxkfsS+erl+55NQ89mbOk5QY/qZ4wtxT5D+gwW6jfr7eu/Sg6xrEE5xDIX9XjPjuHY0umS9nFsqZIdSgdnvXFCtE/l7in4BiOmnqP4HSqjV0lGox+GZXR+z7GlVv+tz+jCvOzIaLa98CwpzsfF86zYLktkWywwH1AOTwtam1n/eMGxwHxac+Rw1fO+JgU9DAvpxzPAbAxMUf0NoO+BDn2pzxCzsRrS76O2x7nfQ+3xT07c7975a2l9p+Hrr+Gfyfr7OcX6eyKQr1VimfKLdfdBfeTjCiu/Z3v8ZrWhB4Xl6cGJbIhge9zwD0sPVrbtvQ7vzghaW6KM7XGlb58ReFqijOdODFhVdd1dVIZjm+1xtF9Ddb2Xka5n+ELtcav/OtD1XkG6Hsp0trlRf2KbG9fYU1SG45PPftiu9vg/i2iPTwt6ant883LtcbXvcaPa4yiHWNagHGIZpfboWA7l11btcZQdnj3OemOoPa7gG4xxsce/L5I9/gjI6NcF2OMN+hvrTIp2TFH9HwB59rR1DTODNiDfbJ0JoW9XCax1gqX8CyG2Uhr/Qvi3W3jvMrWtpOaqZyupPWrlH+az1quecYVlrKONA6yYbaz5VfOr5lfNr2HCqvlV86vm13jyK7VNwvrwTEQ8CMvsG9PJTwgaTO9GOzSFP8dsWfTnKL9/k+rjfX5N0bO/dvw5ah/ihMM75UOr93c2r4H3d04JWpWvlefyoDHN4worv+dvJqUZO4ul54Hvmuhtk83FIp+0ffd7iup/0YNdmLd0YHp+parnXo2bnDLaqsqpAx3exDh/epegR+3TN6LxZ+WyysWJCP9xlb8RD/6lBRWTGw/+8qLaF4kHf+kx3qMzHNj3Z+F5RN9Z8Dpk+GeI1lTr0Fmih/nD69A5QWtLlPEcUvsF5wQeBevWiLBmI8K6OyKsUxFhxeTX6Yiw9keEdVtEWHsiwtodEdYdEWG1IsKKOe5jjokjEWEdiggrpsyJ2Y8xeX84IqyY8zFmG++NCOu+MW1jTJlzZ0RY4zruD0SEdTOsabdHhHWMYJnOqeLe84u/42T1v7qjiKc9K2HpkunQqHM3sl7c5xLhbhA+4zc+Q/yevj8jyrZyTsMjj15bXH5k6crqtUeurTx2+fGqY8Pqnxf1lS1jvJ7LkvB6RZ3TcB74ml+TUHaOyqagzGhU5zScT0R/CP8Rf0vUfxjasNV5zudvhsKysxXQpudzSIYVM5Vqf8L8qub3Q9nFfr9EvoRNv5/xGeUv4jwF7eF+QZk4Rc++0fH7VfUj7xL0ePH4ieMpB/YLpVmjfL+Q4msVv1B+8T7AoHJhXGHl95x/otb7qnOf+RwD1vmIsOYiwrogYNk8nIfnEcd9cP6J4Z8hWlPNw3mih/nDvFsQtLZEGZ99tCDwLAg8LVHGcycGLCtDuXuB3lP+UyvDsc35J6j3hcY2v6niXt9Gu1uO9V/wYBfmz9JeH+6RWbvVun6OynCNPU9lOD4NRuK5tMDjAPUBxGm0NbP+8YljYoqevc3RB3BuePNF7StbvRA5tJCGd8H6gOEflhxSc1rpA8afxTT0bNomS4Ie1c+Yf4J9hvQZLC//BOWQzVMlh1hGoY12hspwzeT8k1Ml7eP8E5Qdp+i9M4J26xfuS6yPMBR8gxEzn1XNy1AZ/W6S0daO0PwTq7/3wS7M3yUZ7Z3Zo2IK+Dyg94Dssm+NZVSH81MQNsP7K/Jdpcn96J4xquzYtHEl4WeMGn6VE290z4iyFGeMhuave/P9uKif1pbXZ4yinZxfk1B2ksqmoMxoVL6rROfRLoTwH/G3RH0+Y3QrZxFwDthWYO0aEJb5wTAmg3ORUa7F1meQdqQV567h93LfGkS7gpVfFmfnxdA1sn55pui6hehSMXchsvE4PI/oqw3OyTP8M1n/WEihLx4XfFXxeEpW27tqDnAM/Y14fkmsNtb8qvlV86vm1zBh1fyq+VXzazz55X0zlH8NDz9jPKjXsj58MiIehGU+H+Ub51yO7brn/dzJ678x9rxnBD0hNkuiPeZgH7fhH5bNovjq2SwqroT9xfnFc1ntrZ8VeLYLrPye97xj+IJv9v1zm4eJ9naC/aqGf4ZoTTUP1R7enMM7tafYEmXsi1N76/MCT0uU8dyJAUvtfczRezjnZqhMxd+pfajQ/ZSXTnbfQXyhe95W/y/WujC/vAMz5OxEdV6cleEY5P1wnC8GY7vvebcdfaDqnvcZQU+95715uXveXjzxjbbn7Z2dGBqXw/IL18yt7nkr2aF0cNYbJ0T7vO9dcN1x2vP+HpLRg+55v2qtC/P/IhmN+ydm76k+OEllN2Is8g9FtMtULHJD0KdskfV2b/1zgFfh5vqKPzhvZwra/6+h/Q9S+5V+oM4tYf3gJwHmegdmyDkWiexTdwwpmVh1DP2MM4ZinGMRct5OIls6eC3neIzU5+0ovnrn7Xh69s1u2yufUUi/I57atu/VbyKP+9q2F3jGwbZHuevZ9nzGeWzb/g9Ibxz0ewqPrXVh/qGjN1q7lW7Itj3qaWzb4/jkePZEc2mBxwHqA4jTaGtm/eMTx8QUPfszRx/AueHNF893FCKHEvlFgvUBzqtJLYfUnPbi2RP5PjZt+0VBj+pntO2xz5Sd79n2Sq9WcohlFNoIHM/u2fYzJe3zvqcwQ+8pu9L6xbPdEYaCbzBS5uxWkdGfIBlt7Qi17a3+Xz69C7PZQb5V2x73fcftfEGjrZn1jxfvfMGZDm+UHMY98wnxzLPLkFf4N9KPY43PqdjsF6DvWR36hj1Wj0fEg7BMT7qRfUd3OuMrhu+ozmPfvOo89i3Cyu/rPPatwarz2NPnsbPdX+exX/+7SKd85lT3HdSbQu1+q/9u0CkfIp0SdbE6j7178Z7+8x19oM5jH96efp3H3i+H6jz2bpn6NZj8LMae/ueSjB50T/9fgoz+fJLRuG6yb1bZrpyT/kUguyyPfTrTa/Ja5++FLV0rq2nP5790WeVqxoN/cVn5RyLSfynt9wVWr9Xn529eyc/P5zm0FTtuJiKsmOfB74kI63hEWK2IsGK2cV9EWON6BnLMs4Zj8v5kRFinIsI6GBFWzO9GxDzLOuZZ/DHHRMyzrO+LCGtcz/WP2Y8xZXR9fv6NsXbcDLxPcX6+/W06J8f45PfTVGZ1f7djB6aNK1267OUUq++excTdIHzGa3yG+GcFPUb3jCib3AKtS1f/t+G39Ni1pWsL11auXbzUIPhGKz9D/0H+L9SOSfydAnl2/lnga35NQtlpKpuCMqNRnT+WyE5dCeE/4m+J+nz+WGhftgQePu9qK7B2DQjLzh9DHZp9TmzvZlm3rxLFhm/6941H6N9HnDuhPcxTPItsip79oePf35n1826n4F0r6+UJ1psV7zHv0pwHGX7umOGfyfr7OYU/ZjqQrxw3g+96cTANKkM8Xp4GlvE+4zjAitnGml81v2p+1fwaJqyaXzW/an6NJ79Sf2uL9eGZiHgQlu3Rq1gFoyGtL6Jrs5htjjaL8jc0qT7e5xfHDCx2gj6VzVL1DLqdgp4Qey91/oDinerLqry74vBuWPZeov3u4P13wz8se+9MIF9VXjfHMZ2F91gOKv/YWYFnu8DK7zm+uwnvYTzSc3b04izLFbXz19mP/L1P68J8Xgemkgch39W4kWXwCxPLYJZJyu+VX9yPVv+zgL7n0Hkdo/TjnXTao+T6ScEbbK89e/EYyPVEa2KwXOf9i9Ry/WQgXzkmDd9tZf1zjeWnWj/Uvsd2gYVyPW284cpVpXPEg3/xipd3lHofKnReGP6ZrH99TTEv1H6vWu85NwrfVTHdPEbUt7TPCzwK1p0RYbUiwtofEdZdEWHF5NehiLB2R4S1LyKsmP14JiKsmPyajQhrT0RYeyPCijm3Y7ZxXMfqPRFhxeTX0YiwYvLrQERYMfkVU07EnEMx5/bRiLBORYR1M8yh2yPCOta5L/MRvT2Sj+jfP7UL84kdvbg9+ziNbyE8zsXwD8s+Vt9T9OxjFcelYrx4X2rQeLH8Ypt2HGDFbGPNr5pfNb9qfg0TVs2vml81v8aTX15sihdPUuu3W9dvpwWtqj94PKp48WmBpyXKeAyNA6yYbaz5VfOr5lfNr2HCqvlV86vm13jyy/uuEP8aHn7GeFR8lqcPD4oHYbHePS3wmN6N8eyj0LsN/0zW3y8p9G4V76/GifIr27u13Tw+sGK2MSasml81v2p+1fwqgxWzjTFh1fyq+TUsfqX+xss04ZmOiAdhmd5tuSLYVoNheneiOOrNXBGLhcZcEcR5GtqD9fE+v6bo2Rs6hobKFak6FhqCnlnxHvMuTUx8eK4Ix8SfTkOPGxOv+FolJj6/eC4PGkc1rrDy+x2de5uT6qzfafFeijlp58hPinYgbU2qj/f5NUXPftGZk1XPzzst6CmLjXvbzl6cZ4HOCfEux8ZZ/T94oAvzlzsw92b9ssJ8KnsJdn6/k8puRBn8a4llsOId56UirdNUdl7ANJ4n+u7lJs/t2wvIc8R5HviA9fE+v6bo2bscnleVT6cFPTG/9aTkoOla6nszPC+26/dm3uv0UdXvzTQEPYp3PL4XEvNuUfBuweEdfj9lUfDOnv1pRN6dFvR48xPlt7fm8DgdNz2wmYYeVw9E/rAeuChobWX9Y4H1LfWt3kWBZ7vAyu9ND2S5/jedcZ+XH9jV+z7K4me3r/+q9Y/H5ajXONYjQ9e4/xVRj1TzxPs24rSgdRRz2vDPZEllzKInWxVfjXdqnWxRWX7x3FHfJ5wXeLYLLJzTKo8e7ZO9u3px2lxB+wT18lugHOv/3f1dmPt3de9Nbii9+TzBsrLbOu/kP89bL36f9W5lPyReDzfljrUF5Q7iNNqaVJ9l6RQ9uxt4wXKn6vk/pwU9nk8pRC4gnhTfio2h89ffd01CT/Lvu2LbsAzxLAg8LVHGsjUGLE+ntzKUSZ5fr8r3XbH/UZZfJllu+FCW47sb7W451n8PyPIHSH6jHs8+ESXvlF14nspwvhiMcbEZjbaqNuO6I7erruvnBD2z4j2WQ4m+XxqsLxr+mSypXFzkvkS+Kn3R+LOUhp7N70AsC3pUP+P3XdU3XRHWJLy/3r7+q+QQjyGUQyxzURdh+eV93/V0Sfv4+65Kdigdk30FE1mx/oIwFHyDEVPPCdmvLZLRLyIZrfYDkB7Wt63+y0BGfw7JaHy/yn4Atpl1a3VGY+qYUPbLYvwjy7o0sZrddcL6GtcJtY/ezPrHBo45tnW+0FknqsbtNgQ9infWD9OZnitrWVzenRW8O+3wDmXBWcE7e/bSiLybEPQwrCK/LMcue37ZRLlzwWuy4R+WX1adken5Zc8KWnkNyy/W52/kM3r520KvBv/K68gvi7KY/bI3ovz8lhHIT9Yjt6v8/M6IvGsKelQuB+pC37tL40RdCOUl60JW/zuvdGG+VswNpd/w98zwPORM1J8i3Fb/B4CHL1jvbbe9bzCyLPU6EJ5bwuvARBJ6/HUA+cPrgMoN8nTERtYv/ybEsyJ9M79Ydo8DrJhtrPlV86vmV82vYcKq+VXzq+bXePIrZa51A+qn9BPml9kUIb6u7Wrn/o/Evi7PZqnaRzFzicY1PoHjSvJrrfO7sLVr1Yt9SBxHFxxjYPhniNbI9Gzaj3NED/OnKD4D322JMo5VrBrPi2Uso2PAUnP2PL2nfFO8R5VfHGOAfqLQ/as90913EF/VGIMvB5/Nvg5MtUdl7bYyJUu93Aorw/liMBLHVW6uCbYnimuCGp9Nqo/3yEN7dkeHAWpNUPMFn/E4mRH0eHFTiWOdgvczONYpkVx0Y53UN1ETx69sxhiomAfVzxhjgH2G9GEsjF3r7eu/Sg7xGEI5xDJXxX2q/ROOMZgoaZ8XYzBB7yk5afUmsmLdCGEo+HYfU4dS/DYZPS3oW+v8LmzterRM/i+T/LexHxq/YPV3gvy/6Mh/L0aBYxtQho3bHo3RVnWP5mmOjFfnNXnfZ24KehqCPp4L+bXe7q1/HvAq3Fxf8Yd1RtX+DWj/g9R+fEfZWicIptV/NsBcp/hyJd+GZTsqHjHOLKs+hj7ZGUNKvqp9GTWG2L734h4S7S8F6wn2bFhxD4qvoXEPE8Tzm/3bxDF9EjdybgLbM/m11vld2Nq1FBJvnFLXzbLyOW74hxVvrHIIVHyvyjm1d1U+JucFj1vOqdJNOaZ4mHkPXx7JJ/FfL3dhfsWAPgnOe1B2j8p7YJ/Eds17+BpH16ia9zAj6KnzHjYvN+/B80ncaHkPnk8iNO/hNJV5eQ8TJe2r4pNQNqvVUz4JZfONk08C6Vvr/C5s7Xq8TP6/luS/9WWoT8LqvwLk/+sj+SRUTs6wzlhSOcneGUuhOck/6sj4qmcsNQU9DUFfiE9iDvAq3Fxf8Yf9x6r9P1XRJ4HtOkEwrf6bBvRJpPZrKR4xziyrPobeXPskxt4nofxzSodnG+NGPisxhU9iXM84mI8Ia0HASqyvB/sNWF9PZHu5+vqCw7slQWtLlHF+z5LAsyTwtEQZz50YsJT+yH4QnHMMU+37qbNvQv0GfxTJb/APQW98XwW/gecbQD1tjspwfPI5N4nm0gKPA9QHlF+rmfWPTxwTU/Tsg44+UPWsjtOCnhA5lMguDtYHDP+w5JCa00pXN/4sp6Fn02+wIuhR/Yx+A+UrQFiD+g1QDrGMQhvhLJXhmhniN8D2VfEbKLvS6im/gbLLxsFvUCajJ2a672A7qtr2H7zUhbljJgz3LsLdrIjb6v8Y4L6lA3OrfgWMs+Z5irHeKdYAFeOs8vWaWf9Y9WKcD3R4o9YAlT+ovgmrbELkFf6N9OM4f067lz6rfzvQ938E5HrGnCch/T7qGBfu99D4hGOJ+z3kG8uJfHHBa7/hn8n6+znF2n82kK/KF8Br3s3uC7gZzjusfQHbyxfAMQTj6gtAuev5AvgMgNi+gIdJ1zN8ob4Aq/9NoOs9l3Q9lOkcJ4D6E/sCcI31fAEGY7v7Al7o6ANVfQG7BD21L2Dzcn0BKp/0RvUFeOdOhfoCOIbA8wXsKmkf+wJQduyi95QObv2i7DPlC1DwDcawzvkrk9H/OJIv4JNBRn+JY49jO/BvPCOoKdrBe7svBXn2aWQ3Dn9/MvyMoHHfn1S55ioPnXP6q9qUWMa60DjAitnGml81v2p+1fwaJqyaXzW/an6NJ79S728U6XQx8CAssyOUv2Xc9lF2QXuwPt7nF++j/DvHb1L1vKimoCfEZkm09xjsNzH8w7JZFF89m+WsoJV9EPnFc/lmyPOM4V+42fdk6lzM7ji8mXIxUe6OMhfzQxViZvJro90tx/oL4KP7iOOj8/JteI8FxyDvsdyIMZUfi7iPUsdUulcdU5n1yyFv7ff2ell+ebmYVfdRlOxQOjjrjaH7KAq+wRjWPgrbMfm11vld2Nq1XCb/99/SpQf7vOr3rX75YhfmrZ1KITH1Kg5RxdTzPEx0fuWmjLcxXHT+kdHWpPo8/vm7u3d3eKNkfFXdvCnoaQj6lP243u6tPw94FW6ur/iD6/WugvafhPY/WGDzFn3L+ATBtPr3AkzOxfT8BqnzeRWPlD1ZdQzNOWOo9huMh99gTtCq1ke2MaqeAzrusPL7lH6D7RQzOSisRQFrGGeDlNGK+GeI1lTzUOnriw7vlgWtLVHG50qrM1GWBZ6WKOO5EwOW0h85nhTnHMNU551YGdpYoX6DF5LeOKjf4AdBb/wMR29kv4GXb6lsEyvD8WkwEs+lBR4HqA+o+OBm1j8+cUxM0bNHHH2gqs/qrKAnRA4lsouD9QHDPyw5pOa00tWNPytp6Nn0G6wKelQ/o99A+QoQ1qB+A5RDLKOUT4/lUH6F+A2wfVX8BsqutH5RfgNll42T3wDpW+v8LmztulQm/7+C5L/1ZajfwOovgfz/6kh+A3UmQeLvcLjfDkCcRlsz658P3rcDvs6R8VVzo5qCnoagL8RvsAB4FW6ur/ijciK4/d9c0W+A7TpBMK3+tw7oN0jte1I8Oi94VHUMfWftNxh7v4HyoSkdnm2Mqmd1jjus/D6l32A72fqDwloSsIaxj1VGK+KfIVpTzUOlry85vFsRtLZEGZ/hpPbvVgSelijjuRMDltIf2Q+Cc45hqr05FXcR6jd4WyS/wUHQG3+5gt/A8w2gnrZAZTg+DUbiubTA4wD1AeXXamb94xPHxBQ9+38cfaBqzvB5QU+IHEpkFwfrA4Z/WHJIzWmlqxt/VtPQs+k3uCjoUf2MfgPlK0BYg/oNUA6xjEIbYY7KcM0M8Rtg+6r4DZRdaf2i/AbKLhsHv0GZjP4vkWz7N6x2Yf5JbdtvXmyX/ffEtr0XF5v4u4BXQuUwfxcw9fdJ5wP5yjo+vqt0JNbhqsbt1bBuXFgxbU/Pnx4zDr4lYNlaoWJxWSZv11jcvbuv/8aIxW0KesrW4AO7e3HOAZ0ha7DVfyWswbd1YKo12LOFOPbaW4MTrSMLzPuiuDNeg3FsYh9N0bMjTn/HWIOV77gRjT8ri6M7q2t1IXSNv1HO6uI+HPR8rfz+SERYd0aEdSgirN0RYbUiwtofEVZM3t8VEVbMNh6MCOvWiLBuiwjrTERY+yLCitmPeyLCisn7mHTFlKsx6RpXWTgbEVbMsRqTrrsjwhrXtTbmfBxX+RWzH2OuQzHXx5gyJybvD0eEFbON4yqjY/L+QERYMeXquOoTMfXoUxFhjavOFHPc3x4RVsw5FFNnimkrjKu+GlNO3BcR1riuaTF1uXH1ddwREVZMPXpc+RVz3b4nIqyYcuJoRFgxZU69bleDFXPdPta5V7l3vG+E76XYN0qVe/frzr5R1dy7pqCHYRXFnnDehNX/kw59aWMVV5c5btZwIO7VRLgbhM/4jc8Q/6ygh+MAsWxyC7SuPnZ19eLVK9ceXV66+PjC6uMNgm+08jMcC/k/Fae3IOobry9lKXi9cs1k80S7C/8i8DW/JqFslcqmoMxozMfuIaL/YiL6Q/iP+Fui/nOgDVX6siXwYKzbVmHNDQhrf9Y7B1BOeDGJ4/oNqEQ5Ru6+ssqVUmcQ8L5y6nMDYsKKmaPSyvrHDueRpYiDzS+Ls2HeTAEsnOMYe4P1/xbW/s+k74Q0BL48BufvKsT15NdGuxe31f9siOv5n05cj/E3JK9x1PGzg+Y1TnYWl9R5janisq1MnXs5bvF089AerI/3+dUXT+f0UdUcQRW3Ni3K4vFneUnlstil5DyPHdSLTR6wHppfz6Ey1Pue3+7C52uC/kZe5LS8COQT17MrJH+K11Ysw3HLcftLAuZ2z5864Yzpqnazys8bYf5UcNz+OORPKb56Np7S6VlfGlQPr2HdeLA830bIPFF4cN6GzPdB8SAsW3dMJis7NK393ZXJZvujTEacq9AerI/3+TVFzx5yZHLVsbBL0FOm3z9nthfnoHH7l0G/f14HplqDbRypuP0lKlO21nb3v77Q6e+q/ld1tt7ozj5bXQpdg8fh7DPvDMbQsxQ4rn7Q8w/y+yMRYd0ZEdahiLB2R4TVighrf0RYMXl/15i28WBEWLdGhHVbRFhnIsLaFxFWzH7cExFWTN7HpCumXI1J17jKwtmIsGKO1Zh03R0R1riutTHn47jKr5j9GHMdOhgRVkyZE5P3h8e0jeMqo2Py/kBEWDHl6rjqEzH16FNj2sZxHfe3R4QVcw7F1Jli2grjqq/GlBP3RYQ1rmtaTF1uXH0dd0SEFVOPHld+xVy3D0aENa4+mJhzaFxlYa1PVIMVU5841rm3/SYVD5M4bmFzvwm/YTIhcC5De7A+3ufXFMPrdKTab6oaY7lL0MOwimLl5ok+q3+kQ1/imPtVFZ/UyHpxX0qEu0H4jN/4DPHPCnqM7hlRtpV4/8uPrFxdWVx4/Noj1x5dWX18tUHwjVZ+hjFX+b/Lor7aYzNeX8mS8HpRxftfBr7m1ySUXaKyKSgzGlW8/+VE9IfwH/G3RH2O9w/ty5bAgzFyW4U1NyAsi/dX8RbeGZXj+u2ARGcOuvvdKj5VxZzxfvd2jHvC9jcKfg0PP2M8OHaMhynPRc0vi89h3oTG+1v9JVj7Q+P9V/b04h403v92iAe61IGp4oGMvyoeiHWw1Gd1qlhyxGm0Nak+3iMv7NnTHB2s6ndqdwl6ZsV7Wx2Pqh9u5Njoh50+ihEbnfZ7UssrKubTLiXneeygXmzygPXQ/OJ4f9T7XtDuwudrgv5GXlSN91dzQMmPCSrDcW/x/rP0N+JMG2u4uBiqPxj+GaI1lf6gxjvyh/WHFUEr29v5xWv+oLZ7DauGVcOqYVWBlTJXIXQ9GRQPwrK12dY0lL229iX+FtOmLobfT5oQOFegPVgf7/Nrip59g6OLVR0Lc4KeMhvom8kGQt8l20D5L+dEWP0/XenC/Faygby8By8vEdd+7u9R50QYbU2qj/fIJ3v23U5/49j3dBHV31V0vFTnzITMecQ/LB1vOZCvdU5EP6w6J2J0vK9zIqrBqnMiqsGqcyJGR1edEzE6uuqciBtDftU5EaPjfZ0TMTre1zkR1WDVORGjG/d1TkQ1WHVOxI2xptU5EdVg1TkRN4a8j8n7vRFhxZTRdX7FjTFWU+ZX4FrCe1e4xqfYuzJacO8KcR6G9mB9vM+vKXr27M6EVHtXh7N+3h12eDcn6GFYRbGJE0Sf1X+0Q9+0aFfEfa6Ltk90CtrXyHpxn0+Eu0H4jN/4DPHPCnqM7hlRtqX8ipWrFy8+fvXa6rWFq4tXrmyOx9BvtFv90P26tPlKq0sqvwLP3s+vSSg7T2VTUGY0qvyKlGfUlfEf8bdEfc6vCO3LVqbnQSxY8wPCsvwKXCuPde5niU4rzy/rq8PUnrXO3wtbuy6FzmvDP5P18zTF3rmS6xOCr7NZv8y1d1tZ/9rCcU/HBJ5jAk8NKx4s6zPs40bBr+HhZ4yH5wfimYiIB2FZPBPzpiiHhPMzrf5XgX4TmkPyyr29uI8Qbn53o92L2+q/eaUL81UdmCqW2/ir9Eyrt931zG+IqGcq3g1r3O/N+tvNfXSKytY6fy9s8eJ1EftIrX3NrH+NxfVzip59h9NHVWXThKBnOku5vlX/ZgSPHbQLTR5U/WbEp7S78PmaoL+RFznPP1Ehh6TqHEhrP4Xnkhr+mSyp7rXojVslW5RNZe8qXfUC3PO8qqr3nosIa5rag+3fqjxEWM9uX//dK2hgW45zmtY6fy9s8TJ+lX3n6Dy0B+vjfX5x/PPPOPKwah81BT1lesibI+kh/xr0kLeQHoJ0Hct637eytwEffm6jl/Ym4GdZk2huB8satquaaehx7SrkD8sapVe1RNlpuMcyxHNE4FGwzkaENUPtSaF75RfLGqSB83ePQVkKWWN6FsoaxHkE2oP18T6/pujZbzuypmof7RL0lMmad0eSNa8DWfO7jqw5nPW+b2V/AHz4hQqyJtE3KIN9OIZ/WLJGfWfPkzWHBa3KzmG9pqpthrBOR4R1LiKssxFhTUeExfI01fc4WZ7eiP6Gjw7J31AkTz+2V+MMladW/9UgT//ekaf8PXIr+wTw4a0V5GkaG30p+MwAezYseTpB9JTJU/VdRrX+TsF9kdz2vo+KZewvHgdYMdtY86vmV82vml/DhFXzq+ZXza/x5FfKPeZGVqzTxcCDsMwuUPYW+8q3q731gk6QcAx7S/mJRuhvDj7/eNz9zccErTdjvEx+v6NzH9N3HXPPzYtHHRTW+Yiw1Fmdic85Dd73MfwzRGuqeThP9DB/mHdLgtaWKGNfbNVzPLGM504MWMqHOUfvHYMyholj+2GCifvJrA9g/6PP7eWt7juIL9TnZvU/D3xuX9mB6e1hqH2pY1SGY/AUleF8MRjjciaW0dak+niPPLRnX+voA2q+qPO91Z5jyBnWic/yDdYHxuHcdLVPmPibICtGjzoTXfVzfhbFnqy/z5A+/L6IXevt679KDnlrP8tc3KNl+YVrpu2bNAhfUftMpnmyQ+ngrDdOiPapPWEF32Ckjo8MldGvJRnt7TPnv3w2odX/2+UuzNc7MtraoWyvXVSm+mC7xxX8qCOHq8YVNAU9DUGfsvHW2731zwNehZvrK/6gjnC4oP0/Be1/sMAuncr0PDxBMK3+mwDmegfmONj2ikeebR86ht5c2/Zjb9ufErQqPZvtgFMCzymBZ7vAyu9T2vbbyR4fFJanUyeyR4Jte/6WQGqdWtnJ3reI1Lc8WqKM45mqfssOy3juxICldDxPb2aYOLbZtkdbOFRv/KNItv3vg974vgFte7bfj0HZeSq7EW37D9a2fW3bC3pGZdujHGIZ5eXz4JpZ2/bXr63Y9hP7uu9gO6ra9p8PMnpHB2Zt2/fbZXs6vLlZbftbof2xbPvbAebNYNsfccZQbdvXtv04wcrva9t+a7Bq2z69bc85QbVt36XfLtQbHyK9cVDb/rmgNz7s6I21bd+92Lb/VEcfqG372rZHemrb/uax7T8/km3/nqUuzH9cwbbHNZVt+xko47mSyLZYYD6gHFY5vc2sf7zgWGA+/RNHDs/AexPimWeXcY4xvsdyOI1NG/7daMM/k/X3cwo5fCSQryqe+gjx/Bi8xzrcMYHnmMBTw6ph1bBqWFuBxWcNGXz1a3j4mafXh6wng+JBWKaLKLuM13zUGVOs+anOX/wxZ82vOhaagp4yHe8nSMfzzqzIf1nHs/o/DjreTzs6no0j5V+foTJPxxt1zhzreDg2sY84Z+7NiXU8hlWko04TfVb/tzv01Wfvb++z9+dEfe/s/TT+Dn32/hzwNb8mocw7e99ozOcOn72fJt8r/Ox9L4cg5tn77GfeCqzDA8IKOXt/Gt5rFPwaHn7GNGOb2R7z9hjT2I7h5xkZ/mHtMar1w9tjVGuv5y9iHQHxhJx3ll+s744DrJhtrPlV86vmV82vYcKq+VXzq+bXePIrpY+skYXpw4PiQVjmMxrh9yaC9/IN/7h+b0LZTXVsXxeeXeinvLC/F+ege9GvX+zCXOzA9M7WVXvRbCvhGJymMjzjjMdBUVsvUVubFdtq9R+Dtt7vtHXCaevNsO/+jA5vbrx994UroTKz3nevYd3osOp90e2zL3rVkclVx8Ig+6IvoTV40H3Rp8Ia/IXOGnyz74u+NPEazLCq7ou+pkNf4n3R5RHuiy6HyCbEP8x90dXHrq5evHrl2qPLSxcfX1h9nOWP0crPcCzk/9S+6IKon3ZfdOXa9t4XXbkWwn/EX++L9tJp5VmWer8yPBeL9yun09Dj7ldOC74qG4Bt8GPw3nbRQ1P5BPl7oCn24vPL9CXmzRTAwjmOOhTW/0FY+0O/1/2GCvpZfm20e3Fb/btBP/tRRz9jHUzFJCSexwvcVtRhVP83s355hn5J5sVPOToY9rs3V5UONozxiDhv5DP3f9Hpo6r7FU1Bz7Qoi8ef6t/r5rET43vdz2134fM1QX8jL3Kev6jC97rVHFDyg/2vOG7Z/3pMwNzutv5/iGjrTwt6ZsV7DeJdGpsq3P9q+Gey/n5OoXudD+Qrn0eA76q8S9aXlL2lzsmvYd34sNhfYPDVr+HhZ57dZuPXm++D4kFY7H/FucEyOVEe+aZMtnUUZTLiNNqaVB/v82uKnn3EkclVx8K0oKdMv/8r0u9ngM4Q/6vV/5uFLsy/If0e6eJzHlCfPkZlqMdxfyeS28nPFfuE099VzxWbFvQwrCLbhW1Eq3/4wPXftLrO6qonoxLnGgTHt/AcUmuz+g7OlvJSHlm5urK48Pi1R649urL6+GpVWWD11Xkii6J+2jNVVheV/xXPK8mvSShj3+wUlBmNyv+aKK9mMYT/iF+ty+x/HXSNx3kbA9bMgLDM/6r2I0Li1hL5BIL9rxyDkTpuTcn10Lg1jsHYTnFrqeMAjIfemBsUD8Ji/6u1tcj/ijoU1p/rrK1V/K/zB3pxe/pZfm20e3Fb/d8B/WypA1PpZ7w/rvyd2z0O7Qr0w1b3wFW84rD2HW5kPXnd6aMYevK0KBul/5XHTgz/6/PaXfh8Kf+r8aKq/1XNgXGIoSk715flR+jY/LSI8kPtfU2L99bi8OYi23URYV9jH2882EuLbIMZz5Bf9bdR43wble2CQb9nynNqq7CK4qGsXP0aHn5W5N/MLzvTUJ1FOhy7Of1ZpF/syLCqZ5E2BT1leu2XkV47aFzBr4Ne+zLSa1FXtP5Va0/+b63z98KWrpVLSu+KB3/5kdH5zZYuh8pBw69iE1PIQeW3UHFjxjvlt2+JMh4jVecFwrozIqxWRFj7I8I6ExHW7oiwjkeEFbMf944prD0RYcXk/c0w7mO2MWY/xhxft0aEFZNfMfsxppyIKQtjjvuYbbwrIqyYbbwnIqyY8/FoRFizEWEdiwgrZj8eiAirHhPVYN3euWfb7c8o1iCNP3DpMdP7jwO9jawXdyKb6bEG4TP+4TPEr2INjO7YsQZLi0sLqwtXH33k6tXl5YsXH2kQfKOVn6G9XzQ2lP2V1meydGl7xxosXQrhP+JXsQYPt7v1YvVlU9RP7P9a3t59ubBctS8tpgLtJd6rwn5Yi0Ln0jLv5caDvbLo7f9Pi/aOwmfPsjXRntSmr+o40cP8YV/VeUGrisllP/tW8jKbEWFxjAaO4UbBr+HhZ0V+5/xin73KNU885tx9x+OCJ1X3Hf+n47OvmpM0Legp89k3DmqcVX32b1vowpzswNwr6Gpmve9b2c7OOzkffmGj930cuzaGFGzO9xllDpuNjdAcNhxLKE+m6Nle4FPK7896sX5p5lr4d45YvqeO9TseyFcV68fy/WY6o66GVcOqYY0nLM9/EiKHFR6lDw0rjtfWfJS9vOYn2rPeXPPNBsQ1X+nzTaqP9/k1Rc+e4az5VcdCU9BTpiM+RDrioOeHfhPoiA+Tjoh0beo69D72fYiOt11tgk9JrOMxrCIdlc/zsvpf0KEvcT7ZxRHmkwV/52gk+WQF3zmK4Rf0vnOUKJ9saZvnky2F8B/xp84n4/O8tgLryICwQvLJxuE7R2lsx/DvHBn+YX3nSK0fai+A/bz4rsrbmoJ7LEM8Xj4HlrG+Ow6wYrax5lfNr5pfNb+GCavmV82vml/jya+UPrJGFqYPD4oHYZnPKCRGII3PIPw7R4Z/WDECyk8XGiNg76q8Nh6Pg+7rjyus/D70O0e/Rn7K4506oX5Kq/9P57swf8PxU3rfOWJbCcdgle8c2XtWnmXdOYTvjWIf1vDPiDammEO7iB7mD/NOnQWq9hB4rN5o39SrYdWwaljjCctkFcq2RsGv4eFnjIfXBcQzEREPwuJ9WC9Wb7vGXlmS26hi9SZv1ThD9Rur/1zQb3Z2YIbE06lxtTcr1m+miY5U/a32MW8RtDaz/rHpnem/1+lvHPueLqL6G3mFfyP9SiecovpnOvSl3cvo7sMOP+Y7fB/W8M8KeozuGVGWYh/2ONHKz9CGyP+dEPW9fdhE++1yH/YE8DW/JqHsOJVNQZnRqPZhTySiP4T/iL8l6vM+bGhfqhgo7uetwNo1ICzbh1XrX8j+aCKb7lLovLZnw9ofVXLd2x89LGit9ePxhJVSB8ZxMiw/K/NmCmChHNsF5Vj/maDfhJ5dukE66C7Cze9utHtxW/0joIM+m3RQnuNYpvid1h/W1TNNhyvS01jPRJ0PY1049+X5EfVMxbthjXsv32dcbIFBv+/1WU4fxfi+13SWcn2rfnYpj50YZ5d+crsLn68J+ht5kfP8EwN+O8rgsj6TX2ud34WtXY/xubPxYC9eTZjLe5H9MRFhL7FdGA/25c2xfCLrHweJ9xeD9VbeX0xj8/j7i8ifQfYXWc5jGeIZxXdmx+GbtQrWkYiw2KeRIl42v7w8a16/t6vv9usi+m6bgp4yvfkbI+nNO0Fv/mZHb+bcDSv7VuDDWzd6aff8AIn2moPjNXivObUfQO01e34A5TdXvl+Oa6qqO2IZ28jjACtmG2t+1fyq+VXza5iwsI2p9+aL1pAYeBCW6SGmJ9wiaEi7hxj+/Z9boD1YH+/zi3OLf83R727JennHzzz9zuqF6EiJfFvBOpLhH5aOpPjq6UhHBK3bJV47Jqz8nmNakZeDzn1vn35QWMcjwjoREdYpASvxOQ/B589x3nciX5T7PfJTDu/mBK0q95d9P4PmEecXz50YsKwM5S77snDOFe2v59fDBBP9dawPYP+jjf8RsvENX6iNb/X/64UuzL90bHxrt/LbHKEyHIPHqUz5wtKer9DVBywnHvUBNT6bVB/vkYf27O8dfaCqT+6woGdWvMdyKNE5pMH6gOEf1jdb1HkSyo+W9jyJ63I6/7cs6FH9vC+7fmY39xnSh99ssmu9ff1XySFv7WeZiz5Mll+4ZpqftkH4itpnMs2THUoHZ71R7aN65whw3bw8pp6j+G0ymu2Y/Frr/C5s6Vp6pEz+33pblx7s86L43Ekox/pfAfL/9g7MkPwjtc+tzlDieYjjL4WMtzFcdE6S0dak+jz+p+jZ0Q5vYnxPtCnoYVgqpiC/bJ5xP57u0Jc27nFhAb+pkBGuEJs/9Z6O6n9lC1bt//NO/8e0+VPLrJj2kVo3TF++kc/Iu98ZCzHPyPPszkS6crC+Z/iHZXfOBfLVeDcvaG1RWX6xrTjod0rGFVZ+z/4f5OWgc5/5HAPWUkRYyxFhrQhYNg9X4fko/D+Gf4ZoTTUPV4ke5g/z7qKgtSXK2P9zUeC5KPC0RBnPnRiwlM9qhd7DOce2FY5t9v9gLGSo/+fRCvp/fm20u+VY/0Wg/18l/R/1Jmu3laFOPU9luBYsUZmKObK5lGjsLvDYRX0AcbL/B+c2jvspevZFjj5Q1f9zXNAT4v9JJIeC9QGWQ6n9P0oOHRd8Nf5cTEPPpv/nkqCnzP+DfYb0GSzP/6POzVRyiP0/6tvqLIfyi/0/x0vax/4flB3H6b1TgnbrF2Wze+fZcF30/yDNjYJfg8nPvHkZKqNfTTLa2hHqo7H6d4GM/kaS0fg+++jRtjhBsO29b7mtC/s7b9N1vo18C6nyKpRvge3hBrUD23i4oI3/cgzoR/5W9a/dKHETrx2SD6UJ7/E6WcdN1HETddxEMawYfsE6bqJ/HtZxE13Yo4yb+FXSyQaNm/hfc12Y73TW9Tpuontx3MR/jGg313ET7lXHTWT9cqiOm+iFMew9yCIZ/QGS0WVnj7HdbPW/F2T0ByPFNtyI+Yp/6cjhGPmKDKsotsHGAPfjx8h+Z3/PWufvhS1eyn7ndXiUdrnqf88uD+3/T9R2+djb5ccFrUpHZh1e+W2Vn3y7wMrvU9rl28mWHhTW8L9xF26Xc1xJan1Y2bjnHd6FxJUYrXaPZYhnlHElSj/zdF6GiWOb7XK0Y0N1vnsPdd9BfFXt8q8Ene9sB2ZVu5zXfNSxTlDZjWiXL3f4VtvltV2O9IzKLkc5xDIKfYC8D45rZm2XX7+2Ypd/EsnoQe3y20BGf7Ijo9kux3axXX4j7pd+miOHY9hlDAvpnwBYbJdb/Rd16Evt/1B2OfvOcWxw/6c+B9LL2UDaqvb/o07/Y/+oPvP63+qF2OUTaXgXvA7bs3E9k/mIoLXeL+/n5aDr1c2wX87nSObXWud3YWvXYm3zd3nRIHxGD/NnUJsf7V4sQzzjYPNjH7A+Pcy9+H8eyeb/2/NdmK9x9Elrt9IZWZ/w/AE4Pg3Gdrf5vzuiza98SrXNv3m5Nr/S4W9Um1/p7FX34g9TGa7HbPNPlLTPs/kn6D1lb1q9CdE+b7+H66LNH0OHUvwOldE/TTIav/MVYvNb/W8EGf1vapt/82Kb7y1jZvPz3JksgDlF7bH6T9Q+gsLxEsNH8M7aR1D7CLYJrPy+9hFsDVZtx9d2/LjZ8X8eyY7/AtAR/0dtxz95VbXjP17b8bUdL+ip7fjed282O/7A7d13sB1V7fgdIKNv68Cs7fh+u+xIhzfjund/skNfbZf38y+GXX7W6f/aLq/t8nGCld/XdvnWYNV2eW2Xj5td/qmk8w1ql3/gXBfmCx2dr7bLuxfb5Z/t6AO1XV7b5UhPbZffPHb5yyLZ5a8AGf2K2i7fvNgue9WQ7fJmpm289XZv/eOAV+Hm+oo/OG8nCtr/DdD+BzvtT2wvXmOapzLf1maavxloXu/QHDJGR30ew6D5+N+eeIzW+fibV52Pv0VY+f3NmI9/PiKsOQErsc4e7DtgnT2R/eXq7HMO75YEreqs49Nwj2WIZ0ngaYkynjsxYCnbjn0hOOcYJo5t9h2gnRWql74lku/gH4Je+jZHL42Vj4/jk/PxE82lBR4HqA8o31Yz6x+fOCam6Nm/d/SBqmc0Hhb0hMihRLZxsD5g+Iclh9Sc9vLxl9PQs+k7WBH0qH5G34HyFyCsGPn4LKNOQBnn4+OaGZKPj+27GfPx031fcGGlTP7/Ecl/ZbthW4u+L/jfz3Zhvq+CX+JmO4PvvzkyPsUZfOiX8PwMJwCvws31FX9QJqB/C+v/hfBLNMQ7ao6z38Dq/9WAfoPteo7f39V+g9pvsE1g5fe132BrsGq/QXq/wTm4xzLEU/sNrv/m8/n44e47iK+q3+A3QW881YFZ+w36x6fnN7jQaUjtN6j9BkhP7TfoffdG8xuUyeiHSEYPeo7f54CMftiR0Wzbz0DZzRBz8CmOHE6dCzADsHittfqf3qFvHHIBcGxw/486F8Boq9r//8jpf+wf1Wde/1u9ELt8Jg3vgtdhwz8su1zx1bPLjwha61yAfl4Oul4xn2PAGlcb/5yANa7fvTuXhh73u3fnHN6pWOuWKOP9/Kr2DJbx3IkBy8pQ7p6j94aZC/B1kezyB0Hn+wZH57N2bzUXAMcn5wIkmksLPA5QH0CcRlsz6x+fOCam6Nm/cPQBnBvefFH6v9ULkUOJ7OBgfYBzklLLITWnvVyAlP7T/J/yE6h+Rrsc+0zlBXh2udKrlRxiGYU2e5VcgJmS9nl2+Qy9F5ILgO0rywVgXTimnqP4HSqjf5xk9KC5AO8604X5E7VdvnmxXfazY26Xv6W2ywv7P4Zd/su1XV7b5dsEVn5f2+Vbg1Xb5ent8lNwj2WIp7bLr/8++a3jSHb5z4LO98HaLn/yqmqX/1Vtl9d2uaCntst7373Z7PLdd3TfwXZUtcufDzJ6bwdmbZf322WHOrwZtV3+nHYvfVb/7g59tV3ez78YdvkJp/+3t12+eFPZ5Shjecwgnu1ul8dqY82vml81v2p+DRMWttHKdkEZvzcNME1HDtFFRp2XyboI2k/o0+Gcus8aki6S2sbZm/W3m/voBJSl6COzM4tyQ49De7A+3mdZt4/s2VWnj44T7/iZ10dWz/NrTwtaR+G3MfwzWX8/p9AXzwXylfPe8F0V389yrerZmOMOK7/nfRzlD6w695nPMWDNRYQ1HxHWkoA1jHyaMloR/wzRmmoeqjNFlxzerQhaW6LsLNxjGeJZEXhaooznTgxYVoZyd4newzl3nMpUjpA6czrUR/gtFXyE+bXR7pZj/UXwEX4b+QjVnoLaqzlPZagHzVGZ8iMPSx9QeY+ePhCa9/i9EfUBtQcWog+MW95jan1gO+Q9qn6Olfeo9kOryCGcpyyH8ov3cQ6XtI/3cVTeorKT2Ges/PrK1lTwDcZs1k9zo+DXYPIzb16Gyug3kYy2dlQ90+iv7+vC/FmS0fi+2WE25tG2yP+tdf5e2NK1tDRFuM/c2aXvF2ivopGEhuVLym8esY2LXu5s2v2uxWDdz/DPZHourUWhpytzlQxQe2HKZ897xlh2Eu6L5nuob+nOiLD2R4R1MCKsWyPCui0irEMRYe2JCCtmP94VEVbMsbo3IqyY/LonIqyYY+JoRFgx+dWICIv1gURr8RXPp5x4rbzaIHzGpyzz18pEcfDuWql89VXXygNwv9Xx0YwIK+Y8PxMR1u6IsPZFhBWT98fGlK7ZiLBaEWHFXCvHdazeERFWzDFx35jSFVMPjqmnjOuYiDkf744Ia1zl6r0RYTUiwrqdYDUELGXjW91ZUV/pOfk4Nr/Zl3zpS77opRldk/Q3OyCNsAMFBNwN7zYA2SQ9z7L+htrfB0rK7xawcqfXt3YsORWY4h00zgo6LpgpNkD2Ak8mBE4OoMaF0u7za4qeLXTaHyOAWgXwe844/jU8/IzxqIPs9mb97eY+QsGXoo9M+cc+Qpx7oT1YH++zrP/wvAecPtpLvONnXh9ZvVnxXoN4lyhBIHiTio3AvWnocY1AxVfj3R2C1haV5RdvcN8h8Nwh8GwXWPk9B63E2MxhPseAdXdEWEciwjouYCXeaA/euDD8w9osPkH0MH+YdycFrS1RxkErJwWekwJPS5Tx3IkBywsqUHNuL5Xh2OagFVQiQzdEH7uz+w7qHqFBK1b/d2FD9BrpXqjPWLvVun4HleEaezeV4fg0GMMKWrF+DQ1awfGJY2KKnn2xow9UDVrZK+gJkUMn0/AuWB8w/MOSQ2pOK33A+HNvGno2g1buE/SUBa1gnyF9BssLWkE5ZPNUySGWUeggaFEZrplsM+4taR8HraDs2EvvtQTt1i/cl1gfYSj4BsPTn0PGc3558zJURn89yWhrR2jQitV/HcjobyIZje/fQu9b2Ws67yQ+uEgmvRqurdj2nDg9K+Bb2xLZIQvch7iGIE6jrZn1j3Ucx9zH3+2sIcoxhM88m9LqzYr3eA1JZI8/GrqGGP6ZTMuGtTj0LHJflvGV7SYlO9GmYv2z6kfgalg1rGHDsjGOc2Kra6Za5z05NCgehGXrrwqu57UC9aQUa4XpWrhWKL9Uk+rjfX5N0bO3O2tF1bEwI+gp02t+hfSavUBniF5j9T8f9Jp/R7qB0v+UfTlLZUovHNahKta3RYeqsG6AYwH9aFP07D9E1A2UrsKwivzlrF9a/T8j/TLNvFq96PkJ0yYrr14MkU2IXwUjGd0zomxyC7ReXrl68eLjV6+tXlu4unjlSt8hL0YrP+MNSOWr2Cnqp/XXrC7ZuJpod+GjLyS/JqHsCJVNQZnRmM+dQ0R/Gh/F6lII/xG/sr+fA22o0pfKp8iHJ40iWGF/1r/Gsd/Qs+tGvVaz7A5dqz+U2K5T+92NaPxZenxatDce/OWr3n5N2nm6uBgq0w2/ktsp7FIlh9Wc4oN2lUzBMo7JUHs5JwQeBeueiLD2RIR1NCKs2yPC2h8R1mxEWHePaRtjjtWDEWHdGhHWbRFhHYoIK+Z8tDkU4n/EsTgKOc/6eWr/492Cr57/8aigtSXKeO4cFXiOCjwKVjMirHsiwjoTEdbuiLD2RYQVk/fHxpSuuyLCijkm9kSEdVtEWOM6vkzOq0OR2VbBPh+WLXeXaHdVW+7BDhBlyzWzft41Hd7NCnrK/K4bd2mcoX5Xq78Kftdnd2B6h4aPy94q91vo3uonR+w3dVBiyKHEifZWg/2SvLfaTEOPu7eq+FrvrQ4HVur9vZC5MCgehDVO+3u2poTu7+EadBe0aYqefYEjr4axv/fFtM4Mur+3F9aZL6V1JnR/r0llKLfGbX+P16fQ/b2viLg+qfWSYYXu71n9f9mhL/H+3rKNS5wbvI7enQh36Dpq+GcFPUb3jCjbyv7e6mNXVy9evXLt0eWli48vrD7eIPhGKz/j/r9H1F8Q9Y3XR+H9eLxeuab29+4BvubXJJTdTWVTUHa080zt792TiP4Q/iN+lQPA+3uhfdkSeHh/byuwWgPCsv09XON4f8+T3aNeq1l2h67V35dYdofYFons6eDYf5Z7qW2LuwL56sloNSdZ7x50Ho0rrPzecgFtTuLYsT3GtGttd06afJzMtPy8C9rD8hzXsil69tPOnFRj5y6Hd0cEPYp37ONKs/Z0eXc06+fdPQ7vjkKZ3SPv7NmbI/JuVtBTZnu8lWyPw0BniO1h9e+7twvz7Xf14vZkaSIfV7CfxvAPS5aqvB5PlrYErewPyC+WWcof1BJ4bnZYqXOXRuWnwXHDfppR2+0taA/Wx/v8Yrv99xxZWXUszAh6ymTle+/SOKvmlzVBVv4x+WnU+RTKh+P5acbt3A/W9UPP/fhA4n0EhlW0D1Lkp2l2lKe082p11Tv7Ia1NslrZJpkV9BjdM6JsS3HYj6xcXVlcePzaI9ceXVl9fLWq3mT1lX6/KOonjnlfVH4a9sVMQtldVDYFZUaj8tMk8ukthvAf8bdEffbTVNWBEQ/7abYCa++AsMxPo/YpQmR36g/TKtmtPpRcVXbv6nRyKtmd9kMBKxd5n9RwIO40PrTwQ/RZribS6xZZrzN6mD+s66o1QM0t7sOtzNM7I8I6FBHW7oiw9kWEtT8irIMRYd0aEdZtEWHFHBN7IsKK2Y8HIsKqx8ToxkSVGEGUTyn0DGsX6hmIk/WMPYIn+TVFz54SUc8YJEZw7W6Ns2qM4LtPd2E+swNT9Ruf24K6EZ/bovS4YfW3ym1GnHxeK/IeY/I59/mTnP6uel5rU9CT+rxWHlcpzmXAcWFjYY+gYVziTPdAe7A+3ucX+9E+0xkLe4h3/MwbC1ZvVrzXIN4l8q0NfIbPnjT0uHGmiq/Gu32C1haV5Rf79vcJPPsEnhpWDWtUsFLH+IbIoUHxICzeO8I5y2sF2hkp1gqzPXCtQJz7oD1YH+/za4qetZ21oupYaAp6yvTEryU9cTfQGaInWv0fBD3x6x09kWN8UffaQ2U3om7wrYl1A4ZVpOfOEH1W/8dp7yiNHtE9wwfHM+sw+xPhDpFNiH82K57vM6IsxRk++4lWfoZjgWWO1ffO8DmYhtfyDJ8DwNf8moSy/VQ2BWVGo9o7OpCI/hD+I/6WqM97R6F92RJ4+OO8W4G1e0BYtnekdGjvw4Uh807RPGiuXRpfwmLw3rPhH1YM126ih/nDvNsjaG2Jsim4xzLE461TWMb67jjAitnGml81v2p+1fwaJixso8l2XAu2uv6q/ZBhxY2O0NcZvM7Xvs7tASu/529gYd+iX+TD5BcZNPf5e051Yf6F4xfh84tR52XdTH3v0NsrVL4WjudKNGbd7yQq/bNJ9fE+v5i/H3f8KUofxmeenWH1PHma2BcVvNfCuSKJ9lDdXBHF1zpXpIZ1o8NKnacTIocGxYOweK8F5yyvFbieplgrzOeEa4XSYZpUH+/za4qeHe8En48qT+f0kV6ce4DOEJ3C6l8FneJMB2ZIno5ab0N0g1HvtbBuELrXsuj0dwzdgGEV6TZNos/qf1KHvnqvpd5rGYR+4nW915LF3Wvhft4KrD0DwgrZa0nhg0GZZ3h2CjxpvyUYvtdi+GeI1shr1qYNNEP0FM151tvwXeVfY19l1XUKy1jfHQdYMdtY86vmV82vml/DhIVtTB3rsJPw7IyIB2HxXovn60zkJw5e5w3/sHydak8u1Ndp796MPrL8PnSv5dsi+UVedLIL8zvIL+LtteA4Y92M89yxTO21cP53fq11fhcvLy8tXVq+cmnhyuXHFxZXHn9s6fLS0uOPriw8tvDIY0tXr6wsXrm2srSy/Njjjz16eeXyI4vXFq498tiVa5evj8kyPn4f8XGiIh+t/lHg4+s6MMtwv55wNyvitvq/f6IL8wfJP9Kk99c6fy9s8Zql9mdZv9ybhOcR7Zvgb9IY/pmsf8ymkHuTRA/zh+XeTkFrS5SxfrBT4FF2lFq3WFYNCovH1lZhxWpjza+aXzW/4rXRZBXKtkbBr+HhZ4yH1wXEMyx9fZfAY+vWNNG31vl7YUtX+Lpl+GeI1lTr1jTRw/zhdUvlqStbjOeJ8v/NCDwtUcbzZFBYap5sBVasNtb8qvlV8yteG01WoWzb6nqC68IuwrMrIh6ExTEmvGeUZcM7X07t2au4yibVx/v84j39TzgxB1XHgvJLhNiqafbiFgbei0ttqyq+erZqyF5cfo2j/zkmrPyefXQxfNkxY9VinkcT87wCL+4vcV5C8DmMhn+GaE01D5WveK/Du5C8hPz+FNxjGeIZZV6CWrs5zpn3KbAMx/bDBNPL8cH+R1/svfd030F8yhebXxvtbjnW/6UTXZhnOzA9n7k634vjDHEMsh8e54vB2O4xp8sdvsWIOb1F0OOd9ZL4bJRgfcDwz2RJ5eIi9yXyVZ23ljae7bqczv8dFPSofs7H256sv8+QPoOFPqz19vVfJYdY1qAcYpmL+1ksv3DNfHa7Ww/xFbXPZJonO5QOznrjhGifOltPwbfnqffsTUYrOybintVS2RrwXFoDvHN98mu93S3H+s+FNeD5zhpg41HZdjupTK2Fxq9ZKluLwy/3vE/EybHmoed9froj56vq5xOCnoagT9mQ6+3e+nsBr8LN9RV/cM0uOjfos6H9D3ban9gefYxpnhJt9Gh+FGhe79AcMka3a67k5yUeoyG+iUTxOgOfyZLaN6H46vkmVN5LK+vvW7ZjVE6msr22C6z8nn0TMf0JMfL1Yp6z6OXoDAprv4A1DJ23jFbEr3J6UsxDlaOz3+HdQUFrS5SdhnssQzwHBZ6WKOO5EwOW0vv303vsF8IypccrH02ob+LbIvkmLoBe+h2OXsr+B2XjqPzIFpXh+OQz6hPNpQUeB6gPIE6jrUn1eUxM0bPXOvpA1VynWUFPiBxKkwsXrg8Y/mHJITWnZwVfjT+3pqFn0zdxm6BH9TP6JrDPkD6D5fkmPD8oyiGWUV5cNa6Z7JvYXdI+zzexm95j2xTvld0xK3AX2Xbom0iR448yWtnaEX0TK2VrwM/RGuDFe+fXertbjvXffrwL8xecNYC/P4E84e9WsG2H/NquZw7/siPnq545NiHoaQj6QnwN+wCvws31FX9QB0EfF9Z/p/BNNMQ7ytZm34HV//Ux9R0oHnm+g9Ax9B9r38HY+w5aglalx7OdMQ75QjFh5fcpfQfbyd4fFNYBASuxzh7sO2CdPZH95ersBxze3SpobYky9h3cKvDcKvC0RBnPnRiwlA7JvhDey8UyHNvsO0A7K9R38LeRfAf/CvTGj1fwHXj+AdTT9lEZjk+DkXguLfA4QH1A+baaWf/4xDExxfCOXv9V+oDytan5omJc8LyaMjmUyDYO1gcM/7DkkJrTSlc3/tyWhp5N38EhQY/qZ/QdKH8BwhrUd4ByiGUU2ggc14BrZojvANtXxXeg7Eq7V74DZZeNg++gTEbfdbT7Drajqm2/ADL6ng7Mrdr2yn8zLnu6RlvVPd17j17/VXJY+Z+Ur1HZZcgrpi/Etm8BXoWb6yv+KHuG23/haLbZ/hDbXn2Lkm37RYDJtr2Xs5DIPg3+dinnLIR+u/TS0W5765wFLaPX4tAzcM6CGrcqfpjtgKoyYNxh5fcpcxZi5hlspxiDxLHCwbY9xwonivt2Y4X3ObxT+64tUcY5C1VtIizjuRMDlopd3UfvKX1JxfywbY/rdqje+DlHu+8gvqq2/X7QGx/twAzJWVD7dsru55gBtf+w3b9J+gVHr//G+CbpbkFPiBxKZEsH6wMcn5RaDqk5rfZQhuGDzf8pX4PqZ7TtVZ4Cwho0ZwHlEMsotT+q9hZCchaUvzIkZ0H5Jex+QrTP29dRvBhWzkKZjP6ao913sB1Vcwp+8FgX5qs7MPfS+/kv5xRguzinAM9hYZ8AngUzjFx35OleognbmNj22VwnLAcF1wl17kmT6uN9lnX70Z59x9Hrv2qdUOewTDu8awh6FO+sn8flnADmXeg5Af/X0Swa79TYZ1hIv5pHU1T/Xx29/pvP0V862osP54zJVTXXeJynOYuo21czoq3Toq3NrH8OoGydomc/evT6r+qrqudSNQQ9oztffeGGOV/d+yYayjC2pVT+oMoV3S6w8nv2j6BfCdfzXzjai9Pew/Uc311vd8ux/hNHuzDfCvcmN9TavivrhWVlv9x5R535GVNmoJ2UEa5bBE+aJTzxxi3OLWxPUT/jXDf8ai28JSvHvQOePUy07q5Iq/LZKf+zOgdgtiKt/B2P2Yq0qv2zWYdWtfcWSutGe7i07hC0qv2JXYCPYSL9aqxn4p0i3aIpaGV5gvV/5+j137x87Vgv/Z6ul1pPVvsrnp4cur/y3qPXf1PpeqnPB2P7MIaPXNn2Vqb8bjwWtmss9gePXv+NEYs9KehRvNtJvEt0/sYm7/YJ3rUc3qFvbZ/gnT37y6NZNN7tFPSkOB9qO8V3DgrroIA1jPylMloR/wzRGpkeN0broMO72wStLVHGup7K27pN4GmJMrY1YsBSsXwc+4rzfCeVqZwsta/GaxHqMWjb7DnWfQfXcbRtlA7Htv/XHuvC3Ee6CuoGLH+9eFCUhfupDMenwUg8lxZ4HKDcVrHMzax/fOKYmKJnd3T4puR21RznvYKeEDmUKBYy2H9i+Iclh9ScVucuGH8OpaFncz/pdkGP6mfcT1LxoQjL209SOVxKDrGMQr9Ai8pwzeT9pD0l7eP9JCU7lJ7JNs+EaJ86Y0PBNxgx9RzF71AZvXSs+w62o0hGr7e75Vj/mSCjV0lGo63s7SvMZr2w7b0HAPaVY71tVvs9aNM2CNZk51/+bLegi3GvAe6nbRF3fin/lY1L9hXiu+grVOvbHqLfyl4F9D90rPh9tu1GbZ8YbVXtk+c661zVc3AmBT0NQR/PE7wfVhyK4ud+QQ/z69NorB4E/ihZuIP4oOJfDjp4DxBeFTOs4lsQL/eFtXNHQf19RIPV/yyg4e0bvTDVmW1IF/tGFc0zFWmeCaD5cwTNw4gbxL5TPGH8OA5wjhxw6rM/ieEfpPrIIzWf19tZDw+t/jXg4RMbGmazBCb3Ywb1USdiP7N3BhLiVzL6QFaOW8XPcH+E0urZ0Yhf5djdWpFWnk+3VqRV6dq3OrRiO26rSOtGe7i07hO0NrPisYO49gka8B3U97D+Vxy7/pvLJ9Mhit7Bfr+FyqzuVwt47OfOL9PplW+a7QR1Hi7CZ7mSX96eHOvK+C7qysp+KJJlSo/Gd5lP3wB8er2DL4Wvg+VLqP1q9VUuIs4t3kfFMX8oANaMg1vZtocc3EgXvsu4mU57z8blRLtbhr6i/JqEspj+jnzd+tWNLh0sg6bavbzx5E1+hfBS9WOL6iPvqvoA2O8a4gPA8YvzpZH1j5eq834G4O6heeida7uZr368+/4PO++zPazOQd7u+ZE/0Wl/jPxIlSPQEPTxnj/eD8vGLcunbBTw6+dpHO8H/kwUtB3vy2xBxruP8CqbTK2hiJfpsXbuKKjPOoTVfwvQwDbZbNbPB6SLdUhF80RFmicCaH6HoHkY35/Bviuy13m84TmVysbi+px/xPBD9B6Vc8xj/t8DD58osMWbJTC5H7OsP0bK4GB9ZbsrX5SS0fuyctwqT4v7I5TWMvuRz0RB+kLsR6R1o91b/2BFWmPYj8M6U0HZUxxjg8/Q96t8Ghx/9IfHrv/msuX3jvXCZb+3+u4Sw3sPwPvAMd2+/EK7KKSeGuOso6BOgHwomktopxWN/x2Z1jmK/GB/KmSuipuydiif/T7Abbzx9DDugw9CH5i+V1XHw1yY/EJ7AvW//JqEsnhryeKisid6vrMBeEP6mOWA509BmeOdB6P4g+c4DZs/PXkl7d72Kr2j6vqj1nBlN3GOs9oDxTUJbZ4n67S7749yvPXYD+3eNpWtqVXX86Kzi/N7jvFR8dlKno3OH1B9/rZK2lSVn3zOpTqTXslm7geUzSy30ZbHNc3krtdfDXjGNn9DtAPzLFXeI+/leDmY+C77CG4DH8Hc8WJ8KfLkWc8PzX22+t55jNh+w4161cEAWBMO7jK9knErvZJpyQSdeA7ek7ja3bLhyErt6+v51mG7t92h39jweKn6UZ2dyf740Pxx79sXRfnjOH5xvjSy/vFSdd5PAFw7A0PNJ9YDrex1MI+Xjxe/z3qgavd2j7+4v9P+GPEXSpY1BH0hvr5Rx180Cvi1TuO4LP6C21gWf8F4DxDe0PgLxBsSy4D1i2y4ZwMNKeIvJirSPBFA8/MEzXX8RbX4i38APEwRf+HpsuMWf+HRGjP+4mAJrRvt3vq3VaS1bO/3INGq9n6HFRPbzPp5uZdw4jO0S5T+w77sLwR94HOP98L1YidOF8D7fID3suO6ffmFdlFIPTXGWUdBnYB9fWouKV8Dj8EdmdY5DlD7rf6XCZmr7En2IykfLfKmShztK6APXjegjuf5+kbpy+rJlQS8IX1c1S7ks6Owvufra42QPzF9oYqfag1XsQ6nCZby46gcrnEbbz32Q7u3TaFnQYau517sCO//bsV3ajSO2/zdX9Kmqvxk+1zlBSrZzP2AspnldtH+1evIVlL9hbqAZ/Pbu3heuvK98f6ud5Y6vss+gjfA+vFWx9eX4nsXrOeHfsPA6pfFqzYItxdbq2B5vr4yvZJxK72SackEnbjf/CSudrdsOLJS+/p6vh3a7m13aJ6zx0vVjy2qj7xTe+js60Odzss/Ltr3w/GL86WR9Y+Xrfj6/pa+OxPi6zt3ovv+E44eyOcm3oi+vl+rfX2VfH3vGpGv711j4Ov7z9vQ1/cHta+vj+dVfX3vq319ta8Pym40X9/fgV7/0Qi+vr8FeJMndPvyC+2ikHpqjLOOgjoBnyE7LF9fo9MW5etT+djqLCnUHY03VXx9O0HHO0fvh+p4eK5sftW+vtrXhzBQpte+vtrXF8rPcfX1oWzmfkDZHOrrM7nr9RfqAqG+vp9zvjVblPsS6uuz+kuwfjx8ohgf+/pwjHLsnucHVDqtJ6NVfp3VjxFb58HyfH0x/IxMSyboxDPLnsTV7pbZs1H4+nq+B9TubXfo9689Xqp+bFF95F2Ir0/ZTMoP6MVco33+MM37WL6+b6N5H5LD+4swj59/ovh91gNvxBzeTwO9vM7h7aeH+fViGsfDyuF9MfTTqHJ4Hxc2HPev8nnm16hyeF8iaK5zePV8Xm9nPTy0+l8CPKxzeItprXN4e+UI/hoefjYOObzfAPrA15zohTtIDu+rAd63n9Dtyy+0i0LqqTHOOoo6m96bSylyeL810NfHuWA7BWzkjaeHcR98J/TBLw6o43m+vjqHt87hRZle5/BmbjxA6Hpe5/D6bUqZw6u+eaJkc2gO7y+SrRQrh/e5jq+P7QY8tzDE12f1fxnWj99xfH3ed7nYD7hX0Kn26PZQG5SMVt+rs/plemiDcHt6qILl+fpi5A8zLZmg095Tc9t4MwpfX8x9EcVL1Y+8D4e84zmK/ad0bt7bU75rtS+P9vnvJPL13UvzHvnFOSz2XrMA53q7t746U7AJz7hvyr4taPiNVpSfId8WRJ6xXr67Iq3KjzfotwW972vnF/t59lSkVelnKn7T21sJpXWjXY7bo9XTfRStar40s/6xzLEzCAvr4T1/a9jq/zmsY3ef7IXbpHfUN1ObWf94QZ4UwZp1YO0pgNWgZ9g+9Q3JKapv7cvb+te0ZitZoexB/g4j+/V5XPHctP43m5nrsL1q9f8ebObfhzUlv3Bts3Yk1ltXU9tVZXOH1ygVwzRCO0nyp+nwR62BnmxR375WeqfSz3l9UbhxzfHspFGON+QB8zP0G9ZV1+tWVr4GNgUstV4rfuL3IvNrst1Lw1rn+cKWLs1PpDGEn56eX8ZP9utifT4LHnU37gd1rhSuZV6fNOCZp2M2Ae7rj1y/V7Yezyv85n2IjlmmjzCPle6Ea5XhN1qLvktVhBvnS9E6FkprDF3Iw420VskbULSG+jyVbV60p1ZE60a7HLdHa5ktz7QqW76Z9Y9l9U2JvYIGteaw7rIKetdnko45QTQgL5tEO47fW6hM+U6UfDUYo5CvXgyf56cz/mD9sjHqfeNzDGJwk6/nZd9l8vyeLBsVbqXjj9t67unj3tqRXyHy2/vGA8dOIKyt6Juj1N9jjs89Dg+QR16Oi9JFed4r/wfKYa9PGvAs1Af3faQfqRg0Xk+KfO9FeRovhvXk3Sd78eE6wOuHiguxWJ991J61zt8LW7xYXmNcl4rdUbEMPec+0rPP7bRfxeepOavWFBXTyToX0qfGB+tcSi/x9v3K9gW82GeObx00ZymU1rLYmANEK/KS45NRp+J2XciK28w+WeQV6/0qbme7f9f6K5xxX/W71iFn1Kr82vxab/fWPwR4FW6ur/iD5y8cKGj/q6D9HO+J76jxyXuaVv9rAeZ6B6YaXzyGEn1P2x1Dar5VHUPf5IwhJUNU3L13hoWatxwXfmAEvFN9WZV33+7wTtkm+x3e7Rb0zIr3GgW/hoefNQnWbRFhHYoI6/aIsA4LWDbW7oDnEcfaSgitiH+GaI1Mz2KD8Bk9zB/m3Z2C1pYo433EOwWeOwWeliizva+YsJRMOkzv4TxnWxjH9sMEE7/5Z3aIilt6qPNerqP/JNka6kwJfHej3S3H+s861YX5RtL7VeyHWrtuozJcRw5RGeopBsPmUqKxu8BjF+U24jTamln/3MZxP0XPftGR20qvVd+LVHmhHPPNei7yLpEcWh1UDiXSgV05pHQJ48+daejZzDu5S9Cj+jmfU3uy/j5D+gwWfvd4vX39V8khjh/y8g9RD+bzxHDNNH+mp39g+0ymebJD6UrsI1D+9tDcf4MRU89R/A6V0b9NMlrZEOoMDLYhfhd8M/9J+Gkago6q/ibc5/s28jd5+RybZ+DDOvIHJ4vfZxtb2Rzb3Y5+X0Q7WuVaNwR9ajzx2Xg494fFz0OCHubXf6dxfBj4o2xT3ku4XeA97OC9nfAqe987x0n1hbWzKG/nNqLB6n8EaOD8TnWmHdLF/kFF876KNO8LoPmjDs2HHJpRxnHf4Rg+5NRnvwjDvz3TPCny27DMtfofhzZy/uVtgmbPH6XO+PLOGyj7/rqnb3P7vfPF8ov9tocr0urZg4h/r6DvjqwcN9K60e6tf2dFWpWOhnrXYaIV6bN31fkSjYJfw8PPPBnP+ZfIS47Vx2cYz3OHaBOfDXYA1us9p3rh8vls2Gd7C+DtA3h3n9Ltyy/MVQmpp8Y46xC4ZnP+pZpLSm/lMbgj0zrB7dR+q39Hpy0q/xL3IFnn3ilgI288PYn74Cj0wTq9H6qDeXGeqJ/l1ySUpd4nxj6bArwhfcxyQMkZHON8PjPW9+I8bh0hf7zzbpReUHX9wTX2EPFHyYdG1t8PvJbllxeXMMrx1qPft3vbVLamVl3P2UZHfvKesbKFlTxT/DQax23+emep51dVfnIelvKvKtnM/YCymeW2iv1Cuev1V1G+LJbhu+hLUP4VbDuvD8oW4TMErP4nwfrx6KlifCl8way3hvr3rL7SBVEP2kO4Ua+6MwCWlzNYplcybqVXMi2ZoNPeG52s1PmXuD7y3A7dL/J4qfqxRfWRd1V9pLyPE+IjxfGL86WR9Y+XqvMez+H4yQIfX2j8uxezaXCwflkMLI9lL0676tknByrSGnpmbkh8Uxmt7Gs5WJHWsvgm75szt1akdaM9XFr3CFqbWfHYQVx7BA0qhm+K6r8C1qrvPFVMj5dXsJtoUXuoWJ99RVb/lWD7vXdDw2wKmPll42p057ksPJr6WzllZ5F6spllitrjUN8OUPw0GkfBz5hnFCj+e2cNqz13j59eXKc6n0qdo8Extd/u+EfQZuSxoHKQcc577WiIdpTtfZ2mvS+VA9PI+mXThIBbdD7ia0F27T/diw95yX4aJReH9Z0e9b0cpV81s/5x1uOboGc/BONiKeB7OmpeqPwIPodQyWEcHyHru5c7FHN9L/vmCM/JWyvSWiaP+Zsjak8oE3i4XacKypRucMHByXmMyFfOR1DrynTWv66kmCNmN+AcUbEYTaqP9/nF+21vduZI1fiifYKehqAvZF/rdsCrcHN9xR+0pw4WtP/t0P4HC/bTpzI9licIptV/AmByXLaat8OKSVA88mISQsfQO50xVDUmQe0pq3nL8QepY9oV71RfVuXdb0Vco5Sdr3TERsGv4eFn2zmWelBYdwhYw4j3K6MV8c8QrZHp2YyH9Pyfinee3wzLeP9B+efuEnhaouxZ7fiwlEziOHMVg6RiHjkuG32vHPOHuWwY8/ffyC7BeLkJ8e5Gu1uO9b/2dBfmh8i/4X13r6q/3crUN+cSxxYv8NhFuY04Md6G5zaO+yl69teO3FY6sNrDU+f8WT0vByaxHAqOy2Y5lEgHduWQ0iWMP3eloWczLvtuQY/qZ4zLVrHYCMuLy/a+SeZ9A1rtK3jxByxfitpXJS5b6UrWL8rm9+xUrpuXDzsuu0hG7zndfQfboWR0fs9+X6t/K8jofXC/n+Cr82qwTZ5vCs8X+HBnAHo5yEzjq4Cu208Xv882trI5trsdfU+n/THsaPW9+4agT40nPicB5/6w+OnF9Fn9MzSO7wD+KNuUY38OC7x3OHgPE15l76tYEcTLfYExdar+IaLB6s8BDRzjfKvgA9LFvkRF876KNO8LoHnJofl2h2aUcdx3OIZvd+qzX4ThH840T4r8Nixzrf5laOMTBbHnzSzMH6XiiLx9rLK4QU/f5vZ7MUz5xT7eOyrSWhYPw/q/Fw9zRwmtG+3e+ndVpFXpaKh33UG0In32rtq3bBT8Gh5+5sl4jstGXnJeJj7DuGyVCz1F9V8A6/Unne6Feyu9g33WKoD3yQDvs07r9uUXxrCF1FNjnHUIXLND5pKXl2D82pFpnYDj3K3+pwuZqPYWWeduCtjIG09P4j74R9AHrxpQB0P/TX4Nf1+7epxsWR8PmkvSEvW9uOxRxr16cRRKL6i6/uAaezvxR8mHRtbfD7yW5dfo4yg0P3v0+3Zvm8rW1Fh5APk9x1EoW1jJM8VPo3Hc5q+XB5BfVfnJsZTKv6pkM/cD4mW5XRSX/aoCmx9pRTudbfK9oh3oS1C+WY5pLvMzFNnw3wDrx+sdfCl8way3hvr3rH5ZbDTH56nYaA/Wfgd3mV7JuJVeybRkgk57b4QxZ3Ju95xZ0u7lTeh+kcdL1Y8tqo+8q+oj5X2cEB8pjl+cL42sf7xUnfcY+8b7PPitEOXjW2/31lf7xk14VjUu2/vuVUhctvd9jQMVaU0dl420hsRtebSmjstGWjfaw6VV2Tcq9oq/JcvjORPvsO/O6v88rFXvOl1MD589iuOVz3dQcdmef97qvxVsv5C4bJQDXlz2cM5L3l5x2epbB3Vctj6nMiQuW/FTrVNMa5Gfm7+BZPV/y/GPqHhaFceE34l81+nydjREO9TeF8L9Wtr7Qt7j9wfyv/Hs7hT7KUYX7msgTqOtmfXLvZ7z4+nZHzj7U03BR7VWqLxWHqdNwM99omS71f9jkO2fINl+I/bH+4fUH2qOePlZZd+osb5UfcP5e/ie6dDTWf8cT9FvJl+w35RcaWb98qjnux/07C+cftvt8M5wZZm2K3Y7vJsl3rUS826f4F3L4R3qbj1rHj37WETezQp6PFheXrDSrWdF/d1Z15f0JV/6ki96aUbXDvqbA2qMsANUzxYqq1tEYKsAPuJt0LsZ/c2HC02IOvx3S8BHQe0JrtAFuQlw1+7W+EMNYOXs94ReWWI4GxQ4cdmRpHCrpEyrf3dFWo+I+ugQ4Q1NpO9IRVo32sOltSVoVZuiPB55jGTiHd7Es/r7773+m4+7U/cW08MOPRwDRZtNqARhfTYqrf6hDn40Kkf30aeFi1Udf2p8eI6/svHBhyfg+OV51xKwUOizUWPv78h0H/Gmt9U/Dn3kJZuyg7EpYOOY89oRKkMR7ns7BKvxykFiqYOw8dBhJV8xIIj7FmUz98UF6AtWKNSGkVICVN/xxgTKDmXU8Fix+ssgW36aZIsKVkscuLzA8xT7QwXFNLP+OYlzfIqeXXH6Q601SjZ4c8mTM3sFLKt/j6h/N9XJMt0391AZvsfG6D1QlqLfjnbgYb8hzruh/Vgf7/Nrip6tO/12t8M7w5VfyhjlACre+FK/hoefMR6E9az29d+9WX+7uY+OQVmKPjregYd9hDiPQnuwPt7n1xQ9e77TR0fhvQnxzOsjq6d4xwkVxxPz7kTWz7vjWTHvTkCZ3SPv7NmnR+RdU9AzK94bdHzPZv3t2SqskxFh3RsR1n0Clo21M/A84lgLTrI0/DNEa2R6NpObzhA9zB/m3VlBa0uU8dp5VuA5K/C0RJnJ2ZiwrOwo0HkfvYfznGHi2OYky3vhPU7gQV0QE3i+lPRx04uULZdfG+1uOdb/C9D9/gnpfqhrHc16y3A9P0Flx6DsJJWhnDQYNpcSjd0FHrsotxGn0dbM+uc2jvspevZKR27jWjkhnvE4uUfQMyveG5IcCk6yZDmUaA125dA9gq/Gn7Np6NlMsjwn6FH9jEmW2GdIn8HykiyPQn0OLkI5dJzKTkLZMSrDNZN9wveUtI+TLFF23EPvHRW0W78oe+GowK3gG4zZrJ/mRsGvweRn3rwMldHfRTL6aKdOqL/N6v8bkNHfSzIa3zdbw/OpTlPdVLLW+IWyVgXENbN+/mK/TdGzf+XI2qqHKSg/neIdb2yN2n5m3h2FMrtH3tmzH4vIu1lBjwfriIDF7cX6s079Y4H1SzfCdtHfLPRQsOJlmyNWl09hYcfcUYLDDSnaMNtFcPHdjP7mzYaJrP8qezcUdn6hs9DqKWcmwvOcwphh9FZyCh+FejYReHB/GITkz91b/P6N4mh5a2JHS0PQpxYtjphA5WNY/Dwh6GF+/Tsaq/cCf5RiwnP4pMB7r4P3JOFVmdzKOEC8R4kGa2fRZtBxosHq/z9iM4j7F/mAdPFGsKL5roo03xVA8286NJ9waM7vOTPb+gLH8Amn/lH4W8E/mWmeoGJ3VMDnMfmfoI2cyX1c0Gww82u9nUmeZFnYpvdJUV8ZDkqGcvsVbmUc8NwLpfU+UR/nHjsgkL77KtLK4/2+irR6DjJFK7bjTEVaN9rDpfW4oFU5udlRweM5E+8c7dzzHPkArOsfvrcXLr+D/c7Z5Vb3gwKeytgxVGwA5hcGNH24wMjLL+WIYx1IyXs0HpVBwvMPdSK1LqBzEOt/FHix+75ifEez3rIYzr97qQ2hDh2rr5y6OH/4S3Y4rs8GwLrLwa2cPWcd3EgXvsu4mU57TwXXoPM0vyahLKYDUAXXoJyZavfyJnSDwOOl6scW1UfeVXWKseM+xCmG4xfnSyPrHy9V5z0G+bBj3wIGUA9oANz1dm/92EGFXkBZSFChl7FRNVCvLEDCCyq8pyKtG0Omda+gVQUVIo1qjGTiHbZNrP49nTGcj7ul+4rp8QJLYwUVnuzgLwsqxCCk/JqEsohyL3lQYdn4YLmnHIDc/whrK0GFnP1i9eehj7xMKS+oEE/zW7qvvB0N0Y6yUwK/mPxHCv+0aHcKf4XxoujL3Eabmus9442ePQB9sdXMnL2CHoYVGlRo9ddAtnwuyZYbMcjzIac/YgR5Mn+fA/g+s6D/i3QGtnGVDuAFKpadKmH1vU0qDzeO1RCdYStBlbzxg+9zUOWNuKH2Gc64rTfUuvfIO3v24oi8qzfUgCj+REJRA2+0DbXPJYVILeQILzRTbeOuXripjUpPGUb8IQtEVaPySEVaj4v6KMjYUEP6jlekNWQzxaP1hKh/3KEV23GiIq0b7eHSulfQmtoAfiUoqd83oAE8S7QMagB/jTCAGabahM0v76iWIRnM8miRng3sdm+byjY3qm5YsdGJTj2WKcrQxPngHdViNI6CnzEdEIr/yCc+zgx5zRm6VR0QhifUAWH1v3tAB8SsgI1z3mtH6HqLcH+lcy6cl6HLGb7vBln0r+4rfp8DWEbtwMCMZpa7ngPjRxzlWWWX4jMvgIV1Ly8rH++HZcgpfqosP+bXG2msHgf+TBS0He+PCLzHHbxHCK8KYFE6BOJletS8x/q8aWv1f1bMe+5f5APSxTqXonm2Is2zATT/okPz3Q7NqCNw3+EYvtupz0evMPyiExZQZ2kJ+Dwm3wFtfCJAZ8E5vN7OJE+yLEy/jHFqg4db6QM890JpLdOFOXLb09vLaN1oD5fWOwStzay4PxDXHYIGfIedy1b/t2CtfPd9vXD5HeTlWSqzuu8S8GxtuaULftOPwI5aLEMYPB/zq6pegaclfD3pFSiHinTcIsf9LJRj/fcAL/7yvmJ8HOSgMuHV3OPxg2OL56XS+T1nrwos42AZxI1z694AWJ4TrSxIjXGrIDWmJRN02nsjtPVkUAjKjal2b7s92y2/Qnip+rFF9ZF36viyWSpTsksFg7WoDMcpBoX8Jc37WdGOBjzz5v0swH2M5j3iZ9+GlV04033/Y/cVv2+8H5fseT5RCcd+zxijZ59w7AmlKygHutqwZpmkdLEG1ckv4ycGLA2Ln+cEPcyv6TO9deaAPxMFbcf78wLvnIP3POFV9oTSPRAv02PtLLInThANVn8WaGDd/IjgA9LF9oSi+ZaKNN8SQPN+h+ZzDs35PdsH1hc4hs859bENCv75TPMEdY8jAj6PyduhjU8UBP03Mz2H19uZ5EmW+UEQzBOsjzwx/EqGcvsVbhwnbE/MVaR1XtTHuXeOaEX65ivSutEeLq0nBK3NrLg/ENcJQQO+Y33G4+4+WCsvnOmFy+8gL9mesLrnBDz2VeUX2xPqM7cIg+djflXVK+zdHO6bOgqQ8R7lEMvystPFboFyrL8KvHjumWJ8PA5QbztPZUcEncqe4LG+lHUv5afmsbss6i9RHcSNY3c5ANYtDu4VUX/ZwY104buMm+m095Q9gcl9+TUJZaO0J1Q/evaE4qXqxxbVR96pAPRbqAxlA9sTOJ+OUBmOU7Qnnkvz/hbRjgY88+b9LQD3W5x5b/JpisreBPP4U515bDEWah5bvemsfx6n0I2Nl6ijKtupmfXLjp69S3r2maCnbDXY7xZBT0PQF2Jr4LweFj9PCHqYX4/ROD4P/JkoaDvenxN4zzt4zxHe0ORbxMv0WDuLbI3jRIPV/1xHbz8s+IB0hcSLNCvS3Ayg+Qsdmk84NOf3bDtYX+AY9mwT3s9k+GzbYhvUWCpKvv1Sx9Y4LmjGObzeziRPsixsbfd0bsSvZCi33/PX5xfbGucr0qr0fbXO7RX0sQ55voRWHu/zFWlVegGuraxHIn1LFWndaJfj9mgt0y2ZVmzHMsBEPMwzbgvSoNYdtnFeDWv+m8guYn0f+/0UlVndbxTwQnQIXLNNF1X6KuoX+TUJZfHWQ/0ZURwvU4C3aBxj/arj2MZhK+sfN4cd/mz64LLh8+cWhz9KZ/LmjloHUUay7u2tHwq38tWM23iLGVtXth55Sbgs45WNUpQI+2Sddvf94cTWaX4ijSH89PwGZfxkuxHrc8w8fzoK5WF+FcUmmM7HddifZfV/EvSh36fYul1AA4+FaaddyteFst8bMw3RxjK7djfZtUrXZZxF/qwmlGP9X4A17LfOFOOztqv17QiVqUN8lD7FtpbSzTy5WeaLbRBuz2+sYHl+4LI1jXEr3YxpyQSd9t7o5PVCZf3A07HzK4SXqh+VfjBPZeqzbGqf+zyV4XximYDjFPe7fovmfVO0owHPQvNbPtAhoIo/62lnu++/+yb3Z72n9mdV8me9f0T+rPePgT/rv21Df9af3wT+rI/W/qyx82dttHvrj8KfpezvRsGv4eFnnoyfgjrMS87jxWdoU8yJNvE+8iys17vO9sJl/xX22ekCeLcAvENndfvyC+2WkHpqjIf4s7y55Nl7xq8dmdYJzlH7rf7BTltULlWovYe6nfHG05O4D+6APngavR+qg42rPxD7bArwhvRx1dgk9gdifRuXij94iMWw+eP5A5VeUHX9wTWW/YFKPjSy/n6o/YF6Pef4BXUoXyPr7zdPno2bP9CbvydK2hTLH4jrq5LN3A8om1luF/niTO56/YW6QKgv7sfJJk/hi9uA9eNFZ4vx1b643vq1L6578dy+WXxxL6J5H8sX93U070P0wN+Aefyoo0d6ejR/iAB5ksJ3ZHyNncfyEtDLt5rHcljQ0xD0hfjicF4Pi5+eT8zqfxmN43ngz0RB2/F+TuCdd/DOEd4YeSzKhsP6J4gGq//lwobj/kU+IF0heSzNijQ3A2j+Kofm8w7N+T371qwvcAyfd+qX5bGw3MY2qLFUlMfyz6CNW81jUbaft/dc1b+lYuk93MoW4rkXSmvMeK35Elo32r31lyvSWhaPP0+0qnh8FWvQKPg1PPzMk/Hsi0NeHiGc+AxtCqWfcH7L98F6/Z3ki+P4ApXrw/C+B+C94axuX36h3RJST41x1iFwzWZfnJpLni/a+LUj0zrBHLXf6v9AoC/Os/fmAPcbzha3vyhf+EehD35jQB3M88UNJ5ekum+krI+r2m3sa8L6ni/uRol9UvzENZZtFyUfGll/PyhbzPMdjXK89ej37d42la2pVddz9v0iP2cIltrLV/JM8dNoHLf5W7YHV5WfbD8jPz1fHPcDymaW20X7S79BtozqL9QFPJscP6j4kOOLYz9WWZ4n++Ks/rtg/fivji/O2h7ib1PnICldkO3E1HmeKhbfg+X54lLmeSKd45rniesjz23PPsivEF4OmueJPmLWuVGnYx+et0+ifKM4XxpZ/3jZii/uOM17nE/si7OyzzjXff/PHT3S06P5cHzkSQrfkTqLBHFi/Av3Q48vmJ79teOLU7qJWne8M4Magr4QXxzKvmHxU/m0mV+mwPH8nci0PcRtnBd4lxy884RX+eKUfoB4mR6cl6o+x6ds+g+BhrcXxF8hH5Au9sUpmpsVaW4G0Dzt0Dzn0Jzfs28Nz+pQY4brs3+e4bMPFtugxhL74jZ9R9DGJwr8jc1Mz+H1diZ5kmVh+75ltiL7t9S64uFWthDPvVBay3QgPmfD04GWSmjdaPfWX6lI66qoj2v5EtGK9Nm7ap+/UfBrePiZJ+PZF4e8PE448RnaFMuiTRz3eS+s18fP9cI9Tu9gn50ugHcK4C2e0+3LL7RbQuqpMc46BK7Z7Isr8+8Wjf8dmdYJ2Ldp9S8ImVjV3kM/oPHG05O4D1agDz6D3q/qyxy3uC/PN1LWx4PuH7REfc8XN0pfhxd3pPSCquuPskHUOTQcF6f8gLgmeb6jUY63mLEeg/p+83vOZdhKnOEo87i9+ev5fvOrKj+9c5I8Xxz3A8pmlttFvrjPIFsm1plrf3T79fuUvrjPgfXjZeeK8dW+uN76tS+ue/Hcvll8cS+jeR/LF/cWmvec159fHN/6pzCPv+pc8fs3Q47q14BeXueo9tPD/PoWGsfKn+PlqA7qA/wWxxenfKaIN1aO6r9w/FrjmqP6XQ7NJxya8/uQ851POPXLclR5Tcc2qLFUlKP6WscXp3zgMXNUvX13xK9kaNH51gjLiwuKnRvA+pfnNy2Lb9lo99aPfY5ZiN9w2DmqyMvQHNV50SbWu38W1uufJl9c0Rlr+f2pAnj/BuC9/ZxuX36h3RJSb6s5qmV+iKLxX5SjWrQ/8dZAX5yXo4pxym8/V9z+otyEJ6AP/nRAHWw75qhW9TUNGqeUXzdDjqoXp4QyXdknpwhWnaNavp579t4FglXnqJbzk3NUkZ+xclQngAZc0/6UbJlYOaovc3xxODd5fQjxxVn9/w7rx8T5YnzW9q3mqKpcD6NV6ZVbOX+kQbi9/AwFy/PFxfADMi2ZoNPeG52s1L44XB95bnv2QX6F8FL1Y4vqI+94jmL/qf1v3lvC+eTlqPbklZ3vpTGWL+5TB/DFfd757vvT54vfvxl8ca1O+2tfXJgv7g4ax8Pyxd0B/TQqX9wRoGG7+OJOODTfKL64M9DG2hdXTOswfXE83kfhiwuldaNdjtujtWyvlWlVe61NwsM847aovW8cX+x/eiqs+Z93vhcu+4s8f57VXRPwQnSI7fD9A09f9c5Iya+q45h9SThuvO8fbMY9Z8Pnj+dLGub3D1h+1t8/KF+P2F7xZLzyTdxs3z8Y1JeUX88m3GyboTzML17fjYem83Gdopjbx0EfivX9gyJ/1ued123Msq35sw4MwZ/1xbCGvbr2Z/XAqv1ZT161PwvK0J/16kT+rD8/dP2+ij/rozCPv/km92d9R+3PquTPet2I/FmvGwN/1g9sQ3/Wj9wE/qyfqP1ZdWwZlN1osWW/Cuv1O8gXNUhs2a8AvN88r9uXX2i3hNTbLrFlvyFk4lZiy37zfHH7i2LLfhv64KMD6mB1bFkdW1bHltWxZbH5ebPEln00kS/up8kmT+GL+3tYPw7MFeOrfXG99WtfXPfiuX2z+OJsvjSy/vGyFV/cP6d5H6IHvnyu+/7hueL3b4bvHxzttH/cvn+AetKw+HlK0MP8OkvjWPnijgg4dj+oL+4s9NNWv39g7Qz9/oHVvwA0DPv7B4rmZgDNyw7Npxya8/sQX9wpp37Z9w+KfFGol4R8/+AKtHGr3z84BWWe/515gvWRJ+zfUr4CD7eyhXjuhdJa5os7RbRW9cV54z32uRxbjS1DWjfa5bi38q2GKrFluIaExpapdYf9T8+DNf/lc71wPX/eBJVZ3RcIeCE6BK7Z43p+/zBjy9hXguPmiMOfUcaWebE7Smfy5o5n26NM8vRrDzfKVM/3Ma7n95etCVXXI8+XxDJe7UWH+pKMxnHzJZ0qaVNVfhbF6uUXx5Z5e5P5xeu78bAotqxo//WloA95sWVV/FlFezQvn9NtzLLqdi1+Q+CTHH8W+4IGPbfsn8Ia9l2OPyvWuWWeH1zpZp7cvNn9WcOR19vLn4V+VvZNoN7F/iycTywTcJyiP+u7Evmz7h3An/VxmMevvcn9WT9U+7Mq+bN+ckT+rJ8cA3/Wm7ahP+vnbwJ/1i/V/qzanwVltT+r35/1H2HN/3gEf9b/J+DV/qzan1X7s6rzs/ZnxeXnze7P+psh+rM+nsif9YHbrt+HxGcN6s9qXujiO3yhGJ/nz+L4rFOCzkHjs2p/1vWr9mdt3Z8VGp8Vst7ifGlk/eNlK/6sX6V5r+YT27ifCfP4ngvF7xue6ax/PqbwsRif0dehfNoqN6VnjNGzU502Kp+VWt/wGY+LpqCnIegL8VnhuB0WP9VcYX7N01hdBv54vi+Wj4h32cG7RHiVz0rZpIi3aL+jyGc1RzRY/WWgIcT/g3SxDa9oPlKR5iMBNF92aJ53aM7v2QdlfYFjeN6pz37XsrUT2+D5xHhMPg3ayD6rOUEzzuH1diZ5kmVh63eZ7sD+ilNO+8vWO9ZpY3/zZ55oVb6VUFp5vK9UpLXsu5dMq/ruZSitG+3h0jonaG1mxWMHcSmfFb7DOZBW/1NhXbc1vugd7Hf2WVndFwp4nn2jdCD+9tFx8R7CZ7mSZdX1I/T9v5r0I5SnPDdRX/L2Raao/ouBT19+oRgfywnUI3n8KBmi7CJeV9U4RZ7zuL4o6vPcQtw45i8GwPJ8BZdE/YsObqQL32XcTCd+I/dJXO1umfFmFHYRyqCpdm+7PXmTXyG8VP3YovrIO843xf5T3yxcoTKcT2wX4ThFu+jLad4rn2QDnnnzHr9L+Kgz73mf38reD/P4q5157PnoMQeXZWEKHd/4XHTmidHWzPrlCspYlv1f69hMKE88GaNsafZFIX0hNlNqG1Tx87ygh/n1GhrHSu8+LuDY/aC22mscm8lbQxU9OC89G4v3vb7dsT+OCz4gXaxDKpqbFWluBtD83Q7N5x2a83u2gZT9cd6pz7E/DJ/jO7ANaiyxzWT1X+fYTMpXgXN4vZ1JnmRZ2NqubF/ly1EylNvv7SnkF9tM8xVpDf3udohveL6E1o12b/3lirTGsO/Uvk+j4Nfw8DNPxk9BHeblccKJz3CvZUm0ifXun4P1+o1k77DvE/tsogDezwC8d1zQ7csvtFtC6qkxzjoErtl8hkxZPEbR+N+RaZ2gyI/0S0Imqn0wa4faB5sD3O+4UNz+IlvqV6AP3j+gDubFSYzyjBRv37qsjweNTWqJ+t4ZMjfKPrTip4o1VjbPBME6IWDhmuTt649yvPXo9+3eNpWtqVXXc+OR4ief+7eVM3mMxnGbv96ZMPlVlZ9sdyM/p6gMZTP3A8pmlttFMQrvT2ST3zqEGIUPwfoxOV+Mr45R6K1fxyh0L57bN0uMgs2XRtY/XqrOe4xR+Mit1+9t7KC8Yl3X2tsswMn+AiWbvHGufFfKN+jl4nm4UaayXu75NhStobGJSgc+HwBrK+sT88nzX6RaG/dm/XOE99PYzsD+PEV1Oa77uGivGqeMi/Hg31h/l4DvxRY26L38qjov7d18Xn5jwLyczvrbn8Lvam1E/6c6M7QpeNITX03PTnZkmvJjKz7iM5a304KehqBvULk1LXCHyi3vTNUQuYXtZrl1vCKtyl5Str8adyeojHOisAxhFtGgfKb5tdHulmP9ZRgv793QMIt8ptbHo7MDFy5tJztwK99qGo4dqPk5zLNEi+LlPRmEsHB88rzG+HE1Tw0ey9RnwRxhPyH6TtiGbVakfZA1beNW3cYiubze7q0fW9YZfiXP2F5UuNW3tqz+qYq0lumTbNsqOyGUVl7vzlektUzOMK2e/llG68aQaT0saG1mxWMHcSk90vOrW/0Xd+ZsPke+ar6YHu8MA/aL4h6LZ0uxPn3VWWNVPADKT2+NHVJO2qJaE3DM8JrgjQ9rK9Yv8+2zHw99CyxT1Bqr1gTFT6NxFPxEGkPWWBV/4vHfW2PVPorHT5Xjx7QWxXSzzWn1X+Gssd5e3ISAjXPea0foeotwJ8mGVPoDr1dFPl2UJ1j/a0B2fYxkF/aPjVPlm0V9kfs4hT1rc7Lo3A48G4LnMM5/3qP9JseeVeuWkjPe2TsNQV+IPav8zZ4dUeZv5pgL5W/2cKv9OQ+3R2tZzIUXn4vvIh7V7xeo7jzVVd9lUDhZ50S+NqlMxWVOE+2p5ojFp+IcQZzL1H6MZ8X42Cl69v3OHFF9j894jnix1kgfj+H8Wm/31r8IeBVurq/4g/HRSwXt/2FoP8cE4jtqLJ8gmFb/xwDmegemGl88hhD2sMaQmptVx9BPOWNIyRt85o0hT1Zw7PDSCHin+rIq734+4hqlzv9ROnej4Nfw8LMmwVqNCOtiRFiXIsK6LGDZWLsCzyOOtZUQWhH/DNEamZ7FBuEzepg/zLv7Ba0tUcb2wv0Cz/0CT0uUPasdH5aSSZfpPZzn7MPDsf0wwcScEotRUfbcQ533cn3+t8kuwdjEEL+91f/ChS7M/0Q2gtK71dq1SmW4jlykMtRTDIbNpURjd4HHLsptxMlnZOHcxnE/Rc/e68htpQOrfCSVC8Rxx6wTI+8SyaHVQeVQIh3YlUNKlzD+3J+GnhWj5wFBj+rnff/7356sv8+QPoM1Ce+vt6//KjnEMSwohzjXDPVgzjHFNZPPFJoraZ/JtL0OfZ6uZP2ibH7PTuW6ebmKTRpUB/DiCMtk9EdJRisbQsVKsA3x9+DH+Vvh02kIOqr6puzdHO6vHbx+r2T9XAGNL4F15BPzxe+zja1sju1uR+/o8CKGHb0k6GkI+tR4snvjJ879YfHzoqCH+dVa6G3XZeCPsk2PEx8uCbyXHbyXCK+y9718cNUX1s6iPeFVosHqHwQaOJ9OnR+DdLEvUdF8viLN5wNoPixoTjzGLnNfK54wfhwHOEcuOfXZ78LwL1N95JEaqyzTrf5R4CHnGK4Kmj1/lzo/QOlCzEOsj3zw9PlLWTluHIfsQ75ckVbP3kT8ewV9V7Jy3EjrRru3/v0VaVU6IOp1l4lWpM/enRV4GgW/hoefeWsI5xgiLzkeHZ/hntQV0aYpqn8Z9IHlhV64y/QO9tmpAngXAd4zFnT78gvzMULqqTHOOgrqBCFzSenFPAZ3ZFrnuETtt/pPFzJXfQ+AdfqmgI288fQw7oMN6IOX0PuhOh76h/IL981R/8uvSSiLt5YsLVY9U6Ssj3lMKDmDY3xT7xH1vRzDlRHyZ8nhj9I7qq4/ag1X/jH2Eyr/ivK1jdt467Ef2r1tKltTq67n7ANAfnJ+jbK1lTxT/DQax23+XixpU1V+cq6R8t8q2cz9gHhZbqPvAte0l5CtpPqrKE4Jy/Bd9FUo3y/ryGV+jCIfwZfA+vH1C8X4UviaWW8N9R9afaULoh7EsYqoV90fAMvLiyvTKxm30iuZlkzQae+NTlbqHENcH3luh+5HebxU/dii+si7qj5Y3icK8cHi+MX50sj6x0vVeY9nTfA+kvf9qPxab/fWV/vSTXhWNebXyyEOyY/zYgrnK9Ia83ybMlpD4sI8WmPGhZXRutEeLq1HBK0qtovP5eHxnIl32N60+t8Pa9VbForpYdmL45Xzds4DrglRn31FVv+HwPZ7b8GZW00BM79Gn1u1WNme8MaHtRXrl8UZ8pklqBewTFE5fqFnlgxnjUwfR6/4j3zi2AZ1jpbHT+8MMlyb1Bwp+u7Umx3/CK59PBbU+RU45712NEQ71N4awn2I9tYQP/dD7Dwlo2nQvPetnFvHuNW6zrSofHJuz3FBz2EBS9lcvI8UK7a/4fQx8+SYwOmtnUqHOUZ1EDeuVfMBsDw7pOo5K0gX+7PtvSlBJ7dHreGHBSyll/P3LWP18Zcd6G3rDNTjMwCwPSn2XW1O4P4n4pwB/vEc6slxpmfvdfaxZ7J+PuIz3oOYFvQMS84hPtYtvXNBVG4AyzvU5ZCujXa3HOv/mdDllC4xpDztldRn+oTaUGqviseJGnNevorxsGh/2+DxuP8fji7hnR10uCLtoXJnBtoxf0DDDbXXq841ta6fErSp9YZ1a4Ub+cI28HxFWsvG2imi1bPXy2jdGDKtM4JWJc+RRjVGsqxY7k1R/Z2L13/zcXfHYjE9nr1+jGhRuYxe7rPV393BXyY3ja7EcvNK1fNC1PjwcufKxgfbYCpGz5M9np9M2WDYRyw3rf4h6COWm8rnYmXHBGwcc147BpGhf7X/+r1ng02LdqfQ3aztqLupPOem4JXd59cUPTsBfcG6m9KB1fmKymZiPeiYgOXZL0qusozIL9U3LBPVuPHymw2+54fLL5Pt7IebC5RBRtcodLdhnqfA8xjlU8iZRZ4fyHhY5Afi/H+rf9mRQWrNCjk3LpbN+Ib9Gu5WdDdvrpXZSRyng/OJ/RQKt3fGzlxFWkPHmrLN5ivSujFkWpWvQuluoefW4DvWZ1NU/3mgu714sZgetnmVTGW+otzE+kW626cGys0hnWNbWXfzbKD8qjo+jGdKbvK8U7LnGDzjeYfn0qo+Yrlp9f+RIzfVtzeVTEVZ9+LF8nYMIkNfQrob8h5jYVGmh8pXRaMnB9SeAM4tPlcFeRXil0T7sWh9DKW1TO/yzltj39qxElpDzjDbSozAMaLVixEoozX1WsC0qnWrmfWPZc7RR1hYD+/ZLrP6L4e14LWLvXCbRAPy8hzRjuN3gspwLFms+Ojscx0j6Mn42Od5Wvu8eL7R+X01f6Yd/ijbu6qPXq0VIXs2CrfSPRU/cS8mvyahLDU/e85Xbve2yVs78itEfiufjDqjimE1BSzkscfP4eho6cfnEYcHyCPvO13q7Die95g3c6xzj3LY65MGPPP0oybAvUT6kTrrmteTKYET3+X15IdgPbl9qRffMcELtU5bvWF9n9Lkb9H3KY22Zta/hvfsh9Gzf+342dScVWuK8oOyzoX0qfERsndyTOC2+jH3Tsp83azLLlWktSx+cJ5oRV5yjtsxwMHtOp0Vt5n9jcirJpUp3/ywzvmyWLfQc74wNq4np4Kevc0Z91XP+fLGEtLH4zK/1tu99VcBr8LN9RV/MHZ7vqD9vwrt59xxfEeNzxME0+q/E2DyWXE4vngMpT7vTPFIzbeqY+g/OGNIyRB85o0hnv9YhvoL83VYvFN9WZV373Z4p2yTOYd36lxtFQvSKPg1PPysSbBWIsLaTufOJT7fKvisOMM/Q7RGpmfzjCYvD1bx7oqgtSXKjsE9liGeKwJPS5Q9qx0flpJJl+g9nOdsC6vzE1TukNkhxj+0aR7qvPfkd8TI1lD7nyq/g33E/3ypC/MvaU9B5UKptWuFykJz+wyGzaVEY3eBxy7KbcTJeSg4t3vy1ejZ3ztyu+rZQCqHZ1a8NyQ5FHxWHMuhRDqwK4eULjGMMz3zfyr/U/UznhWn8jQRlndWnMqtVXKIcxFRD+acZ1wzQ86Kw/aZTPNkh9KVQs6KU3rjOJ0VVySjDy5138F2hMbJWf07QUYfgvvbCX6sfJYL5G9Sui3T+A1A15Gl4vfZxlY2x3a3o091XoxhR88LehqCPjWe+AxtnPvD4qc6P5f5NU/jWJ0HtiTgWP2LAu8lB+9FwqvsfZV/iHi5LzbPCSyov0I0WP1loIHPilsSfEC62D+oaD5fkebzATRfFjQnHmOXua8VTxg/jgOcIxed+ux3Yfh85gTySI1VlulW/+nAQz4rbkXQ7Pm71Fk9ShdiHmJ9db6sktF8bojC7Z2VdakiraHnLu0V9PG5fmVnPm20e+tfqUhr2Xkil4hWdZ7IrMDTKPg1PPzMW0OmoA7zkvP58BnuM10WbZqi+p8O+sCnLvXC5bPIsM+OFcB7IcB7ZEm3L7/wXJ2QemqMs46izjrz5pLSi3kM7si0znGR2m/1P1vIXBWvxTp9U8BG3nh6GPfB49AH3zCgjof+ofzCfWjU//JrEspS70Njn00B3pA+5jEx6Nld+eXFkSyPkD/zDn+U3lF1/VFruPKPHSNYyr+ifG3jNt68s83K1tSq6zn7AJCfvCetbG0lzxQ/R3mWoTd/V0vaVJWfnJuu/LdKNnvneLLcVrFlKHe9/lJ5YOyrwHfRV6H8N6wjl/kx+KwHq/+tsH78iIMvha+56AzpLAuTWWVnFnPMvXdmsYLl5eyU6ZWMW+mVTEsm6LT3Ricr9VlxuD7y3A7dj/J4qfpRfc+Iv3UU6oPlfaIQHyyOX5wvjax/vFSd95hP8JGCmP7Q+Po6fylO/lJIrJdHa+o8eS/XKjWthwWtqXOt3gZr1e8tFdMzjFyrXwHbj8+KUzGEBjO/xvUb4Z494Y0PayvWL4sd5PwmdY4cjxeEpeIcR7dGLibPg1D8V+fmhJxTMKxct//s+EcGyXX7vaXydjREO8py3X5i3/V7FcvNbbOyh5e77//RUvH75gtUsoj3gk7Re2udvxe2eHE/4p6MkrvNrH989eS707P3O3trOK7UWPPi/5FXTB/3N94P6xvqip9zgh7m10doHKs9pWMCjt3PC7xLDt55wqv21pQ8QrxMjzq7BOuzvWn1/8rZWzsm+IB0Vcl3DKW5GUDzx5y9tURj7DL3teKJGm9eHLeqf4zoZ/hF5yuH6kubfbTc5SHvramzdQ1mfq23e+srm8E7M7PMZuBzlbA9bDN4+Yj5FZJz4dFapjd5fhg+X9rTGfJro91b39tfV7R6PlHEr3w/9q6K12kU/BoefhaSQ9bM+nl5jHDiM9xb877ZY/VvB33gwHIv3GP0DvbZdAG82wDe8WXdvvxCP2RIPTXGWUdBnYBz2QbNOSo6X6ZoX+sekBesO+IYsHaoPED0pRpvPD2M++AU9MHD9H6ojuflaA/nXPDqOdplfVzVd1B09mR+jWuO9hGHP1XPbA6NlVSxAXymlvID4Zrk2cKjHG/jcl4W+39Cz01X/DQax23+zpW0qSo/2f+uYleUbOZ+UDnanBuVX7immdz1+qsBz0LjaT+fbH5lBzDOqUzbOk0ox/ovgPXjc5eL8YWcCeP53r2YYKNV6ZWezCr71kODcKNetRIAy/NFl+mVjFvplUxLJujEXI4ncbW7ZcORlXpvLeY3O7x9duSl2gfjmBh1fqc6B4P3z9SZQl4+Kc6XRtY/XqrOezy34aEBfH2/A/P4Hw+oB94ovr6Xgl5e+/r66WF+vZLG8bB8fa+EfhqVr++fCRuO+3fcfH1fL2iufX3VfH2vqX19ta8Pym40X9+PgD7wAxV8fecK4L0B4L0x0Nf3xhvI1/eTkX19bxzA1/cz0Ae/U/v6Nq/a19ff3lS+vnMEq/b1bc3Xd5Zg1b6+8fb1/U4iX9/EEHx9fwjrx0drX18PrNrX9+RV+/qgDPW1jyby9f1R6/p9FV/f1ZXu+x+/yX19zQ4val9fmK9v90pvnWH5+nZDP43K19cCGraLr+9WQXPt66vm67sLeFj7+opprX19vXIEfw0PPxsHX98K6APzK71wj9E72GcXCuAtAbynrej25RfaRSH1touv7wEhc7fi6zPeVPH1PQh9cJXer319vpypfX0+P0N9fRcIVu3r25qv7zTBqn194+3ru0q2Uixf32vJ5i/KMeb1oYqv7wth/fialWJ8nq/vGJWpca50QfZX1r6+fjprX1+Xl1v19R2DMvb14XzitU6du4DzpZH1j5et+PpeTvMe28S6ro2BZgFO9keotXkCnlU9T8M7nyDkPI2Qb8qH0hq65u7NivvVg7WVMyeYT0jXUmLc3G51zizXZTuD+wPL2I/COHicMi7Gg3+rNQjheet2g97Lr6rzEnPrP7b3+r3ng/fG+i54VnWe8XrizTPP56hwe7qtwq1kJdOixg+3R/WxOkdIyXbu41g617udPmaco+CzB8v7FmSZbGTcSjYyLVOCziKZX9THvNZ64yVWH7/Z6WOjZ1rQk2J/xtqI+yTHBN1NwZMe+4qevc3Z71J8VHq22uv05HqI/qHmzJzA7Y1btc6oOcNreuiZZiFzRtEa6mPy1mE1/9j2QpgTBTRMCRrya6PdLcf6/y+MFz4DytuvyS/vDKjh+B8WLlU9s9OzHa2tWD90H0HZKCzHlG6AY8fz5wznjF7NT88/VraPE2K7e2dqIa+LZBDCwvHJ89pg78h8XZ1l6h87/n7UTVhvmahI+yBr2iv39sK19hTJ5fV2b33VH56sK5sPht/zf3i4vf67WJHW0POy9wr6ir7HUEQrr3eXKtJa9j0CptX7HkEZrRtDpnVe0NrMiscO4poXNKjvUPH+5cfAv3nrajE93j7wTqJFfZMD6xd9k+N/OWus+iYHrkfeGmvtGMW5gDHPzi07A5l9fXhGcdEZ0ghLfTdE8dNoHAU/Y57brvjvnTOOvObzrBU/ve9QqG//qG8zTlH9/Z0btcYq/72V7RSwcc577QhdbxHuN++5fq/8eebnGZdvLRttStZ63xk7An2x1e8F7xL0eOuU5yuruveC+PgMd7WGKD2AbUn8jsqEoMvW1imqfx/w9L0w959sS7uLYzjfOlhYUTII9SuWQZ4ulV9VdQT+FgfKoBCfl/oWB4+rHZmWf+zHsvrLjgxSZ/6rPecQ2kPlDsaEruzRcEP1fLU3V3WuLQvabM4sQhmvyQo38oV154sVaS3T8735fakirRtDpnVO0NrMivsDcc0JGvAd6zOOKX52h0H5uPuHq8X0sJ6PY4D3tlBPnxD1WXe2+s8LlJvov82vSSiLKDevjPobT8Yz/saTmndK9izCsxDdDfuI5abV/wxHbnrfDFa6Co45rx2DyNDndAaOGsvWD6a7sa91rfP3whavBrUddTe1jqjY4J4YDHr2eETdrSnoaQgaQvbAymLHrc9U37BMxPcWqQzlG8dMePZ7fplsZ73giwJlkNE1Ct1tXL77FaL/ePajislW6xyP+1c4MghlGNuPuyrSPojc+bvdGm6o7rYo6KgaF6LkuM2ZBSjjOalwq5heb557tJbF8vH89mL5ymjdGDKtSldqZsX9gbiU7obvWJ+x7vYa0N1+wNHd2E+PY4D38lFPnBD1WXez+t+xDXQ3HDMsN9X4wPpVx4fxTOlGPO+U7FmAZyFyE/uoSG5+vyM3UR9hvVPlCOCY89oxiAw90JGhap98F7XNyvZd7L7/o6vF79s+nZonuI/NPEmhF1qfheqF2Mc4Pqbo2U9F1Au9HE9vbcN74yfKtGHxc1HQw/z6BRrHy8CfiYK2473S75cdvEuEV+VBY/8q3jI91s6iPGheQ6z+LwmZwP2LfEC62JejaG5WpLkZQPMTgubEY+wy97XiiRpvNg5wjiw59eeIfobP4wp5pMYqr9dW/9eAh5wHvSBoRhmx3u6tr3QxLy6kTGc1/CFx1Aq3t3YuV6Q1ps66XELrRru3/mpFWkNtObUvYu/OCjyNgl/Dw8+8NWQK6jAvPd0YbTcvJsDq/zHoxn+w2gu3SD/K76cL4P0hwPtvq7p9+YU5YyH11BhnHQV1Ao5TKPvOYdH4L4qL4rxyq/9nju6IY4BjfXcK2MgbTw/jPvgQ9IHpe1V1PKNH2SajzKPEPpsCvCF9XNX/xrYJ1vfyoIcTg1I9b1fpHVXXH7WGK981f99ExRoov/u4jbce+6Hd26ayNbXqes4xKMhP/r6Jit9W8kzx02gct/m7WNKmqvwsOscA11clm7kfUDaz3MZ9TVzTTO56/YW6gGfz27s53P/SUVRNZis7gHGG5kFb/dvBRzB/sRiftd3Lk1FrC+utnp6v9EpPZsXIRfZgeb7QMr2ScSu9kmnJBJ323uhkpc6DjpljoHip+lHtt3AcDerErHOjTsd7OMpXqPZPUF+bp3kfKw/6bTTvQ3x9r4d5vDqgHnij+Pqe0ml/7esL8/U9RON4WL6+h6CfRuXrew7QsF18fc8XNNe+vmq+vk8DHta+vmJaa19frxzBX8PDz8bB1/dFoA+85GIvXM/Xd64A3hcCvJdf1O3LL7SLQuptF1/fPxEydyu+vpdfLG5/ka/vK6EPXl/7+jav2tfX395Uvj7+vknt69uar4+/b1L7+sbb1/f6RL6+r3B8fZyDZWMm1Ndn9X8E1o+3VfD14Rjl2EnPD6h0Wk9Gn4VnVfXQBuG+0c48NN7UZx6G+fqUzaT8gCxL1DqI86WR9Y+Xrfj6XkjzHuca+/qsbO5S9/1/e7H4fdYDca7ieGJ+pfBNGc+LvseB3xngPupZW+jZrzu+PiWblV7UErwrOlsu1NeH42hY/FwQ9DC//hONY+XPOS/g2P2iwOt932SR8Cpfn5ebruixdhb5+jjH3ur/ruPrOy/44J1vomhuVqS5GUDzex1fX6Ixdpn7WvFEjTd1XpanA7DNyvCLzgdFvQdhsK/P6v+J4+ubFzSjjFhv99ZXtpant3i2BOJXMpp9owq35+tYqkhrqN2s9LuQ75sgrRvt3vorFWmN+X0TxNMo+DU8/MxbQ9jXh7xk/yI+C/2+idX/e9Dr/4Z8fexLwj67UADv7wDejku6ffmFdlFIvUF9Vd5c8nKxVE4Iwuf87821sNOWMl8f6447BWzkjaeHcR9Mg443R++H6nier2849oT2FWCfTQHekD6O5XvJL8/XN5ycLM2fsw5/lN5Rdf1Ra7iKdeDvm6i9c7XXNG7jzfNNla2pVddzL3bkNME6K2ApeTZuvmhv/i6UtKkqP41Hip+er8/bh2G5XeTrM7nr9RfqAp7Nb+/mcPc7vj62G2zMhPr6rP4KrB+fdKkYH/v6Tgua1T4cn+mr5oAno0/Ds6p6aINwe3po7Bxnxq38jExLJui099TcNt6Mwtfn5QN7a21+hfBS9WOL6iPvQnx9qA95ebqsC6g4VZwvjax/vGzF1/ehTmC3mmvs67Oyr4d5/CmXit/n81tYR1zr/L2wxcvaZ3xFPxDiNNqaWX8/9Oxl0rNPB92b/XkoMzw50sr65RyvvUhfiD8vtX9U8VPF3DG/HqGxugD8mShoO94P6kd8BPqp6veKmR5rZ9XvFV8Vdhr3r/Jr5lfI+fw7K9K8M4Dmzxc0j+v3ilUc3LxT/zTRz/BDchYQRtH3iv9P4GHI94pRRqy3e+srm8bTD5T9pfYxlIzmfVyFG8ch+zO8+FJFa6itovS7orjMIlo32sOlVflJm1lxfyCu84IGfAd1bqz/KliLv/5SL1x+B3nJfjar+7UCHtsy+WU2SZm98vW0Fqj1sgHPPL3F3s3h/mPSW1TcRINoK7JXdkI51n8N8OKHLxXjY5sE9UJv7vH4UT54o1Xpud6ZlqntlZ0O7nGwV/Dc5/yahLKb1V5BXXgnlSnZpWyS01Sm/HY4XxpZ/3ipOu93AtyHad43RT173+RVswDneru3vvKleOuD0s88PzjOffapKNwob3ndja0jsAxTNqqHG2mtkoOiaE2tIyCtG+1y3B6tMc71a2b9Yxl5xm3BesqeZP3+bbCOfYB0hCbRoPqd2zKV9fPlk9oa9wcA9xOOz8/mrtpz4zNDOcaA+5nnCuc0cR1ul9V/J+j0vw8yPr9wrUE/R35NtnvpW+s8X9jSNfp9K+OdinG1sTdu+1ZNhz8Tor3eXFe6K/r3eV/Ak/cKN64B3j7LKMcb8oD5qdYwz6ceun56ftNG1t9v3vo5Ot+25ifSGMJPrF+Vn0U5YPnF9hzqUtwPKI9R5/tAIh/1LsdHbbSxHfsZl7vvf9jxUfO6o/zF5gvjGJG1zt8LW7x4fUe/p4rLUD6FnnWAnn3U8V+rMab27pVM4zwRpC/Ef41zeFj8nBf0ML8+QeNYxRyeFXBYP6ma8/4Jx3+t9FjEy/RYO4v816zzbPphL3dpYP/1WcEHpIv1fs9GCaW5GUDzLkFz4jF2mfta8USNN/QLKtumKK+mUQC/yN5BXxfCYP/1pn0CPHyi4MyBZqZlxHq7t76yNT09wIt36aFRtIf9956dm19FtkEoraGxXZ695+FGWjfavfWXK9IaI09e6X2Ngl/Dw8+8NYTjUZGXHAOLz1AHUWc3cH7KvaAPHL/cC5fjHbHPpgvgnQJ4i5d1+/ILfeEh9dQYZx1Fnb3jzSVv/0ad96H2x9g2viBkrtId2SYq0h2NN54exn2wAn3wGfR+qI5n9IybXRAzt3rQ+MD88uJRR5kr7dmhSu+ouv6oNVzl4/E5k1vJlR7lePP8SGVratX13Mtv5Fx+5XNR8mzc/E7e/J0vaVNVfvKeDPKT41FDYk6V3FZ7vyh3vf5CXSB0f3fC2ecpivGoGo/6ObB+vOxyMb6QfRy1tmx1f7eOR71+1fGoYfu7qHsX+fqQHrW/y/O+aH/3ZTTvY/n6/qjToVV8fe+HefxVA+qBN4qv72tAL699ff30ML++hcbxsHx93wL9NCpf37/Yhr6+76p9fX08r+rre13t66t9fVB2o/n6fg70gTdW8PVdKID3MwDvHYG+vnfcQL6+X4rs63vHAL6+X4E+eH/t69u8al9ff3tT+fo497z29W3N1zdDsGpf33j7+t6fyNf3WrL5m4Jue9/GTKivz+p/CNaPySvF+NjXh2OUY6Q9P6CXk6Zk9Aw8q6qHNgi3p4cqWJ6vL4afkWnJBJ32nprbxptR+PpwPvLcrnomr/ftauRli+oj70J8fcpmUn5AliVqHcT50sj6x8tWfH1fTvMe5xr7+qzspVe6789cKX6f9UCcqziemF8pfFOp8tL3ddofIy99RtDTEPSF+PpwHA2Ln3OCHubXnTSOVe7xaQHH7i8IvJ6P8QLhHWVe+j1AQ4q89GZFmpsBNJ8UNA8rL/2CwxM13mwc4By54NTnfQ2Gz+Nq0Lz0c8DDFHnpnt5yQdRHPni5sSHnfHm+jvmKtFb1SyJ9IX5JLy89tj4Y4pecFXgaBb+Gh595awj7+pQNg22yZ8pnhO/z3t8zQR942pVeuOxLwj47VwDvQYD3vCu6ffmFdlFIvUF9Vd5cUvlCPAZ3ZFrnYF+n1X+OkLnKnmTdcZeAjbzx9DDugxdAH7x0QB3P8/UNx56ofo5iWR+H5PTiGGebH+t7vr5Rnos44/BH6R1V1x+1hreyYvnQyPr7wdtrGrfx5vmmytbUqus5+5GQnxwnOSNgheY/jtIX7c3fuZI2VeWn8Ujx0/P1efswLLeLfH0vJVtJ9RfqAp7Nb+/mcJcdXx/bDYP6+r4S1o9vH9DXN01lym+ictWL4hyyLI4e2iDcnh4a+9wFxq3OXWBaMkGnvTduvj6cjzy3vbU2v0J4qfqR9+GQdyG+PpSrF6hM+aeVjxDt829P5OvbM90L1+hG2xPPiFlv99Yv22tg/nu56Gp+Kz+/h3sanrHufa4irUqvQf2D5Q3SV3Q2bxGtIb4cj1ZPZ1C0YjuKfCBFtG60h0vrtKDVsy2UvxbpV2M9E+/wPuiMqK/GLq97/zesewfv76Vf+danBexh+WuVHVjV//0mx/+t9BW17ioZa/WG5SNRuvpW8SCsZ7Wv/yp9hcfCBSpb6/y9sMWL11EcC8pPqvxGuAaz3+IdzlhQcmDO4d2EoEfxrkm8Sx3jrGKN5x3eoe7Ws49Jz94ZkXcqhlfFnQw6vtW+7FZhLUaEtRQR1rKAZWMN80AijrWVEFoR/wzRGpmexQbhM3qYP8w77xuNWMa6nvqG06rA0xJlJmdjwlJ785z3g/OcYarvHluZ+kat8Q/1mIc67+V6xfvIPlC5d0qH6zuf5/4uzD91fMQh+y6ePWplOD4NRuK5tMDjAOW2yuNqZv3jE8fEFD37sCO3VayJmi/Kt4TffC2TQ6tpeLcaKocM/7DkkJrTyg9g/LmYhp4Vo+eSoEf1877//W9P1t9nSJ/BmoT319vXf5Uc8mIRWUZV/f6Vp39g+0ymebJD6Zls8yj/q/LPKvgGI6aeo/gdKqN33N99B9uhZHR+z7EDVv8QyOhpsifxfbNplK3JsR2bfheAPXt/b5t3iTajTZsRLIN9TtDEeA8C3v0V8Tayfr4r3xX7xHYKmnO439tBqNY2zn+zshcC/XfcX/w+23Wjtk2Mtqq2ydFOG9Uap+anksXKruP4EqRPzRG7N37yuahrnb8Xtnh5/FwU9DC/ztJYXQb+KDnI+3JLAu+yg3eJ8KoYN7UPofzWDWrnjoL6RXlKF4AGjnFT8VxIV8iZ1acr0nw6gOZlQXPiMXaZ+1rxhPHjOMA5suTUZ3lUpCM0BI/UWOV1yurfDzzkGLcFQTPKiPV2b321b4N7pFVjsdhGwfaE5IjiOOR9huWKtMbIEQ2llefTSkVay76l7Nl3qxVp3WgPl9YFQavKiWUfF4/nTLzDcV1W/5NBb3gh6VH8DvY758ta3U8R8Lz4N5V/wDbCnHgP4bNcyS9vP471ZHwX9WRlOxTJsiIduijW8EXApy9z8KXwc7B8CbVdrf5FUR/nFu+h4pi/GADLy9NUdu1FBzfShe8ybqYTv7v+JK52twz9RPk1CWWpYxFQBk21e3njyZv8CuGl6scW1UfeVbX/2ecaYv/j+MX50sj6x0vVeY/5hu8jf2NI/vnvwTx+xf3F77MtjDYpxlWyLExhQ1hfFZ0xZLQ1s/6+7ckRpmdtxyZTsQ/4zMtV45hLpI/3+/F+WHuXip8XBD3Mr2+icbwA/JkoaDveqz3TBQfvPOEd5IwhpgfXTVW/yF/xGscmOyf4gHRVPWMohOZmAM3f4dhkicaY+z1M5ZPksYRzZN6pf47oZ/g8rpBHaqwWnTH0fY5NNidoRhmx3u6tHzsunnUtbA/H6HkxuvnFNtlCRVrLYi4vEK1K9/Nwe/NpqSKtZbngrKd6Z06W0brRLsft0Vpm6zKtytZtEh7mmZqDWVa8rrFN9lOgU/we2WRsd7H/Fsus7psEvBAdRcWvKX14lHkhXh6+GsdV8/Cx/zkvBMfNOYc/CyPkj5eXoHQyb+6odRZlJMcZq3MDPNwoU708j1GOtx79t93bprI1oep6ZDziPC0l41VcM/LY46fROAp+Io0h/FQ2Qyg/i86wzS/eX1ZnLnp5xRgrPyHqFOWyvxv0od+nvErcL+WxMO2067RoF8p+b8w0RBtVDP9ZaO+LaL+yKJ6Z1zxlL3DujtX/Y1jD/ub+YnxenDmf06NyIgc9p8cblzf7OT3Gm/qcHp2D4/k+OOcH51PIeovzpZH1j5eq8x5zdy7v6oWr7LeqZ8QiHVVz4EJ85R5uz35brEhrzDNiy2gNsd88WstkBNPq2W9ltG60h0urio9VMh7PPGGYHLfFYz0T73hxJFlWPHbZ59R64Prvk/7lB3rpV3Frw4rrUfEgXlzPkuATttee3dZpY4y4HhWXMSveaxT8Gh5+5sXIcixejLh/FQ/5rPb1X7W/x2Nhu8Yxn3TGQtU45tOCHsU71FWY1hS8uyh4t+rwDvc6Lwre2bPzEXl3TtDjxYBXHd+zoj1bhXUpIqzLEWFdEbBsrN0PzyOOteDcHcM/Q7RGpmczZv5+oof5w7x7QNDaEmWs6z0g8Dwg8LREmcnZmLCUfXCF3sN5zrY/jm3O3bkM7/FahHoMxoU/64HuO7iOo42udDj2Qb8NdJXnkK6CugHLXxUf4sVvWBmOT4OReC4t8DhAuY04jbZm1j8+cUxM0bP/w5HbODe8+dLK+vlq9ULk0ANpeBecu2P4hyWH1JxWcTPGn6ekoWczd+epgh7Vz5i7g32G9BksL3cH5RDH4KAcYhmF8UCrVIZrJvtWl0vax7k7SnYoPZNtHrW/p/b/FHyDEVPPUfwOldFfQDLa2qFkdH7P++9W/6tARn8RyWgVT+DFJ7Mv+6UA+0sf6G3zedFmtGkzgsXx8EgD430F4P3yingbWT/fle+KfWJF5+TsJV+4soO4T94C9P/TB4rfZ7tu1LYJ74eH2iZf56xxan4qWazsOo5FR/rUHMF9L5Znw+LnJUEP8+tbaaxeAf4oOcj7FZcF3isO3suEV8WJqbhdxMt9Ye3cUVD/ItFg9b8DaOA4sRXBB6SL/aKK5vmKNM8H0Pw9gubEY+wy97XiCePHcYBz5LJTn31JRTpCQ/BIjVVep6z+64GHHCd2UdCMMmK93VtfxTl7MeaXRX0V+6xk9OWsHDeOQ95nuFKRVs+GRvx7BX33V6SV59P9FWlVevb9Dq3Yjgcq0rrRHi6tFwWtzax47CCui4IGfAd1Paz/M6A3vIX0KH4H+51zDq3uzwt47OPOL87dQd8+2wjL4j2Ez3Ilv7z9ONaT8V3Uk5XtUCTLinRo9INg/SeAT787ZD8Hy5dQ29XqP0XUx7nFe6g45p8SAGvewa3s2qc4uJEufJdxM532nopFQD9Rfk1CWepYBJRBU+1e3njyJr9CeKn6sUX1kXdV7X/2uYbY/zh+cb40sv7xUnXeY4wD+zBVjgjGPYTkEDTgGfO/7Ixmw69iaUO+YaFi9zzcHq0x4t6Vj2AXlSFMPoNf7XWbToz++hR2l/kQivJk5oFvWB/v84t9Eh907FjFcyUbQ2JlkT7uv/xab/fWV/n78059xR8Vy8Dt/x+OfajyYrFdJwim1f8owFzvwFTji8dQ6ngHxSMv3iF0DH08YryD579T+ZnDyo9TvPPO9gzl3cRTinmnZOqcwzuVc618so2CX8PDz3gPczudKTkorBUBK7HPMniPm8+FSxQb454Lt+Lw7qKgVeliHFetfFsXBZ6WKOM97hiwlEzycr85ZxzHNu9xe/sn6LPH/ZMjT+m+U7Q+4bsb7W451v+xp3ZhHuvA9NankLMZVOynshkNxnb3/5915HZV/7/y34bIoUTnLwbvcRv+Yckhz/eNfE3sp97c41Y+VtXPuMdd5MfG/Q271tvXfz3dSMkhllEqj9XzbbF8KWof73Er+pSeifVQv1ffUUEYCr7BGHZMbJGMfgbJaBWHhPuuvHdg9S+DjN4gGY184HxXdf7djWy/Ps+RwzeD/foPoP2x7NdPB5g3g/36j5wxVNuvPu+u1vZrNFi1/VrbrzFhjZv92o5kv94ButHX1Pbrk1dV+/Wba/u1tl8FPbX92vvuzWa/viGS/fqvn9KF+aMEU53ZgfvavF+Oe8F4ZsfbOhu0Sr5fKKDrEKwdP/mU4vfZrla26rDOy1d5yuos5ap5yj/rrAHqnAJ1roRaAzh3TZ3jh2OIzw5N9J0bl5/Lgh7m19tpHK8Cf5RPg7+/tSLwrjp4VwivsvG9c+5UX+AZtKo+50VY/V8BGt5ecA498gHpCjnbYa4izXMBNL9T0Jx4jF3mvlY8Yfw4DlQ8sKrP/jqGz+fEI4/UWGU5bvV/E3jIMcxLgmaUEevt3voqZ8qLtSs755D1dHVGs4db2TfcH6G0lp0nHhJH6eFGWjfavfUvVaS1LDZ8lWhF+uzdWYGnUfBrePiZt4ZMQR3m5QLhxGf4nSNlx/M5le8HPeW/PKUXblGMcX5/vgDenwC8jzxFty+/MI44pJ4a46yjqG/oeHNJfT+Rx+COTOscHJtt9T8kZK46C471+GkBG3nj6WHcB38JfWD6XlUdzzsrFPW//JqEsnhriT5rsMcXC3hD+pjlQNm3Pfi8L6xv41LxZ3GE/Jl3+KP0jqrrj1rDVa46+wbV2VvqW3/jNt567Id2b5vK1tSq67nxSPGTzz9X9rWSZ4qfRuO4zV/vbL78qspPjoNHfk5RGcpm7gf1fTIvpwblrtdfobnJGCP/BsffW3TmXJHvoshHcAR8BKtPLcaXwr/Men6oz9Dql31bhs8PVTk7HizvmzpleiXjVnol05IJOu290clKnRvTcw5Yu5c3nn2QXyG8VP2oclUuUVmo35X3ukL8rjh+cb40sv7xUnXe4zcu2o6vrmge/zDM4wccPZBzQG5EX98zOu2vfX1hvr7n0jgelq/vudBPo/L1vQBo2C6+vhcKmmtfXzVf34uAh7Wvr5jW2td3/W/1a3j42Tj4+l4K+sAXP7UX7iC+vi8FeK98qm5ffqFdFFJPjXHWUVAnwG+wF82lFL6+rxQyt0X0Yjtagl7UHV/51OL2F/n6XgV98MMD6nhGT+3rq319WL/29YWvqbWvb/v4+lA2cz+gbA719f1wIl/fM4bg6/sJWD/+be3r64FV+/qevGpfH5ShvvZvE/n6OM/Z4tJDz8E5L+howDPmv8pTwTXd+x4XywXMYeH8OwVzOuvvtxR+MOMv+qMQJ387BmUf9ivH4v+241dU/YDPvPwfqzcr3msU/BoefsZ41Hm6SuYP+3s0Nu9C89twnUE7mW2k9zh9FON7NIp3O4l3o84vHTQ38E8i8m6noCdm3Hed39avP0QcazddfhvbYeOa34Zyx8tv20llg+a37YL3MHfiE6QP2fqKNgm+u9HulmP9r3xaF2azc+/lqNT5bf35bbd0+Fbnt9X5bUhPyvw25S+o89uulw87v61IRp94WvcdbIeS0fl9UX7b00FGnyYZje/z3pGVPaXzjs0F1Ksj+iUvevZTWttz6WKonCo66wHpnhFlk1ug9fLlx69du/r46uLqY8tLjy5e4TXbaOVn7Dso83mwzEtjQy4tK/8Y2hj5NQllc1Q2BWVGYz5WDxH9ac4pWVoO4T/ib4n6vK9Z9fwRxMO6byis/VnvuOW5zbJJ+bO8/Fd7N5c7b99x/b5KTNzLQW4942nF77PvY9T2u9FW1X5/tqMHqjVM6SvK94G8YvrUOmL3xk9c84fFzyVBD/PrU2l9VLFNal/d6i8LvCsO3mXCq+Le1H4q4uW+sHbuKKi/SDRY/U8DGjjubV7wAeliH7Siea4izXMBNP9DQXPiMXaZ+1rxhPHjOMA5suzU57WS4XPcF/JIjVXW5az+o8BDjntbFDSjjFhv99ZXcQen4RnrD2Xfgmc7HtvD+4cKtxf3s1KR1tAYkr2CvqIYxSJaN9rDpVXtjakYa/at8hjJxDscu2T1vxTWYluXi95R3/fmtf2fCHi855Ff/O2bon39lxfYSvml/FmstygZjTaYsktD9vURLvrYsP4/BV5815B9aKn39TmWreq+vmfPlO3rM+56X797Vd3XN16G7OuH+pZi7Ot/F817ZfuEzvs5gMv+8ZOdstB9/TOCjgY8Y/6rc4bOQB3Dr/buOZ9D4T4Jz3htPVuR1nOiPtJwhmg9CWX8nR5sI8cgIEzOfz8n8JkuifZsCnvFxgnaDedFG5tZvwzH8cl7KT/u2H+K5/iM7b8zgp6GoE/5gdbbvfXR/6pwc33FH5QJZwva/0bHrsJ3JkS7ThBMq/8zAJPPB1ZjdlrAHtYYOid4VHUM/aIzhtQ8V/4/NYY4Rg7LOH7i7Ah4p/qyKu+ecHinZOoZh3c7BT2z4r1Gwa/h4We8Pz4XEVbMuI4Y+TcGa0HASpzjGhw/YfhniNbI9GzuWypfzYLDO2UPKn2L/b7K5lUx9Co+geMnYsBSMol1RJznHD+BY5vjJ1R+V9ne3HtI71Trkxc/YfVf9vQuzD8i28/Tqby4TvXtQ2UXGoztni/+AUduV80XPyfoCZFDifyXwfEThn9YckjNaaWPJs5r3oyfUD431c8YP1GU94z58Hatt6//erqRkkNFeSk4T738SpYvRe3j+AlFn9IzsR7q9yh7lO2h4BsMjpm3MvVrMPkZz0vEESqjs6d338F2hMZPWP0dIKMnCGas/dHn0P6osgWYri8DuqafXvy+F9vPa8B2je1vddofI7b/nKCnIegL2TtNHYev+Kn2PPu+S0DjePMbn5n2afDeqYr/X3TwLhBe7xtAWaZ5y32BfnpVv/DMLKCB907PCz4gXeznUzSfqUjzmQCaTwiaE4+xy9zXiieMH8eBOn9D1Wd/HcNfpPrqWxwIg+W41T8LPOS90wuCZpQR6+3e+mp/Sek/zEOsr2JglIzmc2cUbmXfcH+E0urtdyJ+b6/Jw420brR76y9XpDU0d3uvoI/joxFPo+DX8PAzbw3hM0OQlxzriM9Qlik7forqPwP0gac+vRdu0bkg+f3pAnhrAO+5T9ftyy/chw2pp8Y46yioE+B5j0VzyYutM34VxavweSpW/2Ehc1tEL7ajJehdANzPfXpx+3mf3MqeD33wZQPqeEaP2r9E/S+/JqEs3lqizxzo8cUC3pA+Zjng+cVQ5rREfe/MkLkR8uecwx+ld1Rdf9Qa3sqK5UMj6+8HXsvyC22eJ+u0u++Pcrz12A/t3jaVralV13Pe90Z+niRYyr5W8syLmx63+evlXORXVX4ajxQ/+cwQlM3cDyibWW6jvwLXtC8r8CMgraExBps+hfw/kufqjAHGWeS7KPIRfAWsH//CwZfCv1wUN5plYTKrLN7QO2dsOQDWWQd3mV7JuJVeybRkgk57b3SyUscWeecBlcVDhvBS9aM6D4jPsgr1u/JeV4jfFccvzpdG1j9eqs57/BbYe2ifB9t0qnM/RWXvgnn83U8vfp/9T6n34m2Mhu7Fo1zp0W/o2escf17Vvfhdgp6GoI/9t3g/rNgixc/zgh7m14/SWFUxO2cEHKtfFrPDeOcIr/LnqXUS8XJfWDt3FNQvspH+b8efd0bwAelif56i+WRFmk8G0PxGx5+XaIxd5r5WPGH8OA5wjsw59XlPieGH6DYIo2hf5s2OP0/FuKGMWG/31ld7BCjbi+YL1lf2vJLRc1k5bhyH7M/w/OSKVs+2QfzK91Lkqy2iledTWRx+VTuAacV2LFSkdaM9XFpVbEEzKx47iOucoAHfsfHFc+Q3QG94F/kE+R0VP8N6yG8KeGxb5RfnbRwH2OyLOSXeQ/gsV/Kr6l6rvZvD/dyOwajik1mWoT6m1qSTUI71fw/49JGnF+PjuMpTUObJEG8esHxR4xR5XtWX1iTcKg/Fg3XSwV2298C41d4D05IJOjG250lc7W6Z8WYUdhfKoKl2L288eZNlYbxU/ajiAdl+Qp3+JJWhXGM/opJRyl7DMxU/QvP+pGhH6Lw/CXCfSfMe55rJLp7HL17rvv/XTy9+3+SbZ9Ntd5vsf0a0yU4JehqCvu1sk+1c623XsGwywztKm+yWtS4NKWyyXRVp3hVAc2utn+baJqtmkx1a6/IwhU3m6S3jZpN5tMa0ycr2AjfavfVj64MhecmzAk+j4Nfw8DNvDZmCOsxLzrfBZ0Vnc3AcltWfX7v+m8uWs2u9cAexp+YA3pU13b78QrsopJ4a46yjKJ3Om0vqfGweg0Xf7+Lcd6t/ce36r4qxQJuRdceTAjbypopv/Slr3fdfTO+H6nhGz+jsCb1Hi302BXhD+pjlgJIz6hwq76wGxR/8zt6w+XPK4Y/SO6quP2oN9/KVGll/P/Ball9eTMAox5sXs1K2plZdz739v2mCdUrAKjrv/8k67e77o4xZ8ebv+ZI2VeWn8Ujxk2MsUDZzP6j9Es9HiHLX669Qm9/effIch04Sj8lsZQcwziJfH8e0W/3PXevie+VaMT4+wwDXFi+/mvVWT89XeqUns8p82Oxv8/ztCpbnP4/hZ2RaMkGnvTduvr6Y8WiKl6ofOf4ReadipDg2Q8UoKT8gz3scp6iv2XxpZP3jpeq8x3yqP6B5H6IHfnit+/7XrhW/7+nRwz5Hwvgaeo4E9gOuH+wL+edr139TnSPREPSF+PpS56cpfs4Jephf37nW26554I+yh4p066I8LsZ7gfAqX5/SDxAv9wXOS1Wfcwis/veudWlgX99ZwQekK+R7SDMVaZ4JoPn71/ppTjzGLnNfK54wfhwHOEe8/T7eX2D4RXv6qPcgDPb1Wf0fXuvy8ImCPLpmpmXEeru3vtJN1f4B8xDrK70oJLbW04vzi30d8xVpDY0VD9Gx5kto3Wj31l+sSGuM3K9ZgadR8Gt4+Jm3hrCvD3nJOef4TH3nF9/nsznetnb9N5ctv7DWC5fjrdX3pBjeWwHeO9d0+/IL7aKQemqMs46COgH7+sr8x0Xjf0fm7yVwDuuvrl3/LfP1efYk+hmNN54exn3w62vd9z9M71f1lSp7AvW//JqEslH6XqrmC4XuT3hnV4ybL+WMwx+ld1Rdf9QaruLP2de3lfyfUY63Hvuh3dumsjU1lm85v+ezCVQsgpJnip9G47jNX8+3nF9V+cn2ufo+jZLN3A8qlq1s/8rkrtdfg8T1fQ/Z/DOCbsZZ5OvjeCCr/9G1Lr7dDxbjs7Z75/Eofx77+pTMtTYovdKTWanj+mYc3OMQ1zccWbm94vpUDJzy9XFcn8oPVL4+1NdsvjSy/vFSdd7PANyXDuDre96D3ff3P1j8/o2ST3V7p411PlVY7N5xGqvDit07Dv00qti900DDdsmnOidormP3qsXuLQEP63yqYlrrfKosKM7wRsyneujB67+5fDIdougd7PdJKrO6Dwt4fI5FfnE+FdoaoflUz6M1LZbd9e6OAzdlPtU/AD59wYPF+Op8qt76dT5V95pq9/LmZsmn+gKa97Hyqd5E8x7nmvW1lZ2GMo6DuhfKOFfqPihLYR8YD1FPR5xGWzPrlxk9/mR69rIOz5W9dS+8NyGeeXHuyCumz2CdBljr7d76aj/+Xqe+4g+O3dMF7f9qaD/bMfjOhGjXCYJp9dsAk7/lguOLxxDCHtYYulfwqOoYerUzhrCPVb97Y8jqqXnL/o403/r2eaf6sirvXuPwTsWWnnJ4t0vQEzOfJeZ+uYob3iqscxFhnRewEsfdBH/LxfDPZP1rbUR6Nr+hELpHxvGi+K7av5mEeyxDPCqWVOVtPKsdH5aSSbyfrHywrDvl18MEU527a/xDveehznu5HvPjD3bfKVqf8N2Ndrcc6z/zGV2YP9GB6a1PSv85Q2Woi7Btg+PTYAwrTjLVOf4/58ht5X9Q86WV9fPV6oXIoQtpeBf8LRfDPyw5pOa00keNP/Np6Nn8louyy1Q/78u633IpOo/eYHnfclG6kZJDLKNQD76PytS51yxfitpnMm2vQ5/SM7Ee6vcoe5TtoeAbjNmsn+ZGwa/B5Gc8LxFHqIz+Dw9238F2KBmd37OP2+r/fw92Yf5HghnLLt5FdrGyBZiuNVg7/vODxe+zXa1sVZunvG+w1vl7YYuX8cvGP64BiNNoa2b986Unr42evddZA+6D9ybEM28NQF4xfWoM2f2wcjkUP1XcJvPrz2gcq/2o+wQcXleL1nLGe57wKhtf5YggXu4LPBdZ1S863/iDQAPvVd4n+IB08d6KovlURZpPBdD8EUFz4jF2mfta8YTx4zjAOXLeqc/+OoZflKuAchxhsBy3+n8DPHyiIOekmWkZsd7ura/2qJX+wzzE+irnSslo3g9RuL1zFuYq0hoaV6lsipA8CaR1o91bf74irTHyJGYFnkbBr+HhZ94awrkHyMv7CCc+Qx+SsuOnqP5e0AdmntEL9z56B/tssgDeLMA7/AzdvvzC/cKQemqMs46COgHuWxbNJfSDFY3/ou9nFeV73dZpS9m3XFiPV7lkyBtPD+M+uAv6YI3eD9XxvG+5oP6XX5NQFm8tSR9bP+i5D/nl5R6MMlb+Xoc/Su+ouv6oNVztGbJvcCux8qMcb965GGVratX13Mtl51wOZV8reTZu5+B48/dcSZuq8tN4pPjJuQcom4vOElFyG/0VuKaZ3PX6C/0AbPOfFO1A/4Ty93LOcpnvoshH8CxYPz77GcX4UviXWc8P9Rla/bKYuZOE24uZU7BOO7jL9ErGrfRKpiUTdNp7o5OVOgYG10ee2559kF8hvFT92KL6/397V/Mi2VXFX3V11XRPf39MIoJuJjMm4qK+P8DFkO42Eb+zyEYXefXxFkpAwUSjBN4iexcKQsRFdoouwoAiioqKKIoMEtRkECQQ8A8QXEhAp2bqpH/16989773prqoRchmo6rrn3XPuueeee87v3vsGdVcUd+W9rjy4K9ovzpdSdNZeis7769Du92neo0+ysa5Q3cswj0ePh5+3tdqwgatQNw/8yfqIOBDyNNlWhE5QdxX67fMQezOep+6AqHtEu6QT1hXLx/gtfjd9Ml5+Y/p37ZzF0+c1IQ/r68uBNaosdMR9RPsMnUdhvteJr8LzPGxcjYX1M3T3IHTO86siT+PxRT2gXIznKZnXCsq8lkPmF4XMc7axHo+10gnzRztQ58UU/WWSn9vn82ioI2WrjOcZ/UugQ8bzHhEyo484Tmfp1fke3P8LzRekRz1wfID9uR5l81brCo9HXlnV/ofaA1Rx4aMFZT1JFyur2h9YicLjgbweETKou41sd9+Ctfhlwtn4Gd4bxTqj/bZoz9auS6fNnznPr876Yxveepl3jxLvTL48rVDvKWQfgHGM8uX8XkSjfwV08ZPHw/wsxtih57Pmnpfn8LxUOAfqnG1XYTLqvp+XR3ltefdgPPxC8Ua5+KwenwNEOe05la+YbpaRr6DfqKSzulHjqPZ/PV2qcVT5A+OMGAvzmTTlu/LcsVZnM3C+lKKz9lJ03uN7EZ+neZ8nX3n/0enzv3DyFfNvVqdyB4uLUF/ziL1N5xgDI0+TTa0vuC5yrPdbJ5e5Cs+VxW9sa5eFPCUhX55cZt7ntJU+rwt5WF+3yI7VnvxV0Q7HHKH7Gcz3A8RX5TIq7kG+PBaY7yv6aySD0b/m5DJXhR5QLs5lvJg2r8yrOWR+3cll5mRjPR5rpRPmj3aAc8SLARg/4fZD8THGPdgG5zJG/w8nl7kmZEYfcZzO0qvcxHvPiorRPWwY+8O5nJcXTQrnMo8WlNVby5G/h2N7vL359MGCsmbFZO/s2wv5QmdkQrKepNm8PVmz9l9YVuwHn9tW715VfQlhQWZfvBf+L8gNLL7g59mn27zFOqP9t2gvT4yCMYHFSSoexvhlUlbTWZluTH+vnavovTkvHlZ2XDQexvE3O1Tx8FVHP48uUT+XHf2omMybO2qdRR/J+xS4frD/VLzRp3p7wcu0t5n4N53tU9aaUHQ9Mh2ps1bs4xX2gTr29GkyLkOfKGMefaqcIa8+Ob9UZ7ZYn6UoH1bJ+DjThPDx90798UQ3t+nsFZ6fYFtYc/oVwsvM93s2cz94WZvyZoyl+Tw1rl8qX+AzekZ/DfLsDx+F+fH5MLXeKvyXsbTQ3RGce1GUz2/OGy/zcOYHAS9bjL/+/8LLEMddpTpcUxkvU3vt3nqL86UUnbWXovN+Fdrdo3m/A3RmBxWqexHm8eNH4ecRYy1N+2h188Bw9qbtIZaCPE22FaLH79hf++1J8O+Mie3Ac2XxG9vTupCnJOTLg4ntQ92i9Lkv5GF9PUW2egj6KYu+8xw9EHwPHb4HxFdhYji+Src8FtbPECa2RzIY/dMgA2NiO0IPKBfn8ErmzYIyb+aQ+bNC5jnbWI/HWumE+aMd4Bw5cOh3SH5u/5DoUUfKVhkTM/oB6JAxsT0hM/qI43SWfh/qjN7byzsQ9KgH46989EGUzRvtkGPmw4KyXhH0OAb7JCvKd6WgrDyfrhSU9SFBf8WRFfvxUEFZT9LFyronZF2JwraDvPaEDPiM2RfPkechbniRMDF+BsedMTGjfUG0x3tPk8JnEbahbRszq9sSz2H77FeiqHj8Zc9O2n2idO+7jQv6a56bGI+pNWkT6pH+JdDTd47C/NhPbEEd24/yIVaHMRf7V2WnqHO264cFPc4tzn3Q5h/O0damw/s9gv5hhzfKhc8yb5bTnlN5l/22jLwLfVAlndWN52+iKJ8u1TjuEj3qzurQd21SHfqhK1SH82mH6tBOzX5xvpSis/ZSdN5vQrtXnXnP+wNWt3F8+vwrzjzmPYAtIYPFd+gL55FDmJ4xlkeeJttKdNavoI9l3/89JydDf+L5mF2hO9QVy5cnJ5t3jqv0uSvkYX3dJDveB/2URd95/t5vLnjTycm8NVSNBc5LL4erEP2PnZxsKzqrB5SLY0gl83pBmddzyPwzJyebk431eKxD+fou9dHsAOfInkO/RfJz+6EcDuMebINzMqP/tZOTKawFfcRxOku/C3V5YgeVuyssSvnovSibN9oh52T7BWXNyh93SVaUL0/+iLKepLP0hwVlvYj8cUvwKQU+jQ//5q0hFaBhXW4RT/wN94MUpsFx/W2I6/9yNNsuY7c4ZuVAe69De28d6f5NCuZFeeiUjXOMgjEB6iE0l7bht5D9VyMdc4RwsDeFz1X7eNYPtY+3B7zfOgr3P5Sr/RPGYIPeAZw3xvPOeWD8NymrUHdxa4neJ8YxqwDfPGPMfsDDU9Dn7Ap67x0K20vUz6ajHxV3FF1/1BqucqoytbUt2sI1yTuXsEx7m8kf0tk+Za2pRddz05HSJ7+TQuWQyp8pfZqMD9r83c3oU1F9cl6P+qxQHfpmHgf0zey3FUaIftcbr/vJ+f82/a7uAXHekHXGInSXYR8wgseOw/w2SJbLQmZvT1hhfdvUB+WjvTMWWXEo421eHKra8vBzFYceOLxRLnyWebOc9tyDdsZiZv87ndVN1t5FHl2qcVTY2wHVbUDdOtUp7JpxfBULoJ1ifv4Yzft10Y+8834d2r05/T7Pce327mFEd2Wdtm++g8sq1CN9fdp/9AX2uXoOOZNuXE+acRK349GoNYz3qf0IdLcxB/5xt9kbNlrD7qDdjJudhfPvNQa1JGnFtaQ+ro26tYX3P2mNu41+3BwlybDR7y+a/7CXNDrNYb/b7zbi5hL6Xx83+8OkXr/DfTTothbNv9Pq1Hu9uDfsDJN+azhYNP9xf9RtDnvdQWM87La69UXzT9rtZq9TT1qNXqM1GowWzb/eGA3jQb3VGrZGjUFzuHD9t8dxpxfXB8lg1O0MFz7/2smg1m00Ot1xkgzuTIZF86+NWvV+bzy882/cbjYWbn+jXqtVi0ft4R0DvDMWnYWP/6DV7w76w3ZtVOvX+80s/pP47EMUi9haHcoHGNMz+mcgH/jB9LvFK1XgXwp8RlE+/LMKNBwPXhKyY1xykt77tP0NvAt+Y/pZO1epJyYP502Ym6+RPtYCtJPy8XSW9rJD+wmi3XBoP0W0mw7tp6e0pjfElm9MP2vnKvHYbKUCMtn4Tsb8WbLTbZC3LJ5lOzX6H4KdfpHyVnzebFC9Z6NKdFUhC46x2V2F6J+b8lf7RionqMBvbPvqfgbm4WvUH+wD25TNo68tUL4yyXdJyKdyWeM551y2pXJZ1EElzd9fpZ8NQY/rA78nA/PVS45+FvT+EamfiqOfS6K/Re0HbaRM+kHdVakO1x6e87z+TcpH0lMa9tVG/w3wK98NrKmlSPsH3lcyeUP3w1gGo/8mzNfbtJdfJRluTP+una/01VywwvdKUfdWh3a8QnVqr9PqEHfBtZUL4xKoi4mePgexCtNZUWO6QjyyxrQCbTE9tsd29QqMKZ/PYLu6Mf27dr7SUXGbFavj9zVjneoX2wnOWWUnRcfUdFFkTC1OndigwqBL9N0wPBVzTAqv80b/qrOOevtnk1J0P9LkUbg57+/bGP7IkS/rnEVRbJ3XeYWtm3xmK6+Bb/3p8Wn7KEtV9Jf3380u/wzt/fx4lsZs8BbQ/JJozGf9CWh+RTTmu/4INL8JyK5yhNCduN9N25j33SzOHdkWUCY7f6J0H0Vn5w7b0MfSe5+8/4fPTfR3+zhMt/MA0XEd+4NJeSK996l0h7oJtbXntLUXaKsUnR23KAqPXd7+co71d7D5tynH4r07rEPfyzmW8r3qvBfr+s2CvvcizoJ4vtdry+Od5VfZ7yu/urxzKDo/QB1U0vz9VfrJ2lf1zuGjvbN+9peon4s8x6T06Z11QN3xGR5cE3g+qzM83hlSdW55R7TP8/o/Ii5WGOE2tP92AENCWStCVoVNYbvPgiwXhaeWT07bf4bs4kHDU41+DXgoejvjbs+EMNJJ+eSUNgsX3CCfrs6zeLig0ceg7+3p9zy4IOYzeXBBzJN5zTL6gyl/tWYZzUqgTb5HoHAlD2dRZ5A2RB+98zweb7Rd9gVbBWVV81ed11fnWtmvmK2/z9H9RcvHmKw6X+bx9vCGnYKyeucUkb+K4+zZJeKz3WWfy2SMEddWD59dzDlLrR8Pn62K/nr2o/Bc9IcbpB9l6w+a/VQd/Xj9VfpRvhB14OH73v5HdYn6uUh8fy1DP95dCD7DW4K6ovg+xyRGfwzxwVMnus1SpNfkovg+y2D0T8LatCB8P2ZsFovC8EtUh2suY8G4FjK+j+vLefD9/+bEgnlMFb7vjanC9zE2DOH7T8OYvovv3ytZ+H7eMbW8CfF9Zav2Hc9A5MH3jX7sxIxGsxJok+N1FTPi2sF+U8V5OHf4jL06r8wx8Bec/uwUlC8rruQYWMWVEfGpir5wPG92+BXw2186mW2PMXbMPz+TztYZ7XM0R+f1XgOFv2OcxPMJdfPCSTE6zoW/Djq7Sbmw2stVc4tzYdS1shueW0af5sjHVgJt5rlT790TuYicyOON/ovXk72Css4bmz7PfRr2QUXvdSMmwXo6LCjrRd3rvvt8elq3oDs1Mg5HHVTS/P1V+sl6vxfH4fhuHQ9HP1yifrz3mitcxbMfNS+9O0B592GWaT9bjn6y/FbR+8DefUsPB9haon48+1F4qWc/Kr7DHGmf9KPWFJXnhv4PV+SDa+NHA/2oRhr3Db0r6lWRv6i9BXwH+M0AZo+y5t2HwXZtL+DCz9U36r1ap9Gut0bjetJqLvpcfyMedOPGIO6P+s16r71w/v1uMoxH/VHSbSZxEi/8XlurHXeHcbde77fq41a9vfB7Ze3OYHhHiNq4PvmzkcX/nTMS6Wk9+rJJuTT9295zxfSIFyD97yE2/wP4qbu0gt+E7g2HrhT4vNuG+G01nf1tPT1LX07P0hvvy+lZGa1uA+rQz07K5vRv1Be2ZXJUiP6vkL9Myho8Y8/vCv5rxH9GbvEb+nluqyx+wz3MW+S3sO8XuLbVTbYqtY+/sWxvAIZy4X6t1+v0G4NaqzsaJqPF+9VW0o07SbfWboxa48Yo06/9D79gg5/1fQoA",
  "debug_symbols": "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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_recursive<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) {\n    if low < high {\n        let pivot_index = partition(arr, low, high, sortfn);\n        if pivot_index > 0 {\n            quicksort_recursive(arr, low, pivot_index - 1, sortfn);\n        }\n        quicksort_recursive(arr, pivot_index + 1, high, sortfn);\n    }\n}\n\npub(crate) unconstrained fn quicksort<T, Env, let N: u32>(\n    _arr: [T; N],\n    sortfn: fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = _arr;\n    if arr.len() <= 1 {} else {\n        quicksort_recursive(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "6": {
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n",
      "path": "std/collections/bounded_vec.nr"
    },
    "7": {
      "source": "use crate::cmp::Eq;\nuse crate::collections::bounded_vec::BoundedVec;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// We use load factor alpha_max = 0.75.\n// Upon exceeding it, assert will fail in order to inform the user\n// about performance degradation, so that he can adjust the capacity.\nglobal MAX_LOAD_FACTOR_NUMERATOR: u32 = 3;\nglobal MAX_LOAD_FACTOR_DEN0MINATOR: u32 = 4;\n\n/// `HashMap<Key, Value, MaxLen, Hasher>` is used to efficiently store and look up key-value pairs.\n///\n/// `HashMap` is a bounded type which can store anywhere from zero to `MaxLen` total elements.\n/// Note that due to hash collisions, the actual maximum number of elements stored by any particular\n/// hashmap is likely lower than `MaxLen`. This is true even with cryptographic hash functions since\n/// every hash value will be performed modulo `MaxLen`.\n///\n/// Example:\n///\n/// ```noir\n/// // Create a mapping from Fields to u32s with a maximum length of 12\n/// // using a poseidon2 hasher\n/// use std::hash::poseidon2::Poseidon2Hasher;\n/// let mut map: HashMap<Field, u32, 12, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n///\n/// map.insert(1, 2);\n/// map.insert(3, 4);\n///\n/// let two = map.get(1).unwrap();\n/// ```\npub struct HashMap<K, V, let N: u32, B> {\n    _table: [Slot<K, V>; N],\n\n    /// Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the HashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, let N: u32, B> HashMap<K, V, N, B> {\n    /// Creates a hashmap with an existing `BuildHasher`. This can be used to ensure multiple\n    /// hashmaps are created with the same hasher instance.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    /// let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::with_hasher(my_hasher);\n    /// assert(hashmap.is_empty());\n    /// ```\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = [Slot::default(); N];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    /// Clears the hashmap, removing all key-value pairs from it.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// assert(!map.is_empty());\n    /// map.clear();\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = [Slot::default(); N];\n        self._len = 0;\n    }\n\n    /// Returns `true` if the hashmap contains the given key. Unlike `get`, this will not also return\n    /// the value associated with the key.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// if map.contains_key(7) {\n    ///     let value = map.get(7);\n    ///     assert(value.is_some());\n    /// } else {\n    ///     println(\"No value for key 7!\");\n    /// }\n    /// ```\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        self.get(key).is_some()\n    }\n\n    /// Returns `true` if the length of the hash map is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// assert(map.is_empty());\n    ///\n    /// map.insert(1, 2);\n    /// assert(!map.is_empty());\n    ///\n    /// map.remove(1);\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    /// Returns a vector of each key-value pair present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let entries = map.entries();\n    ///\n    /// // The length of a hashmap may not be compile-time known, so we\n    /// // need to loop over its capacity instead\n    /// for i in 0..map.capacity() {\n    ///     if i < entries.len() {\n    ///         let (key, value) = entries.get(i);\n    ///         println(f\"{key} -> {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:entries\n    pub fn entries(self) -> BoundedVec<(K, V), N> {\n        // docs:end:entries\n        let mut entries = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries.push(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    /// Returns a vector of each key present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let keys = map.keys();\n    ///\n    /// for i in 0..keys.max_len() {\n    ///     if i < keys.len() {\n    ///         let key = keys.get_unchecked(i);\n    ///         let value = map.get(key).unwrap_unchecked();\n    ///         println(f\"{key} -> {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:keys\n    pub fn keys(self) -> BoundedVec<K, N> {\n        // docs:end:keys\n        let mut keys = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys.push(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    /// Returns a vector of each value present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let values = map.values();\n    ///\n    /// for i in 0..values.max_len() {\n    ///     if i < values.len() {\n    ///         let value = values.get_unchecked(i);\n    ///         println(f\"Found value {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:values\n    pub fn values(self) -> BoundedVec<V, N> {\n        // docs:end:values\n        let mut values = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values.push(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    /// Iterates through each key-value pair of the HashMap, setting each key-value pair to the\n    /// result returned from the given function.\n    ///\n    /// Note that since keys can be mutated, the HashMap needs to be rebuilt as it is iterated\n    /// through. If this is not desired, use `iter_values_mut` if only values need to be mutated,\n    /// or `entries` if neither keys nor values need to be mutated.\n    ///\n    /// The iteration order is left unspecified. As a result, if two keys are mutated to become\n    /// equal, which of the two values that will be present for the key in the resulting map is also unspecified.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Add 1 to each key in the map, and double the value associated with that key.\n    /// map.iter_mut(|k, v| (k + 1, v * 2));\n    /// ```\n    // docs:start:iter_mut\n    pub fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = HashMap::with_hasher(self._build_hasher);\n\n        for i in 0..N {\n            if i < self._len {\n                let entry = entries.get_unchecked(i);\n                let (key, value) = f(entry.0, entry.1);\n                new_map.insert(key, value);\n            }\n        }\n\n        self._table = new_map._table;\n    }\n\n    /// Iterates through the HashMap, mutating each key to the result returned from\n    /// the given function.\n    ///\n    /// Note that since keys can be mutated, the HashMap needs to be rebuilt as it is iterated\n    /// through. If only iteration is desired and the keys are not intended to be mutated,\n    /// prefer using `entries` instead.\n    ///\n    /// The iteration order is left unspecified. As a result, if two keys are mutated to become\n    /// equal, which of the two values that will be present for the key in the resulting map is also unspecified.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Double each key, leaving the value associated with that key untouched\n    /// map.iter_keys_mut(|k| k * 2);\n    /// ```\n    // docs:start:iter_keys_mut\n    pub fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = HashMap::with_hasher(self._build_hasher);\n\n        for i in 0..N {\n            if i < self._len {\n                let entry = entries.get_unchecked(i);\n                let (key, value) = (f(entry.0), entry.1);\n                new_map.insert(key, value);\n            }\n        }\n\n        self._table = new_map._table;\n    }\n\n    /// Iterates through the HashMap, applying the given function to each value and mutating the\n    /// value to equal the result. This function is more efficient than `iter_mut` and `iter_keys_mut`\n    /// because the keys are untouched and the underlying hashmap thus does not need to be reordered.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Halve each value\n    /// map.iter_values_mut(|v| v / 2);\n    /// ```\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..N {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    /// Retains only the key-value pairs for which the given function returns true.\n    /// Any key-value pairs for which the function returns false will be removed from the map.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// map.retain(|k, v| (k != 0) & (v != 0));\n    /// ```\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..N {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    /// Returns the current length of this hash map.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // This is equivalent to checking map.is_empty()\n    /// assert(map.len() == 0);\n    ///\n    /// map.insert(1, 2);\n    /// map.insert(3, 4);\n    /// map.insert(5, 6);\n    /// assert(map.len() == 3);\n    ///\n    /// // 3 was already present as a key in the hash map, so the length is unchanged\n    /// map.insert(3, 7);\n    /// assert(map.len() == 3);\n    ///\n    /// map.remove(1);\n    /// assert(map.len() == 2);\n    /// ```\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    /// Returns the maximum capacity of this hashmap. This is always equal to the capacity\n    /// specified in the hashmap's type.\n    ///\n    /// Unlike hashmaps in general purpose programming languages, hashmaps in Noir have a\n    /// static capacity that does not increase as the map grows larger. Thus, this capacity\n    /// is also the maximum possible element count that can be inserted into the hashmap.\n    /// Due to hash collisions (modulo the hashmap length), it is likely the actual maximum\n    /// element count will be lower than the full capacity.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_map: HashMap<Field, Field, 42, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// assert(empty_map.len() == 0);\n    /// assert(empty_map.capacity() == 42);\n    /// ```\n    // docs:start:capacity\n    pub fn capacity(_self: Self) -> u32 {\n        // docs:end:capacity\n        N\n    }\n\n    /// Retrieves a value from the hashmap, returning `Option::none()` if it was not found.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn get_example(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    ///     let x = map.get(12);\n    ///\n    ///     if x.is_some() {\n    ///         assert(x.unwrap() == 42);\n    ///     }\n    /// }\n    /// ```\n    // docs:start:get\n    pub fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let slot = self._table[index];\n\n                // Not marked as deleted and has key-value.\n                if slot.is_valid() {\n                    let (current_key, value) = slot.key_value_unchecked();\n                    if current_key == key {\n                        result = Option::some(value);\n                        should_break = true;\n                    }\n                }\n            }\n        }\n\n        result\n    }\n\n    /// Inserts a new key-value pair into the map. If the key was already in the map, its\n    /// previous value will be overridden with the newly provided one.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// map.insert(12, 42);\n    /// assert(map.len() == 1);\n    /// ```\n    // docs:start:insert\n    pub fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.assert_load_factor();\n\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let mut slot = self._table[index];\n                let mut insert = false;\n\n                // Either marked as deleted or has unset key-value.\n                if slot.is_available() {\n                    insert = true;\n                    self._len += 1;\n                } else {\n                    let (current_key, _) = slot.key_value_unchecked();\n                    if current_key == key {\n                        insert = true;\n                    }\n                }\n\n                if insert {\n                    slot.set(key, value);\n                    self._table[index] = slot;\n                    should_break = true;\n                }\n            }\n        }\n    }\n\n    /// Removes the given key-value pair from the map. If the key was not already present\n    /// in the map, this does nothing.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// map.insert(12, 42);\n    /// assert(!map.is_empty());\n    ///\n    /// map.remove(12);\n    /// assert(map.is_empty());\n    ///\n    /// // If a key was not present in the map, remove does nothing\n    /// map.remove(12);\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:remove\n    pub fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let mut slot = self._table[index];\n\n                // Not marked as deleted and has key-value.\n                if slot.is_valid() {\n                    let (current_key, _) = slot.key_value_unchecked();\n                    if current_key == key {\n                        slot.mark_deleted();\n                        self._table[index] = slot;\n                        self._len -= 1;\n                        should_break = true;\n                    }\n                }\n            }\n        }\n    }\n\n    // Apply HashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(_self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % N\n    }\n\n    // Amount of elements in the table in relation to available slots exceeds alpha_max.\n    // To avoid a comparatively more expensive division operation\n    // we conduct cross-multiplication instead.\n    // n / m >= MAX_LOAD_FACTOR_NUMERATOR / MAX_LOAD_FACTOR_DEN0MINATOR\n    // n * MAX_LOAD_FACTOR_DEN0MINATOR >= m * MAX_LOAD_FACTOR_NUMERATOR\n    fn assert_load_factor(self) {\n        let lhs = self._len * MAX_LOAD_FACTOR_DEN0MINATOR;\n        let rhs = self._table.len() * MAX_LOAD_FACTOR_NUMERATOR;\n        let exceeded = lhs >= rhs;\n        assert(!exceeded, \"Load factor is exceeded, consider increasing the capacity.\");\n    }\n}\n\n// Equality class on HashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, let N: u32, B, H> Eq for HashMap<K, V, N, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    /// Checks if two HashMaps are equal.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map1: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// let mut map2: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    ///\n    /// map1.insert(1, 2);\n    /// map1.insert(3, 4);\n    ///\n    /// map2.insert(3, 4);\n    /// map2.insert(1, 2);\n    ///\n    /// assert(map1 == map2);\n    /// ```\n    fn eq(self, other: HashMap<K, V, N, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    let other_value = other.get(key);\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, let N: u32, B, H> Default for HashMap<K, V, N, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    /// Constructs an empty HashMap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// assert(hashmap.is_empty());\n    /// ```\n    fn default() -> Self {\n        // docs:end:default\n        let _build_hasher = B::default();\n        let map: HashMap<K, V, N, B> = HashMap::with_hasher(_build_hasher);\n        map\n    }\n}\n",
      "path": "std/collections/map.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "50": {
      "source": "mod utils;\n\nuse std::collections::map::HashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\nuse utils::cut;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_CAP: u32 = 8;\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> HashMap<K, V, HASHMAP_CAP, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> HashMap<K, V, HASHMAP_CAP, BuildHasherDefault<Poseidon2Hasher>> HashMap::default();\n\nfn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nfn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"HashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"HashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nfn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"HashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nfn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"HashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nfn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    for entry in input {\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"HashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nfn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"HashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nfn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"HashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"HashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nfn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = cut(hashmap.keys()).sort_via(K_CMP);\n    let values: [V; 3] = cut(hashmap.values()).sort_via(V_CMP);\n    let entries: [(K, V); 3] = cut(hashmap.entries()).sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nfn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = cut(hashmap.keys()).sort_via(K_CMP);\n    let values: [V; 3] = cut(hashmap.values()).sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = cut(hashmap.entries()).sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib hashmap documentation\nfn doc_tests() {\n    // docs:start:default_example\n    let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> =\n        HashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: HashMap<Field, Field, 42, BuildHasherDefault<Poseidon2Hasher>> =\n        HashMap::default();\n    assert(empty_map.len() == 0);\n    assert(empty_map.capacity() == 42);\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    let mut map2: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    let x = map.get(12);\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries.get(i);\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for i in 0..keys.max_len() {\n        if i < keys.len() {\n            let key = keys.get_unchecked(i);\n            let value = map.get(key).unwrap_unchecked();\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for i in 0..values.max_len() {\n        if i < values.len() {\n            let value = values.get_unchecked(i);\n            println(f\"Found value {value}\");\n        }\n    }\n    // docs:end:values_example\n}\n\nfn iter_examples(mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    },
    "51": {
      "source": "// Compile-time: cuts the M first elements from the BoundedVec<T, N>.\npub(crate) fn cut<T, let N: u32, let M: u32>(input: BoundedVec<T, N>) -> [T; M] {\n    assert(M < N, \"M should be less than N.\");\n\n    let mut new = BoundedVec::new();\n    for i in 0..M {\n        new.push(input.get(i));\n    }\n    new.storage()\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
