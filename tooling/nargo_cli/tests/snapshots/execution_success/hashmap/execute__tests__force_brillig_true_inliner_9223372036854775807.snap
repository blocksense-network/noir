---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "955212737754845985": {
        "error_kind": "string",
        "string": "HashMap should have retained 2 elements."
      },
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "5727012404371710682": {
        "error_kind": "string",
        "string": "push out of bounds"
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "6895136539169241630": {
        "error_kind": "string",
        "string": "HashMaps should not be equal."
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "9417307514377997680": {
        "error_kind": "string",
        "string": "HashMap after one insert should have a length of 1 element."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12389747999246339213": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14479745468926698352": {
        "error_kind": "string",
        "string": "HashMap after one insert and corresponding removal should be empty."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16567169223151679177": {
        "error_kind": "string",
        "string": "HashMaps should be equal."
      },
      "16850003084350092401": {
        "error_kind": "string",
        "string": "Load factor is exceeded, consider increasing the capacity."
      },
      "16954218183513903507": {
        "error_kind": "string",
        "string": "Attempted to read past end of BoundedVec"
      },
      "17677620431177272765": {
        "error_kind": "string",
        "string": "HashMap length is invalid."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_recursive<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) {\n    if low < high {\n        let pivot_index = partition(arr, low, high, sortfn);\n        if pivot_index > 0 {\n            quicksort_recursive(arr, low, pivot_index - 1, sortfn);\n        }\n        quicksort_recursive(arr, pivot_index + 1, high, sortfn);\n    }\n}\n\npub(crate) unconstrained fn quicksort<T, Env, let N: u32>(\n    _arr: [T; N],\n    sortfn: fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = _arr;\n    if arr.len() <= 1 {} else {\n        quicksort_recursive(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "6": {
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n",
      "path": "std/collections/bounded_vec.nr"
    },
    "7": {
      "source": "use crate::cmp::Eq;\nuse crate::collections::bounded_vec::BoundedVec;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// We use load factor alpha_max = 0.75.\n// Upon exceeding it, assert will fail in order to inform the user\n// about performance degradation, so that he can adjust the capacity.\nglobal MAX_LOAD_FACTOR_NUMERATOR: u32 = 3;\nglobal MAX_LOAD_FACTOR_DEN0MINATOR: u32 = 4;\n\n/// `HashMap<Key, Value, MaxLen, Hasher>` is used to efficiently store and look up key-value pairs.\n///\n/// `HashMap` is a bounded type which can store anywhere from zero to `MaxLen` total elements.\n/// Note that due to hash collisions, the actual maximum number of elements stored by any particular\n/// hashmap is likely lower than `MaxLen`. This is true even with cryptographic hash functions since\n/// every hash value will be performed modulo `MaxLen`.\n///\n/// Example:\n///\n/// ```noir\n/// // Create a mapping from Fields to u32s with a maximum length of 12\n/// // using a poseidon2 hasher\n/// use std::hash::poseidon2::Poseidon2Hasher;\n/// let mut map: HashMap<Field, u32, 12, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n///\n/// map.insert(1, 2);\n/// map.insert(3, 4);\n///\n/// let two = map.get(1).unwrap();\n/// ```\npub struct HashMap<K, V, let N: u32, B> {\n    _table: [Slot<K, V>; N],\n\n    /// Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the HashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, let N: u32, B> HashMap<K, V, N, B> {\n    /// Creates a hashmap with an existing `BuildHasher`. This can be used to ensure multiple\n    /// hashmaps are created with the same hasher instance.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    /// let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::with_hasher(my_hasher);\n    /// assert(hashmap.is_empty());\n    /// ```\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = [Slot::default(); N];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    /// Clears the hashmap, removing all key-value pairs from it.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// assert(!map.is_empty());\n    /// map.clear();\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = [Slot::default(); N];\n        self._len = 0;\n    }\n\n    /// Returns `true` if the hashmap contains the given key. Unlike `get`, this will not also return\n    /// the value associated with the key.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// if map.contains_key(7) {\n    ///     let value = map.get(7);\n    ///     assert(value.is_some());\n    /// } else {\n    ///     println(\"No value for key 7!\");\n    /// }\n    /// ```\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        self.get(key).is_some()\n    }\n\n    /// Returns `true` if the length of the hash map is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// assert(map.is_empty());\n    ///\n    /// map.insert(1, 2);\n    /// assert(!map.is_empty());\n    ///\n    /// map.remove(1);\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    /// Returns a vector of each key-value pair present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let entries = map.entries();\n    ///\n    /// // The length of a hashmap may not be compile-time known, so we\n    /// // need to loop over its capacity instead\n    /// for i in 0..map.capacity() {\n    ///     if i < entries.len() {\n    ///         let (key, value) = entries.get(i);\n    ///         println(f\"{key} -> {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:entries\n    pub fn entries(self) -> BoundedVec<(K, V), N> {\n        // docs:end:entries\n        let mut entries = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries.push(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    /// Returns a vector of each key present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let keys = map.keys();\n    ///\n    /// for i in 0..keys.max_len() {\n    ///     if i < keys.len() {\n    ///         let key = keys.get_unchecked(i);\n    ///         let value = map.get(key).unwrap_unchecked();\n    ///         println(f\"{key} -> {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:keys\n    pub fn keys(self) -> BoundedVec<K, N> {\n        // docs:end:keys\n        let mut keys = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys.push(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    /// Returns a vector of each value present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let values = map.values();\n    ///\n    /// for i in 0..values.max_len() {\n    ///     if i < values.len() {\n    ///         let value = values.get_unchecked(i);\n    ///         println(f\"Found value {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:values\n    pub fn values(self) -> BoundedVec<V, N> {\n        // docs:end:values\n        let mut values = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values.push(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    /// Iterates through each key-value pair of the HashMap, setting each key-value pair to the\n    /// result returned from the given function.\n    ///\n    /// Note that since keys can be mutated, the HashMap needs to be rebuilt as it is iterated\n    /// through. If this is not desired, use `iter_values_mut` if only values need to be mutated,\n    /// or `entries` if neither keys nor values need to be mutated.\n    ///\n    /// The iteration order is left unspecified. As a result, if two keys are mutated to become\n    /// equal, which of the two values that will be present for the key in the resulting map is also unspecified.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Add 1 to each key in the map, and double the value associated with that key.\n    /// map.iter_mut(|k, v| (k + 1, v * 2));\n    /// ```\n    // docs:start:iter_mut\n    pub fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = HashMap::with_hasher(self._build_hasher);\n\n        for i in 0..N {\n            if i < self._len {\n                let entry = entries.get_unchecked(i);\n                let (key, value) = f(entry.0, entry.1);\n                new_map.insert(key, value);\n            }\n        }\n\n        self._table = new_map._table;\n    }\n\n    /// Iterates through the HashMap, mutating each key to the result returned from\n    /// the given function.\n    ///\n    /// Note that since keys can be mutated, the HashMap needs to be rebuilt as it is iterated\n    /// through. If only iteration is desired and the keys are not intended to be mutated,\n    /// prefer using `entries` instead.\n    ///\n    /// The iteration order is left unspecified. As a result, if two keys are mutated to become\n    /// equal, which of the two values that will be present for the key in the resulting map is also unspecified.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Double each key, leaving the value associated with that key untouched\n    /// map.iter_keys_mut(|k| k * 2);\n    /// ```\n    // docs:start:iter_keys_mut\n    pub fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = HashMap::with_hasher(self._build_hasher);\n\n        for i in 0..N {\n            if i < self._len {\n                let entry = entries.get_unchecked(i);\n                let (key, value) = (f(entry.0), entry.1);\n                new_map.insert(key, value);\n            }\n        }\n\n        self._table = new_map._table;\n    }\n\n    /// Iterates through the HashMap, applying the given function to each value and mutating the\n    /// value to equal the result. This function is more efficient than `iter_mut` and `iter_keys_mut`\n    /// because the keys are untouched and the underlying hashmap thus does not need to be reordered.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Halve each value\n    /// map.iter_values_mut(|v| v / 2);\n    /// ```\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..N {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    /// Retains only the key-value pairs for which the given function returns true.\n    /// Any key-value pairs for which the function returns false will be removed from the map.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// map.retain(|k, v| (k != 0) & (v != 0));\n    /// ```\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..N {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    /// Returns the current length of this hash map.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // This is equivalent to checking map.is_empty()\n    /// assert(map.len() == 0);\n    ///\n    /// map.insert(1, 2);\n    /// map.insert(3, 4);\n    /// map.insert(5, 6);\n    /// assert(map.len() == 3);\n    ///\n    /// // 3 was already present as a key in the hash map, so the length is unchanged\n    /// map.insert(3, 7);\n    /// assert(map.len() == 3);\n    ///\n    /// map.remove(1);\n    /// assert(map.len() == 2);\n    /// ```\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    /// Returns the maximum capacity of this hashmap. This is always equal to the capacity\n    /// specified in the hashmap's type.\n    ///\n    /// Unlike hashmaps in general purpose programming languages, hashmaps in Noir have a\n    /// static capacity that does not increase as the map grows larger. Thus, this capacity\n    /// is also the maximum possible element count that can be inserted into the hashmap.\n    /// Due to hash collisions (modulo the hashmap length), it is likely the actual maximum\n    /// element count will be lower than the full capacity.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_map: HashMap<Field, Field, 42, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// assert(empty_map.len() == 0);\n    /// assert(empty_map.capacity() == 42);\n    /// ```\n    // docs:start:capacity\n    pub fn capacity(_self: Self) -> u32 {\n        // docs:end:capacity\n        N\n    }\n\n    /// Retrieves a value from the hashmap, returning `Option::none()` if it was not found.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn get_example(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    ///     let x = map.get(12);\n    ///\n    ///     if x.is_some() {\n    ///         assert(x.unwrap() == 42);\n    ///     }\n    /// }\n    /// ```\n    // docs:start:get\n    pub fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let slot = self._table[index];\n\n                // Not marked as deleted and has key-value.\n                if slot.is_valid() {\n                    let (current_key, value) = slot.key_value_unchecked();\n                    if current_key == key {\n                        result = Option::some(value);\n                        should_break = true;\n                    }\n                }\n            }\n        }\n\n        result\n    }\n\n    /// Inserts a new key-value pair into the map. If the key was already in the map, its\n    /// previous value will be overridden with the newly provided one.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// map.insert(12, 42);\n    /// assert(map.len() == 1);\n    /// ```\n    // docs:start:insert\n    pub fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.assert_load_factor();\n\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let mut slot = self._table[index];\n                let mut insert = false;\n\n                // Either marked as deleted or has unset key-value.\n                if slot.is_available() {\n                    insert = true;\n                    self._len += 1;\n                } else {\n                    let (current_key, _) = slot.key_value_unchecked();\n                    if current_key == key {\n                        insert = true;\n                    }\n                }\n\n                if insert {\n                    slot.set(key, value);\n                    self._table[index] = slot;\n                    should_break = true;\n                }\n            }\n        }\n    }\n\n    /// Removes the given key-value pair from the map. If the key was not already present\n    /// in the map, this does nothing.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// map.insert(12, 42);\n    /// assert(!map.is_empty());\n    ///\n    /// map.remove(12);\n    /// assert(map.is_empty());\n    ///\n    /// // If a key was not present in the map, remove does nothing\n    /// map.remove(12);\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:remove\n    pub fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let mut slot = self._table[index];\n\n                // Not marked as deleted and has key-value.\n                if slot.is_valid() {\n                    let (current_key, _) = slot.key_value_unchecked();\n                    if current_key == key {\n                        slot.mark_deleted();\n                        self._table[index] = slot;\n                        self._len -= 1;\n                        should_break = true;\n                    }\n                }\n            }\n        }\n    }\n\n    // Apply HashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(_self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % N\n    }\n\n    // Amount of elements in the table in relation to available slots exceeds alpha_max.\n    // To avoid a comparatively more expensive division operation\n    // we conduct cross-multiplication instead.\n    // n / m >= MAX_LOAD_FACTOR_NUMERATOR / MAX_LOAD_FACTOR_DEN0MINATOR\n    // n * MAX_LOAD_FACTOR_DEN0MINATOR >= m * MAX_LOAD_FACTOR_NUMERATOR\n    fn assert_load_factor(self) {\n        let lhs = self._len * MAX_LOAD_FACTOR_DEN0MINATOR;\n        let rhs = self._table.len() * MAX_LOAD_FACTOR_NUMERATOR;\n        let exceeded = lhs >= rhs;\n        assert(!exceeded, \"Load factor is exceeded, consider increasing the capacity.\");\n    }\n}\n\n// Equality class on HashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, let N: u32, B, H> Eq for HashMap<K, V, N, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    /// Checks if two HashMaps are equal.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map1: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// let mut map2: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    ///\n    /// map1.insert(1, 2);\n    /// map1.insert(3, 4);\n    ///\n    /// map2.insert(3, 4);\n    /// map2.insert(1, 2);\n    ///\n    /// assert(map1 == map2);\n    /// ```\n    fn eq(self, other: HashMap<K, V, N, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    let other_value = other.get(key);\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, let N: u32, B, H> Default for HashMap<K, V, N, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    /// Constructs an empty HashMap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// assert(hashmap.is_empty());\n    /// ```\n    fn default() -> Self {\n        // docs:end:default\n        let _build_hasher = B::default();\n        let map: HashMap<K, V, N, B> = HashMap::with_hasher(_build_hasher);\n        map\n    }\n}\n",
      "path": "std/collections/map.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "50": {
      "source": "mod utils;\n\nuse std::collections::map::HashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\nuse utils::cut;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_CAP: u32 = 8;\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> HashMap<K, V, HASHMAP_CAP, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> HashMap<K, V, HASHMAP_CAP, BuildHasherDefault<Poseidon2Hasher>> HashMap::default();\n\nfn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nfn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"HashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"HashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nfn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"HashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nfn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"HashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nfn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    for entry in input {\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"HashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nfn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"HashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nfn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"HashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"HashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nfn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = cut(hashmap.keys()).sort_via(K_CMP);\n    let values: [V; 3] = cut(hashmap.values()).sort_via(V_CMP);\n    let entries: [(K, V); 3] = cut(hashmap.entries()).sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nfn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = cut(hashmap.keys()).sort_via(K_CMP);\n    let values: [V; 3] = cut(hashmap.values()).sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = cut(hashmap.entries()).sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib hashmap documentation\nfn doc_tests() {\n    // docs:start:default_example\n    let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> =\n        HashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: HashMap<Field, Field, 42, BuildHasherDefault<Poseidon2Hasher>> =\n        HashMap::default();\n    assert(empty_map.len() == 0);\n    assert(empty_map.capacity() == 42);\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    let mut map2: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    let x = map.get(12);\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries.get(i);\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for i in 0..keys.max_len() {\n        if i < keys.len() {\n            let key = keys.get_unchecked(i);\n            let value = map.get(key).unwrap_unchecked();\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for i in 0..values.max_len() {\n        if i < values.len() {\n            let value = values.get_unchecked(i);\n            println(f\"Found value {value}\");\n        }\n    }\n    // docs:end:values_example\n}\n\nfn iter_examples(mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    },
    "51": {
      "source": "// Compile-time: cuts the M first elements from the BoundedVec<T, N>.\npub(crate) fn cut<T, let N: u32, let M: u32>(input: BoundedVec<T, N>) -> [T; M] {\n    assert(M < N, \"M should be less than N.\");\n\n    let mut new = BoundedVec::new();\n    for i in 0..M {\n        new.push(input.get(i));\n    }\n    new.storage()\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
