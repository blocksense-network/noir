---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "955212737754845985": {
        "error_kind": "string",
        "string": "HashMap should have retained 2 elements."
      },
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "5727012404371710682": {
        "error_kind": "string",
        "string": "push out of bounds"
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "6895136539169241630": {
        "error_kind": "string",
        "string": "HashMaps should not be equal."
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "9417307514377997680": {
        "error_kind": "string",
        "string": "HashMap after one insert should have a length of 1 element."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12389747999246339213": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14479745468926698352": {
        "error_kind": "string",
        "string": "HashMap after one insert and corresponding removal should be empty."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16567169223151679177": {
        "error_kind": "string",
        "string": "HashMaps should be equal."
      },
      "16850003084350092401": {
        "error_kind": "string",
        "string": "Load factor is exceeded, consider increasing the capacity."
      },
      "16954218183513903507": {
        "error_kind": "string",
        "string": "Attempted to read past end of BoundedVec"
      },
      "17677620431177272765": {
        "error_kind": "string",
        "string": "HashMap length is invalid."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_recursive<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) {\n    if low < high {\n        let pivot_index = partition(arr, low, high, sortfn);\n        if pivot_index > 0 {\n            quicksort_recursive(arr, low, pivot_index - 1, sortfn);\n        }\n        quicksort_recursive(arr, pivot_index + 1, high, sortfn);\n    }\n}\n\npub(crate) unconstrained fn quicksort<T, Env, let N: u32>(\n    _arr: [T; N],\n    sortfn: fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = _arr;\n    if arr.len() <= 1 {} else {\n        quicksort_recursive(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "6": {
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n",
      "path": "std/collections/bounded_vec.nr"
    },
    "7": {
      "source": "use crate::cmp::Eq;\nuse crate::collections::bounded_vec::BoundedVec;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// We use load factor alpha_max = 0.75.\n// Upon exceeding it, assert will fail in order to inform the user\n// about performance degradation, so that he can adjust the capacity.\nglobal MAX_LOAD_FACTOR_NUMERATOR: u32 = 3;\nglobal MAX_LOAD_FACTOR_DEN0MINATOR: u32 = 4;\n\n/// `HashMap<Key, Value, MaxLen, Hasher>` is used to efficiently store and look up key-value pairs.\n///\n/// `HashMap` is a bounded type which can store anywhere from zero to `MaxLen` total elements.\n/// Note that due to hash collisions, the actual maximum number of elements stored by any particular\n/// hashmap is likely lower than `MaxLen`. This is true even with cryptographic hash functions since\n/// every hash value will be performed modulo `MaxLen`.\n///\n/// Example:\n///\n/// ```noir\n/// // Create a mapping from Fields to u32s with a maximum length of 12\n/// // using a poseidon2 hasher\n/// use std::hash::poseidon2::Poseidon2Hasher;\n/// let mut map: HashMap<Field, u32, 12, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n///\n/// map.insert(1, 2);\n/// map.insert(3, 4);\n///\n/// let two = map.get(1).unwrap();\n/// ```\npub struct HashMap<K, V, let N: u32, B> {\n    _table: [Slot<K, V>; N],\n\n    /// Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the HashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, let N: u32, B> HashMap<K, V, N, B> {\n    /// Creates a hashmap with an existing `BuildHasher`. This can be used to ensure multiple\n    /// hashmaps are created with the same hasher instance.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    /// let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::with_hasher(my_hasher);\n    /// assert(hashmap.is_empty());\n    /// ```\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = [Slot::default(); N];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    /// Clears the hashmap, removing all key-value pairs from it.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// assert(!map.is_empty());\n    /// map.clear();\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = [Slot::default(); N];\n        self._len = 0;\n    }\n\n    /// Returns `true` if the hashmap contains the given key. Unlike `get`, this will not also return\n    /// the value associated with the key.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// if map.contains_key(7) {\n    ///     let value = map.get(7);\n    ///     assert(value.is_some());\n    /// } else {\n    ///     println(\"No value for key 7!\");\n    /// }\n    /// ```\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        self.get(key).is_some()\n    }\n\n    /// Returns `true` if the length of the hash map is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// assert(map.is_empty());\n    ///\n    /// map.insert(1, 2);\n    /// assert(!map.is_empty());\n    ///\n    /// map.remove(1);\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    /// Returns a vector of each key-value pair present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let entries = map.entries();\n    ///\n    /// // The length of a hashmap may not be compile-time known, so we\n    /// // need to loop over its capacity instead\n    /// for i in 0..map.capacity() {\n    ///     if i < entries.len() {\n    ///         let (key, value) = entries.get(i);\n    ///         println(f\"{key} -> {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:entries\n    pub fn entries(self) -> BoundedVec<(K, V), N> {\n        // docs:end:entries\n        let mut entries = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries.push(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    /// Returns a vector of each key present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let keys = map.keys();\n    ///\n    /// for i in 0..keys.max_len() {\n    ///     if i < keys.len() {\n    ///         let key = keys.get_unchecked(i);\n    ///         let value = map.get(key).unwrap_unchecked();\n    ///         println(f\"{key} -> {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:keys\n    pub fn keys(self) -> BoundedVec<K, N> {\n        // docs:end:keys\n        let mut keys = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys.push(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    /// Returns a vector of each value present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let values = map.values();\n    ///\n    /// for i in 0..values.max_len() {\n    ///     if i < values.len() {\n    ///         let value = values.get_unchecked(i);\n    ///         println(f\"Found value {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:values\n    pub fn values(self) -> BoundedVec<V, N> {\n        // docs:end:values\n        let mut values = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values.push(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    /// Iterates through each key-value pair of the HashMap, setting each key-value pair to the\n    /// result returned from the given function.\n    ///\n    /// Note that since keys can be mutated, the HashMap needs to be rebuilt as it is iterated\n    /// through. If this is not desired, use `iter_values_mut` if only values need to be mutated,\n    /// or `entries` if neither keys nor values need to be mutated.\n    ///\n    /// The iteration order is left unspecified. As a result, if two keys are mutated to become\n    /// equal, which of the two values that will be present for the key in the resulting map is also unspecified.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Add 1 to each key in the map, and double the value associated with that key.\n    /// map.iter_mut(|k, v| (k + 1, v * 2));\n    /// ```\n    // docs:start:iter_mut\n    pub fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = HashMap::with_hasher(self._build_hasher);\n\n        for i in 0..N {\n            if i < self._len {\n                let entry = entries.get_unchecked(i);\n                let (key, value) = f(entry.0, entry.1);\n                new_map.insert(key, value);\n            }\n        }\n\n        self._table = new_map._table;\n    }\n\n    /// Iterates through the HashMap, mutating each key to the result returned from\n    /// the given function.\n    ///\n    /// Note that since keys can be mutated, the HashMap needs to be rebuilt as it is iterated\n    /// through. If only iteration is desired and the keys are not intended to be mutated,\n    /// prefer using `entries` instead.\n    ///\n    /// The iteration order is left unspecified. As a result, if two keys are mutated to become\n    /// equal, which of the two values that will be present for the key in the resulting map is also unspecified.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Double each key, leaving the value associated with that key untouched\n    /// map.iter_keys_mut(|k| k * 2);\n    /// ```\n    // docs:start:iter_keys_mut\n    pub fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = HashMap::with_hasher(self._build_hasher);\n\n        for i in 0..N {\n            if i < self._len {\n                let entry = entries.get_unchecked(i);\n                let (key, value) = (f(entry.0), entry.1);\n                new_map.insert(key, value);\n            }\n        }\n\n        self._table = new_map._table;\n    }\n\n    /// Iterates through the HashMap, applying the given function to each value and mutating the\n    /// value to equal the result. This function is more efficient than `iter_mut` and `iter_keys_mut`\n    /// because the keys are untouched and the underlying hashmap thus does not need to be reordered.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Halve each value\n    /// map.iter_values_mut(|v| v / 2);\n    /// ```\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..N {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    /// Retains only the key-value pairs for which the given function returns true.\n    /// Any key-value pairs for which the function returns false will be removed from the map.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// map.retain(|k, v| (k != 0) & (v != 0));\n    /// ```\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..N {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    /// Returns the current length of this hash map.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // This is equivalent to checking map.is_empty()\n    /// assert(map.len() == 0);\n    ///\n    /// map.insert(1, 2);\n    /// map.insert(3, 4);\n    /// map.insert(5, 6);\n    /// assert(map.len() == 3);\n    ///\n    /// // 3 was already present as a key in the hash map, so the length is unchanged\n    /// map.insert(3, 7);\n    /// assert(map.len() == 3);\n    ///\n    /// map.remove(1);\n    /// assert(map.len() == 2);\n    /// ```\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    /// Returns the maximum capacity of this hashmap. This is always equal to the capacity\n    /// specified in the hashmap's type.\n    ///\n    /// Unlike hashmaps in general purpose programming languages, hashmaps in Noir have a\n    /// static capacity that does not increase as the map grows larger. Thus, this capacity\n    /// is also the maximum possible element count that can be inserted into the hashmap.\n    /// Due to hash collisions (modulo the hashmap length), it is likely the actual maximum\n    /// element count will be lower than the full capacity.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_map: HashMap<Field, Field, 42, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// assert(empty_map.len() == 0);\n    /// assert(empty_map.capacity() == 42);\n    /// ```\n    // docs:start:capacity\n    pub fn capacity(_self: Self) -> u32 {\n        // docs:end:capacity\n        N\n    }\n\n    /// Retrieves a value from the hashmap, returning `Option::none()` if it was not found.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn get_example(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    ///     let x = map.get(12);\n    ///\n    ///     if x.is_some() {\n    ///         assert(x.unwrap() == 42);\n    ///     }\n    /// }\n    /// ```\n    // docs:start:get\n    pub fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let slot = self._table[index];\n\n                // Not marked as deleted and has key-value.\n                if slot.is_valid() {\n                    let (current_key, value) = slot.key_value_unchecked();\n                    if current_key == key {\n                        result = Option::some(value);\n                        should_break = true;\n                    }\n                }\n            }\n        }\n\n        result\n    }\n\n    /// Inserts a new key-value pair into the map. If the key was already in the map, its\n    /// previous value will be overridden with the newly provided one.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// map.insert(12, 42);\n    /// assert(map.len() == 1);\n    /// ```\n    // docs:start:insert\n    pub fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.assert_load_factor();\n\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let mut slot = self._table[index];\n                let mut insert = false;\n\n                // Either marked as deleted or has unset key-value.\n                if slot.is_available() {\n                    insert = true;\n                    self._len += 1;\n                } else {\n                    let (current_key, _) = slot.key_value_unchecked();\n                    if current_key == key {\n                        insert = true;\n                    }\n                }\n\n                if insert {\n                    slot.set(key, value);\n                    self._table[index] = slot;\n                    should_break = true;\n                }\n            }\n        }\n    }\n\n    /// Removes the given key-value pair from the map. If the key was not already present\n    /// in the map, this does nothing.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// map.insert(12, 42);\n    /// assert(!map.is_empty());\n    ///\n    /// map.remove(12);\n    /// assert(map.is_empty());\n    ///\n    /// // If a key was not present in the map, remove does nothing\n    /// map.remove(12);\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:remove\n    pub fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let mut slot = self._table[index];\n\n                // Not marked as deleted and has key-value.\n                if slot.is_valid() {\n                    let (current_key, _) = slot.key_value_unchecked();\n                    if current_key == key {\n                        slot.mark_deleted();\n                        self._table[index] = slot;\n                        self._len -= 1;\n                        should_break = true;\n                    }\n                }\n            }\n        }\n    }\n\n    // Apply HashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(_self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % N\n    }\n\n    // Amount of elements in the table in relation to available slots exceeds alpha_max.\n    // To avoid a comparatively more expensive division operation\n    // we conduct cross-multiplication instead.\n    // n / m >= MAX_LOAD_FACTOR_NUMERATOR / MAX_LOAD_FACTOR_DEN0MINATOR\n    // n * MAX_LOAD_FACTOR_DEN0MINATOR >= m * MAX_LOAD_FACTOR_NUMERATOR\n    fn assert_load_factor(self) {\n        let lhs = self._len * MAX_LOAD_FACTOR_DEN0MINATOR;\n        let rhs = self._table.len() * MAX_LOAD_FACTOR_NUMERATOR;\n        let exceeded = lhs >= rhs;\n        assert(!exceeded, \"Load factor is exceeded, consider increasing the capacity.\");\n    }\n}\n\n// Equality class on HashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, let N: u32, B, H> Eq for HashMap<K, V, N, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    /// Checks if two HashMaps are equal.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map1: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// let mut map2: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    ///\n    /// map1.insert(1, 2);\n    /// map1.insert(3, 4);\n    ///\n    /// map2.insert(3, 4);\n    /// map2.insert(1, 2);\n    ///\n    /// assert(map1 == map2);\n    /// ```\n    fn eq(self, other: HashMap<K, V, N, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    let other_value = other.get(key);\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, let N: u32, B, H> Default for HashMap<K, V, N, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    /// Constructs an empty HashMap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// assert(hashmap.is_empty());\n    /// ```\n    fn default() -> Self {\n        // docs:end:default\n        let _build_hasher = B::default();\n        let map: HashMap<K, V, N, B> = HashMap::with_hasher(_build_hasher);\n        map\n    }\n}\n",
      "path": "std/collections/map.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "50": {
      "source": "mod utils;\n\nuse std::collections::map::HashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\nuse utils::cut;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_CAP: u32 = 8;\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> HashMap<K, V, HASHMAP_CAP, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> HashMap<K, V, HASHMAP_CAP, BuildHasherDefault<Poseidon2Hasher>> HashMap::default();\n\nfn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nfn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"HashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"HashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nfn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"HashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nfn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"HashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nfn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    for entry in input {\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"HashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nfn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"HashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nfn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"HashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"HashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nfn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = cut(hashmap.keys()).sort_via(K_CMP);\n    let values: [V; 3] = cut(hashmap.values()).sort_via(V_CMP);\n    let entries: [(K, V); 3] = cut(hashmap.entries()).sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nfn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = cut(hashmap.keys()).sort_via(K_CMP);\n    let values: [V; 3] = cut(hashmap.values()).sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = cut(hashmap.entries()).sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib hashmap documentation\nfn doc_tests() {\n    // docs:start:default_example\n    let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> =\n        HashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: HashMap<Field, Field, 42, BuildHasherDefault<Poseidon2Hasher>> =\n        HashMap::default();\n    assert(empty_map.len() == 0);\n    assert(empty_map.capacity() == 42);\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    let mut map2: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    let x = map.get(12);\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries.get(i);\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for i in 0..keys.max_len() {\n        if i < keys.len() {\n            let key = keys.get_unchecked(i);\n            let value = map.get(key).unwrap_unchecked();\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for i in 0..values.max_len() {\n        if i < values.len() {\n            let value = values.get_unchecked(i);\n            println(f\"Found value {value}\");\n        }\n    }\n    // docs:end:values_example\n}\n\nfn iter_examples(mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    },
    "51": {
      "source": "// Compile-time: cuts the M first elements from the BoundedVec<T, N>.\npub(crate) fn cut<T, let N: u32, let M: u32>(input: BoundedVec<T, N>) -> [T; M] {\n    assert(M < N, \"M should be less than N.\");\n\n    let mut new = BoundedVec::new();\n    for i in 0..M {\n        new.push(input.get(i));\n    }\n    new.storage()\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
