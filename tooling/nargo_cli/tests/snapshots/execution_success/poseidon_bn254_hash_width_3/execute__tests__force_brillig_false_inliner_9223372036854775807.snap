---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x1",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "field"
          }
        },
        "visibility": "private"
      },
      {
        "name": "y1",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      },
      {
        "name": "x2",
        "type": {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "field"
          }
        },
        "visibility": "private"
      },
      {
        "name": "y2",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {}
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "50": {
      "source": "use poseidon;\n\nfn main(x1: [Field; 2], y1: pub Field, x2: [Field; 4], y2: pub Field) {\n    let hash1 = poseidon::poseidon::bn254::hash_2(x1);\n    assert(hash1 == y1);\n\n    let hash2 = poseidon::poseidon::bn254::hash_4(x2);\n    assert(hash2 == y2);\n}\n",
      "path": ""
    },
    "54": {
      "source": "// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::poseidon::bn254::consts;\nuse crate::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n",
      "path": ""
    },
    "55": {
      "source": "// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n",
      "path": ""
    },
    "56": {
      "source": "pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse std::default::Default;\nuse std::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        std::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        std::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    std::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: Field,\n    capacity: Field,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, rate + capacity);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": []
}
