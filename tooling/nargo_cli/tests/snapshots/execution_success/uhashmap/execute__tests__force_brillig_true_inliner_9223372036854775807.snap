---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "4105629585450304037": {
        "error_kind": "string",
        "string": "UHashMap after one insert should have a length of 1 element."
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "6665645948190457319": {
        "error_kind": "string",
        "string": "CtHashMaps should be equal."
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "7511829951750337011": {
        "error_kind": "fmtstring",
        "length": 37,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "8082322909743101849": {
        "error_kind": "string",
        "string": "UHashMap after one insert and corresponding removal should be empty."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "13674703438729013973": {
        "error_kind": "string",
        "string": "UHashMap length is invalid."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14241324264716156348": {
        "error_kind": "string",
        "string": "CtHashMaps should not be equal."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16986922238178214607": {
        "error_kind": "string",
        "string": "UHashMap should have retained 2 elements."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_recursive<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) {\n    if low < high {\n        let pivot_index = partition(arr, low, high, sortfn);\n        if pivot_index > 0 {\n            quicksort_recursive(arr, low, pivot_index - 1, sortfn);\n        }\n        quicksort_recursive(arr, pivot_index + 1, high, sortfn);\n    }\n}\n\npub(crate) unconstrained fn quicksort<T, Env, let N: u32>(\n    _arr: [T; N],\n    sortfn: fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = _arr;\n    if arr.len() <= 1 {} else {\n        quicksort_recursive(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "9": {
      "source": "use crate::cmp::Eq;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// An unconstrained hash table with open addressing and quadratic probing.\n// Note that \"unconstrained\" here means that almost all operations on this\n// map are unconstrained and importantly are not constrained afterward either.\n// This map is meant to be used in unconstrained or comptime code where this\n// is not an issue.\n//\n// Compared to the constrained HashMap type, UHashMap can grow automatically\n// as needed and is more efficient since it can break out of loops early.\npub struct UHashMap<K, V, B> {\n    _table: [Slot<K, V>],\n\n    // Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the UHashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, B> UHashMap<K, V, B> {\n    // Creates a new instance of UHashMap with specified BuildHasher.\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = &[Slot::default()];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    pub fn with_hasher_and_capacity<H>(_build_hasher: B, capacity: u32) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let mut _table = &[];\n        for _ in 0..capacity {\n            _table = _table.push_back(Slot::default());\n        }\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    // Clears the map, removing all key-value entries.\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = &[Slot::default()];\n        self._len = 0;\n    }\n\n    // Returns true if the map contains a value for the specified key.\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        // Safety: unconstrained context\n        unsafe { self.get(key) }.is_some()\n    }\n\n    // Returns true if the map contains no elements.\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    // Returns a BoundedVec of all valid entries in this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:entries\n    pub fn entries(self) -> [(K, V)] {\n        // docs:end:entries\n        let mut entries = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries = entries.push_back(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    // Returns a BoundedVec containing all the keys within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:keys\n    pub fn keys(self) -> [K] {\n        // docs:end:keys\n        let mut keys = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys = keys.push_back(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    // Returns a BoundedVec containing all the values within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:values\n    pub fn values(self) -> [V] {\n        // docs:end:values\n        let mut values = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values = values.push_back(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    // For each key-value entry applies mutator function.\n    // docs:start:iter_mut\n    pub unconstrained fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = f(entry.0, entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each key applies mutator function.\n    // docs:start:iter_keys_mut\n    pub unconstrained fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = (f(entry.0), entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each value applies mutator function.\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..self._table.len() {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    // Retains only the elements specified by the predicate.\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..self._table.len() {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    // Amount of active key-value entries.\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    // Get the current capacity of the inner table.\n    // docs:start:capacity\n    pub fn capacity(self: Self) -> u32 {\n        // docs:end:capacity\n        self._table.len()\n    }\n\n    // Get the value by key. If it does not exist, returns none().\n    // docs:start:get\n    pub unconstrained fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, value) = slot.key_value_unchecked();\n                if current_key == key {\n                    result = Option::some(value);\n                    break;\n                }\n            }\n        }\n\n        result\n    }\n\n    // Insert key-value entry. In case key was already present, value is overridden.\n    // docs:start:insert\n    pub unconstrained fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.try_resize();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n            let mut insert = false;\n\n            // Either marked as deleted or has unset key-value.\n            if slot.is_available() {\n                insert = true;\n                self._len += 1;\n            } else {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    insert = true;\n                }\n            }\n\n            if insert {\n                slot.set(key, value);\n                self._table[index] = slot;\n                break;\n            }\n        }\n    }\n\n    unconstrained fn try_resize<H>(&mut self)\n    where\n        B: BuildHasher<H>,\n        K: Eq + Hash,\n        H: Hasher,\n    {\n        if self.len() + 1 >= self.capacity() / 2 {\n            let capacity = self.capacity() * 2;\n            let mut new_map = UHashMap::with_hasher_and_capacity(self._build_hasher, capacity);\n\n            for entry in self.entries() {\n                new_map.insert(entry.0, entry.1);\n            }\n            *self = new_map;\n        }\n    }\n\n    // Removes a key-value entry. If key is not present, UHashMap remains unchanged.\n    // docs:start:remove\n    pub unconstrained fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    slot.mark_deleted();\n                    self._table[index] = slot;\n                    self._len -= 1;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Apply UHashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % self._table.len()\n    }\n}\n\n// Equality class on UHashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, B, H> Eq for UHashMap<K, V, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    fn eq(self, other: UHashMap<K, V, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    // Safety: unconstrained context\n                    let other_value = unsafe { other.get(key) };\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, B, H> Default for UHashMap<K, V, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        // docs:end:default\n        UHashMap::with_hasher(B::default())\n    }\n}\n",
      "path": "std/collections/umap.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "46": {
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n",
      "path": "std/slice.nr"
    },
    "50": {
      "source": "use std::collections::umap::UHashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> UHashMap::default();\n\nunconstrained fn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nunconstrained fn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"UHashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"UHashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nunconstrained fn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"UHashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nunconstrained fn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"UHashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nunconstrained fn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for entry in input {\n        println(f\"Inserting {entry}\");\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    println(hashmap.len());\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"UHashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nunconstrained fn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"UHashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nunconstrained fn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"CtHashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"CtHashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nunconstrained fn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nunconstrained fn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib cthashmap documentation\nunconstrained fn doc_tests() {\n    // docs:start:default_example\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::default();\n    assert(empty_map.len() == 0);\n    println(empty_map.capacity());\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    let mut map2: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // Safety: testing context\n    let x = unsafe { map.get(12) };\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries[i];\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for key in keys {\n        // Safety: testing context\n        let value = unsafe { map.get(key) }.unwrap_unchecked();\n        println(f\"{key} -> {value}\");\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for value in values {\n        println(f\"Found value {value}\");\n    }\n    // docs:end:values_example\n}\n\nunconstrained fn iter_examples(\n    mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>,\n) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
