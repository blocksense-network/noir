---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "4105629585450304037": {
        "error_kind": "string",
        "string": "UHashMap after one insert should have a length of 1 element."
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "6665645948190457319": {
        "error_kind": "string",
        "string": "CtHashMaps should be equal."
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "7511829951750337011": {
        "error_kind": "fmtstring",
        "length": 37,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "8082322909743101849": {
        "error_kind": "string",
        "string": "UHashMap after one insert and corresponding removal should be empty."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "13674703438729013973": {
        "error_kind": "string",
        "string": "UHashMap length is invalid."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14241324264716156348": {
        "error_kind": "string",
        "string": "CtHashMaps should not be equal."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16986922238178214607": {
        "error_kind": "string",
        "string": "UHashMap should have retained 2 elements."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, let N: u32, Env>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_loop<T, let N: u32, Env>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) {\n    let mut stack: [(u32, u32)] = &[(low, high)];\n    // TODO(https://github.com/noir-lang/noir_sort/issues/22): use 'loop' once it's stabilized\n    for _ in 0..2 * N {\n        if stack.len() == 0 {\n            break;\n        }\n\n        let (new_stack, (new_low, new_high)) = stack.pop_back();\n        stack = new_stack;\n\n        if new_high < new_low + 1 {\n            continue;\n        }\n\n        let pivot_index = partition(arr, new_low, new_high, sortfn);\n        stack = stack.push_back((pivot_index + 1, new_high));\n        if 0 < pivot_index {\n            stack = stack.push_back((new_low, pivot_index - 1));\n        }\n    }\n}\n\npub unconstrained fn quicksort<T, let N: u32, Env>(\n    arr: [T; N],\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = arr;\n    if arr.len() > 1 {\n        quicksort_loop(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "9": {
      "source": "use crate::cmp::Eq;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// An unconstrained hash table with open addressing and quadratic probing.\n// Note that \"unconstrained\" here means that almost all operations on this\n// map are unconstrained and importantly are not constrained afterward either.\n// This map is meant to be used in unconstrained or comptime code where this\n// is not an issue.\n//\n// Compared to the constrained HashMap type, UHashMap can grow automatically\n// as needed and is more efficient since it can break out of loops early.\npub struct UHashMap<K, V, B> {\n    _table: [Slot<K, V>],\n\n    // Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the UHashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, B> UHashMap<K, V, B> {\n    // Creates a new instance of UHashMap with specified BuildHasher.\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = &[Slot::default()];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    pub fn with_hasher_and_capacity<H>(_build_hasher: B, capacity: u32) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let mut _table = &[];\n        for _ in 0..capacity {\n            _table = _table.push_back(Slot::default());\n        }\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    // Clears the map, removing all key-value entries.\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = &[Slot::default()];\n        self._len = 0;\n    }\n\n    // Returns true if the map contains a value for the specified key.\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        // Safety: unconstrained context\n        unsafe { self.get(key) }.is_some()\n    }\n\n    // Returns true if the map contains no elements.\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    // Returns a BoundedVec of all valid entries in this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:entries\n    pub fn entries(self) -> [(K, V)] {\n        // docs:end:entries\n        let mut entries = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries = entries.push_back(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    // Returns a BoundedVec containing all the keys within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:keys\n    pub fn keys(self) -> [K] {\n        // docs:end:keys\n        let mut keys = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys = keys.push_back(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    // Returns a BoundedVec containing all the values within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:values\n    pub fn values(self) -> [V] {\n        // docs:end:values\n        let mut values = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values = values.push_back(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    // For each key-value entry applies mutator function.\n    // docs:start:iter_mut\n    pub unconstrained fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = f(entry.0, entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each key applies mutator function.\n    // docs:start:iter_keys_mut\n    pub unconstrained fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = (f(entry.0), entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each value applies mutator function.\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..self._table.len() {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    // Retains only the elements specified by the predicate.\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..self._table.len() {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    // Amount of active key-value entries.\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    // Get the current capacity of the inner table.\n    // docs:start:capacity\n    pub fn capacity(self: Self) -> u32 {\n        // docs:end:capacity\n        self._table.len()\n    }\n\n    // Get the value by key. If it does not exist, returns none().\n    // docs:start:get\n    pub unconstrained fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, value) = slot.key_value_unchecked();\n                if current_key == key {\n                    result = Option::some(value);\n                    break;\n                }\n            }\n        }\n\n        result\n    }\n\n    // Insert key-value entry. In case key was already present, value is overridden.\n    // docs:start:insert\n    pub unconstrained fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.try_resize();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n            let mut insert = false;\n\n            // Either marked as deleted or has unset key-value.\n            if slot.is_available() {\n                insert = true;\n                self._len += 1;\n            } else {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    insert = true;\n                }\n            }\n\n            if insert {\n                slot.set(key, value);\n                self._table[index] = slot;\n                break;\n            }\n        }\n    }\n\n    unconstrained fn try_resize<H>(&mut self)\n    where\n        B: BuildHasher<H>,\n        K: Eq + Hash,\n        H: Hasher,\n    {\n        if self.len() + 1 >= self.capacity() / 2 {\n            let capacity = self.capacity() * 2;\n            let mut new_map = UHashMap::with_hasher_and_capacity(self._build_hasher, capacity);\n\n            for entry in self.entries() {\n                new_map.insert(entry.0, entry.1);\n            }\n            *self = new_map;\n        }\n    }\n\n    // Removes a key-value entry. If key is not present, UHashMap remains unchanged.\n    // docs:start:remove\n    pub unconstrained fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    slot.mark_deleted();\n                    self._table[index] = slot;\n                    self._len -= 1;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Apply UHashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % self._table.len()\n    }\n}\n\n// Equality class on UHashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, B, H> Eq for UHashMap<K, V, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    fn eq(self, other: UHashMap<K, V, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    // Safety: unconstrained context\n                    let other_value = unsafe { other.get(key) };\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, B, H> Default for UHashMap<K, V, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        // docs:end:default\n        UHashMap::with_hasher(B::default())\n    }\n}\n",
      "path": "std/collections/umap.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "46": {
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n",
      "path": "std/slice.nr"
    },
    "50": {
      "source": "use std::collections::umap::UHashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> UHashMap::default();\n\nunconstrained fn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nunconstrained fn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"UHashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"UHashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nunconstrained fn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"UHashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nunconstrained fn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"UHashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nunconstrained fn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for entry in input {\n        println(f\"Inserting {entry}\");\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    println(hashmap.len());\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"UHashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nunconstrained fn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"UHashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nunconstrained fn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"CtHashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"CtHashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nunconstrained fn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nunconstrained fn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib cthashmap documentation\nunconstrained fn doc_tests() {\n    // docs:start:default_example\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::default();\n    assert(empty_map.len() == 0);\n    println(empty_map.capacity());\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    let mut map2: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // Safety: testing context\n    let x = unsafe { map.get(12) };\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries[i];\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for key in keys {\n        // Safety: testing context\n        let value = unsafe { map.get(key) }.unwrap_unchecked();\n        println(f\"{key} -> {value}\");\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for value in values {\n        println(f\"Found value {value}\");\n    }\n    // docs:end:values_example\n}\n\nunconstrained fn iter_examples(\n    mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>,\n) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
