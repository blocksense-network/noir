---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "4105629585450304037": {
        "error_kind": "string",
        "string": "UHashMap after one insert should have a length of 1 element."
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "6665645948190457319": {
        "error_kind": "string",
        "string": "CtHashMaps should be equal."
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "7511829951750337011": {
        "error_kind": "fmtstring",
        "length": 37,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "8082322909743101849": {
        "error_kind": "string",
        "string": "UHashMap after one insert and corresponding removal should be empty."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "13674703438729013973": {
        "error_kind": "string",
        "string": "UHashMap length is invalid."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14241324264716156348": {
        "error_kind": "string",
        "string": "CtHashMaps should not be equal."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16986922238178214607": {
        "error_kind": "string",
        "string": "UHashMap should have retained 2 elements."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/+29C5SkyVUe+GdWZnVXdT2yq7r6/aieaWkEWnvr3d2YR2OqYRjBjJBGMxppNKK7q4oZPdADwfE53oPTxmsWjGxkbDDG2FgyYA5vI/OwZbBs2cCBtWXwYh8b8zDYYi0wL7OyWdZe/un/Vn755fffjL8yIjOrp/5z6lRmRvw3bty4cePGvTdu1LL7z4k//KsVnxvF/xr8n8m6Hyu7VfxfGexZjQhrJRWOtUOAY/0Q4DhxCHBsHAIcm4cAx8lDgOOxQ4Dj8UOA49QhwHH6EOB4IgGOLz64iOdI54tFLoxzYZcLk3yy5pMhZ7Z8MHNincjKH+v4d7/y/v+p4nsdyiMK+9Upajcm/Bsr1+9Mif5FxH99CuieAP69KYCZAP7KsQLOF7c78Lkvxge1LNU4be0m7ue9WepbBn2xthtp2t6pUXsZ9TOj9qezpDy1WqP2DB+mj32etTrtDj41Kmu0e/thZc12dz/yJ5dHZ6Ae81Yd6j0Enx8vPqflx/tyI+EYrCw6fbbfjrWz/cfoNgG/GV2NzsexPpVNQVmj3d3OdPG9Ae0gLMOjSfWvFt/ni/+T8I693xLtT1L7XXiL35guU6L+lKifr33ni8/5mmdrwWe1O/AijumWwd9OA3/d4N8G+Fk8+CsG/7PT4L8P/3MAfiMB/EcL+Clo87mAe0T4+3rQY2lovw//VWngrxn8z0sDf8Pgf34BPx7tV3cN9uOAezzD0No+7zyRBv49g//qNPD36fMF7di0X79usF+TBPeNfb5/bRL4m3sG/8kk8Lf28X9dGvj78/apNPD35+3TaeBvGvzXp4G/v6Y/kwb+Pv+/IQ38Gwb/jWng3zT4z6aBvy/b3pQG/o7Bfy4N/H3Z+eY08PflzxcW8LNosK/vr1t34sPel2t3k9Dl+r5cu5cG/r4uvpMG/r7c3E0Df19u7qWBvy83v6iAnyWA/Xwa3O8a/BfSwN+XOW+JTpsb+7R5a3zY+2vV2+LD3l+n3j447FX+Id/757ajN17rHk9l/0Ibne3F5rNe2yTaCvO/Zh9YryJY+L69azanSSiLvYeqFbRIAH/d+nxM0AL7ZO3PCtrVSv4bLC6ztqYJViqbqeob4m+2pxbVZxqUwTpWEdaUKEsxppNOv7H9WQdX7kf+oC1rEJrkz6NjCsv6aHMf+YDnfqJxXLF+2NxriH4gbvWsV1Ychz416be3F//z73dIziremXRo1xT4zIr3qsgK1Q7CMlk/m/X2ddB2kIZN6s9BZZ9qB2GZDdf4Cv2sEfnqjvVjOut9rOwEtM3jOQNlvC7MQhnTbY76g2XzUMaBb/hM0HekU47LzrUOXK5nz3zWS99JKpvOevtoZSdEH23eGG1wrqLv3ni2SfX/D+jD/COdPvD7g/IbwjIZx+Maox2E9Si1MyvaMZ5nHrlVfF8Z7NkM6Qe2P5318nMK3WSO8GH6oD+X54m926Ky/OG1cF60My/aOUywbN9h8xJ5Z9+HmvXSLcUabT7ThugH4lan+vg5f5r0298q/qs1WvHOnEO7WYHPrHjvoHN/VvRnUFgnI8JaiAhrUcAyXjsFv8fcC4bKMGt/mnBNJcNOET5MH6bdksC1Jcqwb1iG7SyJdlqijOVODFhWhnJnkd7DeT5LZcjbjxFM5FVep+tQZjpjrr98CNrK/2yP0Mx0rNB2u1OO9T/tWgfmjxW/zVMd7Pd81itfWlSGstD6PcK5FKwPjMNcUvqA0WcpDT4bhs9pgY+a2/mYzmW9Y4b4GSy04VnsgeKhReprIl5YYZmAazi2OQt95r6hfGjSbx8t/qs1HMfWG+9W1st/LE9QDh2jMpRDLKNOQtk8laEcwjiaMtyRN9gWe0zgPuHgbuPMdMH6CEPBNxj9ZOe/z3TflOzMP09BOdb/pawD81xNw6yXwOS5nVpnNRqW6ax16qPV/zWilfFP2VjVqb7SlU867bao3XweLTzSDVPxA7Y7Szjsxz+W1J8jHKz+rwMOS4TDrKAD4oVxXFV5uAznYwE4/7aD87yDM/I5jx3y8LxTn+chw29lmiY472YFfObJT0Afz5bwRj3TMtbWoCmBUwq7vNrzTjs0aYn6am/p6WFe28iHjxEtFhLT4mQfWiwQ/guivlq/5kX/FyrS4lVEi0S637rXN6TFIuG/KOovOLQ46cDqR4vt9oNFC7Vnq2flcwvbQnmSiXdQd+ian4U+kMvvxVo3XH6HZRCWWd3TAG9BwGYZnGV6H8h+FLVuoo6kbMmmG7L9F/kOdSKlExo8ZZ+fIRrYe5cKeLncv1DIfeWXy/9uFd9XBno2bhr86STwt+5OET3iwr9+07P3W9tp7N7rqzVqL8v0vtvan856+SnFvlvNEaQP27CUrdnbh7HswHY8my2WcbzjILDuRYT1dERYdyPC2okIK2Yfn4oI6/GIsJ6PCGsvIqwnI8J6NiKs3YiwYvLXCxFhxeSv10WEFZP2OxFhxaTXMxFhvTkirJ2IsMZVfr0UaD+ucuL1EWHFpH1M3SQmvXYiwnpDRFgx17SY9Iqp+8bUTd4UEdY40j7/zHvmcehj/vlERLzsTK/BY9sOxjeW+ZG+uXb/f9q4uPUNjiuzNrDtVqK2a9Se0Rp/w/ZnBT6G97QoGyRPwc7mxurG3s3Nuzt767s71/dqBN9w5d/Y16Xs28qukNbevr6i8sFgHEb+NKCsRWVNKDMcMR/MFMGMjX8I/bH9lqjP/rfQsVQ+dD5LNAisqQPCWsi65wDKiVnC08qzLHl8eXBsjbU/nfXSNIWNb0rQtSHoqmLZ7V2Opcwfji2rGtNxGGBxrC3yjtEwre3Yj1tQY1XPetdOXKfZP/N9BXOqOB3FO1MO7dQaPyveq5X8t3b4N+bRuYiw5iPCSh0DnNg/HaybWPvTWcr1ryPDPP+3ot2iwFXFkmHfsAzbUXF/LVHGcicGLCtDucNrPc7zBpUhbz9GMJFXbxdl/eLFfqrWaQvbC421tfpXINb2nxcw1Xlj67eK8ZijMhUP4cXAJ/bpB+sD1v50lnRur3p86cXapozrz/9UTPqCwAdjbXHMVNxtaKztAvU1ES/sr+GnAL8J0SbH2p4S/cyfJv32i84aXlX/WRD4KDnEsgblEMtcFQev5BDH2ir9A3nDZJonO5SuxDr3hOifopuCbzC885X95OpvkFw9aBzub9U6MJ8sXlB8z+c+cezwDDCOXWj8biJdwD1zFhJH+/tEY5t3OP4qDph1kLK5y+0uULsqflftecviq7CfZfG7LcLB6v8PwCEkFraq/aBREedGAM4T9XKcTzo4M6/jWCAPn3Tqcww6w+eYSuyD4qWyOLcp6OPZkrhqFXOcPxy/O4qY1TmHJv1iVq1/ITGrqm2Uz48RLRLpLOssO8pocYrw984KYv/mRf8ZVj/9jeN3TyemxVIfWpwm/NXZKjxTtEi0OOXA6keL7XY3Lc4kpsXpPrQ4Q/ifEfVPO7RYErCUvQfHhGmF6wW+w3LY6l8tXsjl98vq3XDn6B2WQVhmdV8B8K4J2Cz/skzvLW3O94vfNd1qXtRjPQjXJc5/gXod579AOni6BNPijwr5r3wWhlde7zLlyUBbWKN4Z1jx6l78PLdfNl/VOqlsNeybQfrMOfRpOPRJdNZs3eNhT1dS9ETdhPdO+D6vmaptdfY6Jr+l8ZmG81vVM0TMb/g+r7sqB5/SQaryJ8JoFO+Mkp7eOap+9GSbgLe35z04ytj8eYzqGw1tH8F1ys7IvRpk7I1HuvHD/GZsB8F9MPNJU/RZ7bmxj7zWqDyD86JtXmvsO+5DMQeY2RWaVP8NQIc/RjyYKrfX7XZ3OylyleUP51pSvqbEfrpgey+f8Ujkj3bPeCgfXpUzHvnD/o5BYofGFRb7f5W/NXEOrxWW1Y1Mr31sO0a5jHKez0l/CciFQW3Hyn6q1rmDzv3D6LM9KKwR+KyC/b/j4LNacGh3SuDaEmXs/1V2mlOinZYoY7kTAxbHpGC/1R6A43WQt9n/i7zK63SZn+Iv0B4dda4Q/+++fAD/7/tIZ1IyRPkp+Gwz8iDHTh7lWvJzLan18EHNtaTsE+OSa2kO+sx983Itvd9Zw6vqP4sCHyWHWNagHPLywbH8QjnEe0Slf3i5lpTsULoS69xq76vopuAbjH6y83tL7JtlPl6MrcH6fxdsph8vgRnqqx3XXEt/n/o1rFxLfx/m0ahyLf2o4/ecFXRAvEJyLU1VxHkqAOd/4uDcL9dSWUy58nuq+jwPGT7bsJStXsWGME/+pOOrnRM4o+wah1xLkw5N+tn1ONbOsxEehlxLSIuXeq4lpMVLPddSTFooPVPZZjiWneVJJt7heBKr/8ugG/xH8tWWxaAYfbHM6v4awPtVAZtlcJYN5qs1HUnZkk03VPZ5jDH6uGOD92zpGdXPn9vt+//Zlv6bsBZ8+iMaZv5MwO/2bLfD8ZvsA4v3Nuo+ksR3KW0ktqvvz1cVC6p8NLOCdrWS/waLy/iMVqJ7rtwzWt69M6iTcbxm1TM7Clbis3L7Y3rc6Te2P+vgyv3IH5u3g9Ikfx4dU1jWR+Uz5LmfaBxXWP43Mr1vOA79YVmBawevP7PF5FR2DcU7xx3aefe6pfJL8roXwweibDHDunvK7Bn9bB3nJzpwkRfK7MSf1e6UY/3/+nAH5qUCprL1eP5ztiEruk1lvTyS/90qvq8M9GxuKh9hPPgbN5Q9JyL8HbVvjQf//v29qMfFhb++Ojqf2tpWqM7xoPjUeA4d1A+m5ssgPjXOWTMIrHsRYb0hEiw1/8eBXkpuDILX45Hwyp9nI8J6OiKs5yLCeiYirJ2IsGLxff7E5Ik3RYS1GxFWTJmzExFWTNq/LiKsmPMxVh+VjjMIXk+048GKOY4xZc6bI8LaiQgrJr2ejwjrpbCmvRAR1qsJlumvKs9O/tievkn1v7pQ6tPGg67d8GIgE+9lbtSoPaM3/obtzwp8OHcdlg2Su27rxvre1uqNO3f21q/vre65ZzVVfJHHS2pflDY+am1TnSM5BXTNnwaULVJZE8oMR5W7Lk3M09pmCP2x/Zaoz2dADppTB+dwVVgh+eZS2dtut7vbSWE/zB8+P8E+yfxJHDMUHC/J8iNR3P2+naSf35rtJMonzLlV8od9AcofreTOYYLF5yfUHEocB7LC872R+f77etYrO1Au8PnoDzg+CsU78w7tVHxzijMPixFhnYoIaykirNMCVuI8AMHnJ6z9acI1lQzz8gwo2p0VuLZEGcfinRXtnBXttEQZy50YsFRs8ml6z4t3Rt7m8xPIq7xOl/nFfpT8YioWEd/dbnfKsf7PPdyB+WHyi4WekeDcEsiDqGcy//BcQn4YhT5g7U9nSef2qseX3v7gXBp89s9PnBf4nBH44PkJHDPEz2B55yeQh3gvkYgX9tfwc4DfhGgT8zxx385Bn5r02884a3hV/eeMwEfJIZY1KIdY5uIejeUXyiE+P6H0D+QNPj+hZIfSlVjnnhD9U3RT8A1GP9n5ixO6b6E58qz+f5jowLzQ0DDrJTB5bqfOF3nQnHP/mWhlPFI2VmU2EGx3yWn3FLWrzk8ofsB22Xdp/Sw7P7FAOFj9/wI4hJxFQLz4/EQVHi7DeS4A5991cF50cEY+57FDHl506vM8ZPinMk2TslxHPO+s/n+HPp4t4Y16pvdJfH4ijc3Kz+923KGJshmqHNRqH8yw+sVl8PmJUeR3Q1oMO7+bmq+jzO+GtEiR3y2UFtvtB4sWSs9UthmO6WJ5kol3UHfA+icLfSCX30uNbrj8DvItnxmzumcB3ikBm2Vw/qh9oHd+As/smY6kbMl8fgLt4UsAw3SiqjmM+HzJfq734gPeVZ1lmm7q/ALDu158SHuuoXNH1PBzCYXfEVWWYwXxnhZlKe6ICs0VY/XV2VTvjqg0fgd9RxT6d/KnAWWzVNaEMsNR+dkS3WW2EkJ/bF/5f1jvrZr3B9vhM0yDwJo8ICzz2XlnWxLdu7Tv9/TObmH73tmtGuGuYOWPxc97ueUSnwO7YTjN9Om3l1d1hnCdSYPrRto56ef/xD6xH/mg51Cwreks6Ti7eeW88zc4r5EGg8oI5pnU5xBnnH73W5NnSvqRP7fbcWiSP+N6n5r10eY+8gHLqUTjGHyf2gz0h2WFd5/aM6Dvsi1Z8c6MQ7vjAp9Z8V4VWaHaQVi815iL2I66Z2RQ2afaUflQ0+qRq2vqjFFGfcQ9KI+nOvfCfnFFN9xDN6kM9+CoE/AzQd+RTnl7O9c6cLmePeoM3UuJvqjH8KPoa3QKpa/S7WaoTOkWyrfDZ8btu8otmj8c82r1vxxk3WdSTuFU89nWkJTyKX84Js6Lt00UuxTsA+f7GBPF6Ln3Maq4JjUvy+5jzJ8UdyiOGyyOiVMxaONyHx3701GGos+DbaLf4OhAVf3pyqes1oKDzn1eH2LASh3HdlBYI4jjCbZljkMczxmHducEri1Rxvavc6Kdc6KdlihjuRMDFsfpYr+9M8Uq3oRj4pBXeZ0ui+v4u+QLQT9CSEyc1f/hhzsw/x75MHBfF+KLtTKUhdbvo5i4sLmk9IEHNSYOeWjcYuI4rj00Ju6fOWt41bj2MwIfJYdmqQzlEMsoFVOg5NCgMXGzAvcJB3cbZxUbo3QfBd9g9JOdP1viRy6LiWOfqtX/OfBNzzc1zMMeE/cLRKthxcT9AsyjUcXE/QfAIUVM3GxFnGcDcP6Yg3O/mLiyHDRlMXFcP3ZMHM87q/8b0MfDGBM349DkpRYTh7R4qcfEIS1e6jFxMWkxipi4ZqEP5DJsqtkN14uJa1KZ1Z0BeMcFbJbB+aP2gaExcaYjKVsyx8SpO3RRJ1KxGhzPgGsJ58u39xaLDxgTNyVg53+3iu8rAz0bmyr+Ix786zdUzEY8+Fvryi8cEf/rozv7vvaSOvuuePygZ8wVPw8CqxUJVv5w7pxB8JqJiNdOOx6sWH3Mn6ciwno8IqznI8J6LiKsmPzFMnUQvF7bjgdrLyKsJyPCejYirN2IsGLOxxciwnoiIqyYc/t1EWHFHMediLBi0uuZiLDeHBHWTkRY47p2vBRoH1PmWF4/g2d6Iuftyz/zmVWr+78Vimpi/X8/p18r68YZ215I1HaN2jNa42/YvtL1DW+Vu3yQs0Zru3+4MVu7t7e2t7K3sbd1vSpfWH1lJ/LuPE2UE29DnTXivH0NKFugsiaUGY7qrFGi/I8bIfTH9tW8DPEnhOqtfJZ9EFiTB4S1kHXPAZQTic/cDO0cS7+7l2LlQ8S2ju5eStLvo7uXIsCyPqr7ZoZ995I6x+LdvRR6juXrwUb9INy9lOocy7DvXlL+UoOh7ulJwXO2DiLPqfWvnvWus7iGsq/p2x2eqxpzVBP4jC6Wf3UtdP2z9g9zLH/++Rh8xjJsJzRmnu2mg8C6FxHW0xFh3Y0IaycirDdGhBVzHJ+JCOvxiLCejwgrJn/FpP1ORFix+D7/fCKLAyt/zBZl6wLLs1vF95WBnrU1te7Eg79+R9kE4sHfvKtsJhHh73hnatLGe22thK7Z1v404ZpqzfbiyfKH1+wzAleOzc4fll0qPknF0as4b54vg8CajgQrf3g9GwTWcxFhPRUJVmzaL0SEFQuv/GE9bhBYOxFh3Y0IazcSrPwzx5CMA71i88QTY4pXTDnxZERYb4oI6+lIsGLSflzlV/65GQlW/sTkr52IsGLJwvwz6/ZHMsfH6/XteLBi6kyx5ET+PBsRViz9K39i6SYxeSK2LFwcU1jjuu+IuT4+6LIwf472oqPTAY72okdr7WFYa2OP4wsR8ToVEa+YOuY4rrX5s9eOByvmHjkm3+9GhDWO++38OdIBRifvj3SA0fH9kQ5w+Pkrf8ZRB4gJC/vYL7/QN052t4ln+ifEu3YPAZ93/9qHOzD/egHTu/dAxU7mf7eK7ysDPevr6jxHRPhrIec5EsXob9WovSzTPmtrf5pwjYtPx2etYjGQPuyzPiVwbVFZ/rCOoPLOnBLttEQ7LEcGgTUdCVb+8HowCKznIsJ6KhKs2LRfiAgrFl75s9uOByvmON6LCCsmrz4TEVZMej0dEVasOZQ/4yondiLCikn7mPwVE6+7kWDFll9PjCFe+efZSLDyJ+Ycijm3dyLCekMkWOO8bk9FhDUfCVb+8P5SnUNTenEev2V7pXe++4Uvfk9GT4O+W3Iza4wDTqzhl9F7t9u98Gr0eQLgZAT3ZeI9bhMPDkFOuZ4NpNX/3WJnmB8M2i4SpqkNpLU3rMN3+4e2oT/YpuFWz3oFFV72wsnM/zv0lw9CIb0UDZn5agKfWfEe0y7RBVzByc74QrtmGnzcC+0UXfkQGb7borL84YOnVQ+yHQZYdqlJ2iR9G7shB/hSJj/A9oxO+Bu2P6wDfMqw4h3gCzGsxFaqOOHMuChCj0eE9fqIsGLSazcirHE0HuVPzHEc1010TCPNOG5W82cnIqxxNdLE4tX8c0wjcyx65Z9PRMQr5tyO5SzIn5j8Na7GtpiGqJg88dp2PLxeCnPohUh45c+rC1j9nMdPHetuE5PshTiPrf6/eagD85kCZuL9/Ubiy2z2kzCpPRf2CZPD1TK9X+f/BovLOHl46v206ptnp8B9EhvvDro3RVhpkzj6ydKQ1mXJaPBdtce+3Y5Dk/wZVzuC9dHKVEInK8MkTE2CqRInpb2guiMzxi1x2yAyw9oalsxQffNkhkq85sE6XhFW4gSO+2M66fQb2591cFVzhmXGQWmSP4+OKSzro7qAxWiYeBxXWPY3RD8Qt3rWKytw3WAd6KsLvUf5AxTveAksVcBd6uR1nIxvKmI7yt8yqOxT7SAsXlMS6RQbo7zcTV3INmgyRWxrWJfYhCZ/blF9pkEZrNDkVEO63N3dWyCteW+hcOV+5A+vKYMk2Xp0TGHxmoJ8YDQc1oWnNvfKLjzlZJsoK3Dfzpe0fa+zplTV4ecEPp6v7qAyGGHxmnIqYjtIQ05unSKRbP7YmqIuPjQYiS+43Oc5OyyAPIdtLkF/sD5+zp8m/faPHJ5Tl2ouObSrCXz62aQ+QjYpvBQixCZl9X8EbFI/XsCcF3iZDjRPsFFvUUmkm1Sm5rvik1NUhmPGfIzjNCgfIyxeH+wy8jKd+DThpRJCJ+b74JgUTvSXaD/hJvpT+yKj3TmBa4vK8ofXynOinXOincMEy2JSbO4aH/5SMV/zufmJY93vIx9b/Nw8vY/zeCrrpXsKeXy+gNcQdEDc6lQfPyMt7LePOfL4LLw3IX5j2tcFPop2fNHB+cS0u5D10u68Q7sLUGafkXb2229GpN1xgY/NaZQBuJb97jHdJq5lfHk09sPq/8bVDsz/R8wNtXadIVhW9vtAk895pPx95oHUOrStkWU6tOFWz3rXVNRBmvzb8c4/5gHUI5Ru4fEAy3V876BrtZdI96CwTkeEFUMfMVhnBazEsjo4PtDan856ZWMKHUKtoWcd2p0XuLYyLavtM5ZhO+dFOy1Rxut+DFjeumRlOM/5UhvkbfY9KX13FvC3B+X1heOdtrA9lNf47na7U471/8XVDszLxY9qD2H9VnuIJSpDHmR9HPmH51KitTtYH7f2p7Okc3vV40tlUzL6XEiDz/5FbBcFPko/Ppnd3//xmCF+BgvPfXxe+/5/xUPnqK+j1uMWoc/cN0+P+1+dNbyqDfGcwEfJIZY1KIdY5qIOx/JL7VdYviDuyBsm0zz9zNOVbJzVnl7RTcE3GEp+sR2xTK5+GslVa1vJVZa7WP/W8Q7Mv01ytar9xdq0sauX4MLyNJEu4Nr1zgp82G73GNHY5h2Ov9pr2Odzot3zTrvnqN3838Ij3fVVAhRsl/Gxfk6W1Oc9jdV/HHBYIhxOCzogXnzZpcK5XhHnegDOr3VwPuvgzLyOY4E8fNapzzY6hn8u0zQp27cuUh+t/jPQx7PUx0WBM+pztq4l3hOsM82zrNe2rWji6ezYv/msP31V2yifHyNaJNJZ1ll2lNHiAuF/QdRX9pt50X+G1U9/exXR4lJiWlzsQ4tLhP8lUf8i1DlPtLjgwOpHi+12Ny0uJ6bFpT60uEz4Xxb1Lzm0uChgKXsPjgnTCmUvvsNy2Oq/C3SKLz3eDXeJ3mEZhGVW908AvPcI2Cz/skzvLdl3iuugvYu6lfJtsR6EtGE/FO7d0Fec/6l9sGe3tPpfLuS/umDb8MrrXX6ku9+oIzeKdxL7mvb5Xfk7lV+M11WsjzzI+w183/hT0ee4Q5+6Q59El1y5MUll86+MnqibeLYfXjPV3gnXUZw/L9Zpd973+A371CjeGSW/IX2q8luZvUytu8oWXnZZ74t12p33DccHff6yLQHr896e9+D2357HqD7K9AlRh9cbq/8tIGNvPNKNH8fGYRnug5lP5kSf1Z4b15oqcRS41nAchTqHoeKGef3yLrtPEcuaP7fbnfrYLu6hESbHiE8IvBLHQQfbbflcwUQafNxzBUgf9oHMC1wP0zmaFLk9+IL4fwj657863v0+8jHHUaj5nziOeoXlYEPQAXGrZ73rI67dLCc/4tiQMcZvQvzmxVFYPUW7CaLdqONQmXahcag/HZF2ap+hdAW0H3/0uG4T9yMoL2vUD6s/cbUD82fF3PDWLoNr61MDfkfdydYETrD8b4CGjxXr9FTWu+bF9EGN69mog8ZKYFvTWe9YpViXVN+8GBF1tsmDNVkRVuIzkuvM56rf2P6sg6s6Z8Q600Fpkj+Pjiks66PSaXk9TTSOK6xXNUQ/ELd61isrUB6zbed3nDWhav67usAn9fkwtq8dj9hO6jixloBl6yWfcc6fW8X/lcGeTYM9Fx/23bT65eq6su/Yo/KuMR8quwrH2KnxRr8Pn/tGfxHqjfxM0HekU47LzrUOXK5nD9M3f24V/1cGe9ZYv40Ieyft+crVTRVzaY8aX+YLHF/mCxWPrs4BcByFipkJ5QujU1W+eJDpy/sMpC/q9/zEoO981l+2YH3c9zw01XkH1+2yuJlTUI71f2C5A/NlU914KV1A6S3HqUytcTX6rs4T5Y/5cDk2/ZUFbnndz3f8HDHXTdPVUuoB+WP6peIHthMk8tvs64Q233B8VIxUPeudn2jzbtJv12H8WCesms9qQuAT8xzpYYyPPyisEcQHB8faj0N88DmHdhcEri1Rxr4WFRNzQbTTEmW8F40BS/l9vDjWCSpD3uZYe+RVlqdla9traG1D/9aEeHe73SnH+n9luQPzdbS2KRmiYkJPUxnyIPrlmX94LiWKywr22Vj701nSub3q8aU6D270uZgGn/1YexWfpM6kYKy9iq9HWF6sPfLQeeprIl7YX8PxLMCEaJPP/18U/cyfJv2256zhVc//nxf4KDnEsgblEMtcFUep5BD745X+gbzBsfZKdihdif2iE6J/im4Kvv3eT3Z+yZTuW9m+APcNWP/Lpjowv7cEZmhcfOp8F+p8qBeDZvW/nPqlYqtPCTj2+aDx+F8O84jj4hU/YLtlZxTK4uI5TtHq/xnAgWPMTwk6IF4cF1+Fh8twngjA+SsdnE87OCOf89ipGHNVn+chwz+TaZrgvDsl4DNPvhf6eLaEN+qZ3idxXPwZwvlW8X1lsGedaZ5l2rfHNFHnJ1ReGrUPZlhePFb+cFz8KM4IIC2qnhFgvdM7I9CPFhwXn0j3W/f6hrTgs0PevkvR4qwDqx8tttsPFi2UnqlsM5w3gOVJJt5hm6HV/1bQDb5jqhsuv4N8O09lVve7AN7fEbBZBueP2gd6cfH2LupIyuZnuqGX2wN1IqUTejbPjOrnz+32/f9s8/wBWAteTXEhiWLuNkYZQ4B94hiCQeJCrK1hxYV48RFZVu57ZhqUwWpWhJU4lmh/TCecfmP7sw6uyh9v82NQmuTPo2MKy/royZPE47i/n7K5p+55RNzqWa+swFgX9jX9n479QPHOhEM7nsP548VOh8gK1Q7C4vUlRb5l7Nuw40LQJ3Wr+L8y2LM+bj5k5hXUT3jNieGjR/2Bnwn6jnQ6qI8+f24V/1cGe66n9Tmubik/W0a05D0sluH48Njh+PDYKR+/8ukgz/Kjxs7oVHXsHmT6cnwF0rdq/EpV+qo90gSVKZuP2nPzGpwqZ+Qoz/Grs/eD+pyxrWHlTFN98/I3qpxpHqyQXGYIa5S2BmUr8Xz/IWOq+o2wTK/w/KIHbcfLHaHsZ+Pic+M8paE+t8XigrsYeUpVLqp+/qQz091tNgHPEH+D1X9huQPzfAFTxZIZH3n2LS8+J20ups2VUJln7U9nvbRPIfMULyB9PP2Vz9bjXH5Nu1OvTMaE5nR+U0RYb44IazcirOciwtqJCOvxiLBi0v71EWHF7ONeRFhPRoT1bERYb4wI66mIsGKO49MRYcWkfUy8YsrVmHiNqyy8FxFWTF6NidcbIsIa17U25nwcV/kVcxxjrkMx18eYMicm7V8XEVbMPo6rjI5J++cjwoopV8dVn4ipR782Iqxx1Zli8v0LEWHFnEM7EWHF3CuMq74aU048ERHWuK5puxFh7USEFZNez0SEFVOP3okIaxzX7fzzdBYHVv7EkhP55xMR8Yopc47W7dGt268mWOreTBUbz7n//3XB9Gn9zJvrozuzuLleo/aM3vgbtu+dt50WZY0BcN28t7u5tXtz7+762tbOyuZOjeAbrvwbxqPlfyo3vPLHpM1Vv7GncvJeBLrmTwPKLlBZE8oMx9wXeYbwT3N+c2MvhP7YvjrnzOeVDnpmGudtDFjNA8JayLrnAMsJxFPJn/zZbt//z3H6/47kT6o7bRYAbibaQpyQHuosh/Ij8zid7QOLz++ecfA658Ay+YOw8H17V8UtsvxNI/sPftdhotwjqyF0zR8vzszeVXEiPM8Giek5ExEWx68gntbvxGf5Vjx95YygYT3r5WmcW6zP/I4Tv1I1Xn5J4JMyF6Aah0SxmjdUnF1GfTzn9B95juOv1FpoZainvKXdgc/PBH1HWuRj+1q6wwPr2aNiery8Ukz71PerGX3LznPzHMDxQNnFd8IcO9GhU4o5oGg3QWWIK8e5okxivTRRXo6VUd5LpO4SUnOlihzBttSeJMV6qfrm6Z64x0AalMG6VBFW2r2Mf++WuitLybhB1waExXL2UsR2kIbWN3UvmM3rxPNpX0ZeKeChjLwscK1TffycP0367ZojI6vusc4JfPrFub7iRHeb6l5DHMsm9cPqf9pyB+YrC5hKPhsfqf0G8+/w70PfXAuVebxHGLf70NVcUTYCjnMdJK/amyLCenNEWLsRYT0XEdZORFiPR4QVk/avjwgrZh/3IsJ6MiKsZyPCemNEWE9FhBVzHJ+OCCsm7WPiFVOuxsRrXGXhvYiwYvJqTLzeEBHWuK61MefjuMqvmOMYcx2KuT7GlDkxaf+6iLBi9nFcZXRM2j8fEVZMuTqu+kRMPfq1EWGNq84Uk+9fiAgr5hzaiQgr5l5hXPXVmHLiiYiwxnVN240IaycirJj0eiYirJh69E5EWOO6br8UbDAx59C4ysIjfWJ0+gTH3ypfvsq7y776Xy98NoljYDc932RaP+pm8J0h7IdSPt9pUTZI/O2NOxu7G6srO3t39u5ubO5s1gi+4cq/1aH9/O+yqK/8REbrK2lovaribzHmIH8aUHaJyppQZjiq+Ns0ft/N1RD6Y/stUZ/jbweJNeB82YPAah4QlsXfYgzFBYLlyZ/82W7f/8/y57dI/iTKGSbjb8+X9AHpcUb0wcvjVCPYZbA4/vacg9cFB5bJH4SF79u73r1siXOGBcffWvvToo8pfOseXfOHfeuK/1uijOeZit+5KNpRsM5FhGV84cWPp873yPMD5YWK96xnvTyNc6tJvx2buf8/RuyhigdOHX/L45BmDqzeUXG0GfXxgtP/0Lgwjr9FPeWt7Q58fiboO9KiavytGseQOZBqLWL5g3NAxfHXs97xQNnVpN8uJp4DIfG3yPccf6tyf6fOWzmusZp1qF9FjmBbw7rnQfUN8ffWHtYXB1nHDFbimO11T09AWuP5Qq4/6NqAsFjOpojzxb7NZ5qv8ifxfNqXkbZeoIy8JHCtU338nD9N+u2mIyPrRLt+fD4h8OkXf/tpM7rN0Phbqz+93IF5q4Cpxs34SMln5l+l26Q+nx0q8zj+NtHdIG78rVovq5zRyx+Ovz3oubr8eVNEWG+OCGs3IqznIsLaiQjr8YiwYtL+9RFhxezjXkRYT0aE9WxEWG+MCOupiLBijuPTEWHFpH1MvGLK1Zh4jassvBcRVkxejYnXGyLCGte1NuZ8HFf5FXMcY65DMdfHmDInJu1fFxFWzD6Oq4yOSfvnI8KKKVfHVZ+IqUe/NiKscdWZYvL9CxFhxZxDOxFhxdwrjKu+GlNOPBER1riuabsRYe1EhBWTXs9EhBVTj96JCGtc1+2Xwl70bkRYMWX0uMrVI91kdLpJSCwv+nLMf86xdBNFMETa+IXNLc/PmdYnu7lVo/aM3vgbtu/Fbk2LsoFieTd2t7Z2dvc291Z2V2/e7Lkr03Dl33Bs8z8Vl6l8ToljYddULC/H6zagjPPsNqHMcFSxvInivtdC6I/tt0R9juUdJG4B414GhVU/ICyL5cV4jPMEy/BU8id/ttv3/zep/jGSP6liCFUsL+eZRXxZNk2mwet6qGyy9ocVtzNJ+DB92Ietcie2qCx/Hm136nHZhPitfgQrOiwbMxzjWsl/a4d/43ZUfF6/eJZLs5138D0Vz5I/2+1OOdb/jSsdmMsFTBXPwjGFKgYn8Xx386hym1nWiVEKzaP6SNF/FaM0Ae9NiN94TFnG5M+seG9Q3vHGIY2cW72p7nfPqI+sC2NZaIwdxzKjnva2dgc+PxP0HWmRj+3vVYhlVuMYMgdGHc/PcwDHA/dCHM//qSOcA4njwIPPxVj701nvOKfQF84H0tW7p6QlyubhM8+7CfFb3YE1FRHWHPUH+z+oPERYn9vubqdsLX2c1lLc74espVb/l2At/QJaSxH381n3+1b2JMy973xFN+7efEm03gbPF9avU88XpV9782VJ4NoSZcfhM5ZhO+q+CAXrVERYi9SfFLpn/oTOl51Z3bfQ+WL1fxbmyxc584Xtb1b2Fpgv3zP6+XLg/ehhnS+8vgzC4zHn3lREWDHn8VxEWOMmE9qRZMKHQCZ8RcB+lPezfw5kwvcXMsHmfaJ5tpH27pbOuShvHmP7Mc66javNTNlMEP8yWJMVYSVeK/bHdMLpN7Y/6+Cq5u3tdhya5M+jYwrL+jgONimbe6E2KZQVKPNZHn7LIbZJ5c9j7e52liK2gzRkHeagsk+1g7BszUucLyCajU2tC8qvpXIwzVMZ+j1RX+Nngr4jnfL3dq514HI9e14K9J2iMqQv6p38HNG3U+bRl+1MSN9F+MxPDPrOEw7Yx3mBwxKVnRF9TJ0nY5Tn+7FPHEtyTtA4RJZjW9MEK3Lf3BxHno/RiwsYxMZqsBLn+dgf0/NOv7H91DZf9ielyA2BfVP5xGxep77j0GhvMg91T5XTqp71ykj0qTXpt191dM+qvvRFgU8/m8KvVbDLo6xlu/xXgU3h42RTQB3d+EjJbs6nYv0p0/fPEC5Wv1kATZzfYcubZ4lzjwbHDLJMUPJL3XWZImYwVNZafRX/5cUMpoq5UzGDHBfYgLILVNaEMsNRxQwmii9dC6E/tt8S9TlmcJB1k+/fHgTW5AFhWcwg6gO83qA8NTk1rLu8VfwNtrkI/WEZ58XfnCg6otabxayXdouCdq2sV3bzepzq3vtx1bWQTlV0ICWHF9P0zY2F8MZZzREPVsgZAYSVeM+1znNK9Rvbr5r36HY7Dk3y59ExhWV9DNHFU+2dWcaX5ZhkXTw0x+QjjmyMqYsfdK+t2kFYbAdOtS9jv+hBZZ9qB2HZPsV4DvUjXo9HnbPvIvQH6+Pn/OGcfTccnqt6lmJO4NNv//epc91t9rszm33CVv8dsP/7jAKmlxtV7f88/Ytz/SldaFziQg23qnGhjzq8gDm8J8Rvnvw5Q2U4D+eoTMU/KN8W+0zL+OsJ4q+D2hdeDvz1Goe/2P6L/MX2X6TRsGKLx1V/VTn0Q2Q4tjWsHPeqb95ceJD1V6Q166+p9Ay2/6awM2PflMzn9T9Vjm1ei1HmK5tGnerj5/xp0m9vjyjz5wQ+/eTzuyKt/79/uQPzPY585jUecWbfjMEus//u23up/l8Yjv13fYT23+DcwqOw/27e293c2r25d3d9bWtnZXOnRvANV/4txP57WtRPuwfY2Dvc9t+NvRD6Y/up7b+odw0KK4X9t0Z4KvmTP9vt+//Z//SXSP6kshWrM+NnSvqA9JgTfVCymsfpTB9YfP/TooPXOQeWyR+Ehe+zPQVxYPmbyg4dKn85t/tcGnxWQ+iaPxzLE2LjVPNsEL15MSIs1hERT9YRE9nVVzx9ZVHQsJ718jTOLdZnvsPREavG9s4JfFKft+dxSDMHqsfDcf9jnJn+wnYHPj8T9B1pUfX+JzWOIXNg1H5LngOhfssfTTwHQmxJiCvbkpCvWC9NFZuUNldSx+6gcjdhn/AuVJ5HVeQItqX2JCnWS9U3T/dUNn8PVug9pgZrXO/0SnEvU/6wnL0UsR2kIfsPVJxh4vm0LyPtDmCUkZcFrnWqj5/zp0m//TtHRlbdY3m2YqQ52pJ+kWxJaJ8JsSVZ/X8OtqT/4NiSjI/UfgPHHtegMlsS5wuw+n8wHFvS5gjzDwbfJT6S/IMld4nHyD/o3SWe6i7uQ55/cDWE/th+6vyDbDMeRS5DlX+QbUme/Mmf7fb9/yx/7IDYKPMPch+QHouiD0pWh9h/EBbbks44eHnxbCZ/EJa6l3yW6lp5/iS2HwTbkqz9acI1Mj6rvH4jXZE+ni2JYwdS2ZLORITFvinE0/p92G1JZwp5EmMf3RD4pLYl8TikmQPjYUu60+7A50fZkowWVW1JahxD5sBhtSX9L4nnwJR471Yc2myxHhAR9h7HscSDvbY6uv1N+PrKd4+ntj15Npj84fVV2YuUrYPX10HsUuciwiqLr7dy9d/a4d/K1vH8Cc2n9JnzHbi4vobmU7L6HwZ7xXYBU9kk+Lww6y63iu8rAz0b10cXl7J2I3Susb0gUeyce2Zc6YWebUPtGXkMD7r/zB++82cQWDsRYT0eEdYbI8J6LhKs/PNMFgdW/sQcx7tjCuvpSLBi036nHQ/WuPL9TkRYscYxf2Ly15MRYe1EhBVzHGPKiViyMH9i8n3MPr4+IqxYfcw/T2dxYOVPTLl6IiJe9yLitRARr5i8+nwkWEc8UR3WCwUs3lt9kPwfqCtE3Lfc885BJd4z3atRe0Y//A3bV7H8hnfsWP611bWVzZXdu3d2d9fXt7bu1Ai+4cq/sf9V8Ybaf6X1X65dP9yx/GvXQ+iP7atY/segD7HGUsUYp45lOtxj6efqU2Npfma0OcwQrjMA61YUPNfWOW43HuyNVS+HQGI/Q7BdmGVr6vws/fzsnt+Vz3qnOvs6ExEW5xBFHq6V/Ld2+DduB2GF2oX/GdmF8Ux6iF3Y6n8Q7MI/SXZh9BvNZN3vW9lPg5/K7t5Q73OcMo4Nxylj7DPL6VT+vHE9Hz1IziY+15NaJvSLl/HiN0Nib0LuaERYieOR1kNkIbY/aB4D1W+ExT78FGfrsW/Kf8Rr/ajzLHEOutA8Sx9z/O9Vc9DNCHz6yfePV/D7oazlvemfBvn+Xxz5zmfUEOeQM6cIa64El+Ot+//TyvJOzlPF/6nvaA+VzWV+ZiW3sSxFztNQvYjnHNb3cp6m2ZvonKe8f2pA2Xkqa0KZ4aj2VonyI6yF0B/bV3EEHKccQ8eNAatxQFi2f1TrudIPeb0ZdczjHPSHZZwX8zhXyEa13swJ2ilbhlpvhnS2cmNc9Wd17j5URo/rufiXgv6scu7NOrhyP/LndjsOTfJnXO+jtz6G5J86rDkHP9mRjTHzT6Xal3HO01S5yNhGdVDZp9pBWLZPUedUeT1OZJcOvvOCz6mG3nnxxxyeq3pOdUbg02//9xmt7jYPuv/bg/3fHy9gqv2f4az2f57+xXdlPIj56F/l8EKMfPQq5+kMlan7Y1XOUz7/gDBT2EtT33Wq6It9innXKZ9dq6fpm3t2DfFn3uG9jX0+CB8qWIn3UMF3nbKNDOsPuo4hLLaXpsgRrmQr9pVlZKL55MpIdX9mVRn5vCMj60S7fnyu/D/91su3tXSbZesl+7Os/jqsl++g9ZLlAZYhT3DuMGurkWl+57Xb6n8V2UvT7D879lLPv72UqO1Q2cxyXuUAnxZlKeylofe1W321R/HspYnyd0h7Ke6B8qcBZUtU1oQyw1HZSxPZ9ddC6I/tt0R9tpeGjqXSw9jGOQis+gFhmb1U6d01wlPJn/zZbt//z77995L8SRPXqPM6WFueXpf2fPXK9VDZZO0PS29sED5l6ynHquC7KvaE7VIzop0Z0c4RrHiwvBwfIfyo2lH7/H761Acq6FP5s93ulGP906BPfZujT3H+kwmBc+L5vuLpayqWqZ71zi8cU9bnvtvRkdWeCH/jMVW6aMr9khqHNHIu3p3h+cN7PIwL9vJafFG7A5+fCfqOtMjH9vcq5LUI3VMw7VOtxcaPpkPgHJgRuNazXp0DbcUcb/iPE8+BKfHerTi0uZcwxniLbS8RYa/xHi4e7BtrIWdSEvmdgvUz9uOmvvvH81HnD6/BofnN2eY3yF2Jn98eP1gsRwaFFTOHO9sfUvnWQuO/f4H0M7QhhehnVv9/XurA/GVHP+OYPiv7VZDn31/EfyfW0zbS2sM6dmqlz6s4xxi+B2trWHtI1TfPJqv2kB6skH0Pwkqs16zzPFH9xvar7p1vt+PQJH/GdY9qffT8x+OinzagPywrPP30fzj6qeKdhkM7tb9Nub/PH441SbFOYd8GlX2qHYRla146/XjtTlofR/X9LPMKxtfwmoOxLjwmfKYVyzB3NOpJ/Ki9rtEpnyM71zpwuZ4981kvfb27k+ao7Jzoo81JL+Ysf2w+cEzZhZP3/6e+m1HZtjkGKNUdmCavU8ad5Q/bLkeQP7FyfvjDnD8xf3hdP2jOw3GG9fYClrpb3Wh42O9W3yjkUIy71dV5fGX3POjc57UjBqwrEWEtR4R1VcAyXnsIfo+5rw2VYdb+NOGaSoY9RPgwfZh2DwtcW6KM7VkPi3YeFu20RBnLnRiwVG6iq/SeuhPHypC3HyOYy1DG6zSOP9p8njjZaSv/wximEJuP1f9lsPm8poCp4n6t3yrO+zKVoSy0fo9wLgXrA+Mwl5Q+YPR5OA0+G4bPNYGPmts5m8xlvWOG+Bks3I/yHRnIQ1epr4l4YYVlAq7h2CafFXhY9DN/mvTbPWcNr3pW4KrAR8khjg9HOcQyCu/m4jtvlgEXsz17uCNvmExTsuMCvVeWS3Ui66UL1kcYCr7B6Cc733lS960sPnQJyrH+l5zswPyuEpj1Epgs+1LrrEbDMp21Rn20+n+S+mX8UzZW3EelK19x2r1M7ebzaOGR7vqKH7Bdxsf6OVlS/yLhYPX/FOCwRDhcEHRQ8QQezjMVcZ4JwPnPOjhfcnBGPuexQx6+5NTnecjwL2eaJjjvLgj4zJNfDX08W8Ib9UzLWFuDRnkX6RmHJpdFfbW39PQwr23kw8eIFsuJaXGlDy2WCf9lUV+tX/Oi/8sVafEqosXVxLRYznxaXCX8r4r6yw4trjiw+tFiu/1g0ULt2epZ+dzCtlCeZOId1B2w/vtBN/i2k91w+R2WQVhmdb8D4H2rgM0yOMv0PpB9QjWBF+pIypZsuqGKjbgCML6L9pPYFt9dhmsb321q730f9PuHT+o6P0C2/FRnqJQtH2OqEKem6ONiSR9/aAzwR/p6OQ4TnxEM3rfzmZ9E/mb3rKbym3vnk9R5FLZbHfQMyTjDYju+ly8u9flHlb9HjVU9612TvPw9P+XYAGLmi4txRjVmvouYPsyYfsqju9z2n+R3ubEdf9x8kepMNtvWVL5qpQexHR959XZR1s8W9Z8i2fH/Cdjx/2/Hjs/5OtVZSbW35LxLyoeY2JYVrA9Y++pu9xRzSfGlWg8T2xz27fhqn618xWjHxzFD/AyWZ8dHHrpIfR21L34J+sx983zxv++s4VX1H2VjU3KIZQ3KIZa5GAfl5YRkO77SP5RNyJMdSlcqs+Mvir4jDAXfYCgdkePhyuTq8YXufqMtUdmAeT9m9U8sdGC+o/h80Bg2a9PGLtQ3kCoezdpScXPKps9xc0tEY2VfPifgsA5S1Sdh7SrfgDrXge0yPmjzUPXZFmH1zwEObGc/J+hQNU/rTEWcZwJwvuzgfMHBmXkdx0LZ2VV9PvfF8C9mmiY4X88J+MyT16CP7BtYEjijPse+gVHco3LGoYmns2P/5rP+9FVto3xm38Bh85NcIFp4fqh++hv7BpYT02Lc/CRIi+12Ny2uJqbFcubT4irhf1XUX3Zoofwkyt7DsYkIC30DKv8w+2g/FXSKWwvdcM/QOyyDsMzqfhbA+wwBm+VfllX3DaBt+DjpQViP9SCVf1rpdUhDpoOnSzAtPlfIf5XryPDK611+pLvfaAtrFO+kvhuM18ks0/zO+pGar2qdVLYazoGvckEp+sw49EmdH7rfHoJ5RNETdRPeO+H7vGaqttU9dTH5bVxyqNfoO9b3+A3f53VXnT9UOkhV/kQYjeKdUdIT+a0qPdkm4O3teQ+OMjZ/+B5Fo6HtI7gO74mt/ltBxt54pBs/Pg+MZbgPZj5R527Vnhv7yGuGuosGeczsA5wX+T1FG6P0uR75WfefIz9rBFgvBT/rV4IcOvKzDgbryM965GeNCWvc/Kzvp73wQf2s3wp+1m91dJMjP+uRn/XIz9r9OX/Yz/qDzhp+5GftHfdx87N+JJKf9cfBbvnKotKRn/X+8y9H5Gf9l2PgZ/2/DqGf9d++BPysv3TkZz3ys2ZHftYjP+v4+ln/G+gUfxDBz/o/Ad7/K2Cz/MuywfysH6ngZ8X9GftZQ2zmoX7W/frFh35+VsNL+WlQR24U74zynlnUf0P8iMiDvN/A9z0/66JDn4msnD6J8la7flbkMb5jWNHT87N666/aO4X6WT1+8/yCo+A3pE9VfmP/Br7P6+6EgKX8goqemN/xQZ6/RiPvvCvTs5ZpvxT7WVGmKz8r2iKx/iMgYw/qZ2U+qRPuhhfvubGPvGaoO1GQx9jPavVXijYS+zOln9XaSngnxGrafMfjnzt2Hj7zM0HfkU5Vc8fGiAFQvJxlvXLtdlGfefkziZePYga6ZQbT8ihmYPxhvRRiBp6ENfUoZmAwWEcxA0cxAzFhjVvMwDsWO21he1VjBr4SYgbeTXr2UcxAEnyOYgayXh56UGIGvsJZw49iBnrHfdxiBt5HcvWgMQN/ebED878dxQx01f8bRONhxQz8DZibo4oZeD/gcFhiBr7dwflBiRn4buEzYhlwFDNwFDOAsI5iBsJpsd3upsXVxLRYznxaXCX8r4r6yw4tRhEz8E9Bp/jJxW64B4kZ+GmA9xMCNsu/LMsGihl4H+lBWG/UZ7N/JjBm4Ohs9tHZbFwnjs5ma347Ops9OD0ftLPZ/zVCzEDo2ez/5tgyY53N/v/GwM965NfvfOYnhl+f6Zs/t4r/K4M9G2n94OMxdsepDMcOeZYfNXYYj3iQsXsQ6TtFZUjfSfjMT8yYl0mBa43wQ9k6CTC22/f/N6n+1VP3/6cdQy1bOZ5gMknb4z8/T8FnfhT/GJ3GgX9WxoB/ZgW+Vm+K8I2MV7DP09qfzlLyesfnOUX4MH2YV2cErhzjkj/s81d7BBVrdZhgcQwU8o7RMDW/h+jMiFud6uPn/GGd+rOKeav8p4p3phzaTQp8ZsV7tZL/1g7/xjwaM55qKSKs1LFZiffGwTFQ1v404ZpKhnl7b0W7CwJXdRc6x0BVvZMVy1juxIBlZSh3ztF7OM8nqUzZaDhmIX9uF2X9fPXPneq0he2FxkBZ/RcgBupOAVPpJtbvkPgoZdvyYhMT++yD9QFrfzpLOrdXPb5U6+Ew4i3zP2UXPy/wwRgodR8wwvJioJT/fVjxGyqOAtucgT5z39CnzD6ndztreFX957zAR8khljUoh1jmqrNtSg6xnVTpH8gbHAOlZIfSlVjnnhD9U3RT8A2G0hFDY6DaJFe92FJsg2NLv+JUB+bHSK7OCLyUf49joFQsRo3qZFlyv5J7FiDE3/heorGKo1kScFgHqRp79V6YmxwDpc4tYrtlsTllMVDsk7b67wMclkpibZAOiBfHQCmcJyviPBmA89c7OJ9zcGZex7FQ8USqPvsVGD77hpQPXMVcMk/+degjx0DNCJxRn+MYqFH4yxYdmoT6y1QcJsNSbasztqOMB0NaVI0H4/tvq8aDIS04BmoU8WBIi5TxYP1osd3upsWVxLS43IcWVwh/FT922aHFJQFL2XtwTJhWaO/Fd1gOW/0Pgk7xw6e64bLfmWUQllndfwDwfkjAZvmXZdVjoNAv3SY9COuxHoTrEsdAoV5X5s8uk/81KMf6HxbyX8VQoJ2/St6FRPsZN8ZHndfy5qtaJ5Wtxvizat6USYc+ieIH1j0e9nSl0Jgpta/iNVO1rc7ExeS3UeShUTKsRt+xvsdvXkz3pICldJCq/OnF6I2CnshvVenJNgFvb897cJSx+cMxUEbDshgo3hNb/V8BGXvQGCjmk7ros9pzD+JnNT2O/ay/PkZ++kS+1MRxOr58xj7xOX7lV+b/BquMdsPy+3prT/54+QuQBmWwQnyoCCsxv67zvFL9xvar+rtvt+PQJH/G1d9tfXyQ/d2TxYKVyt+taNfKummXKtcVr+tIu0WHdriGLwna2W9zEWnXEvh4sFoC1kyBY/68890vfPF7Mnoa9N2UEHtYybCGX0bv2cRAeDX6rDap9v1l4r2QSdYi+LeK7ysDPh6jqIGpyihnE08yVuDyhx3cqMCxYlqH98wRM+gi7+GeP7epHRUQk3hjGuyUtvans14eTaGsqI2I4gkOtMF31aaDF0e1gTkj2jlMsDhIDXmHla9EG8p9eWIGhkamHSec5AMdAmicYGfQuiNPqib5mBL4pAgGO0zJtQ4KawTJhYKD1MYhudBFh3aXBa4tUYZB4ViG7VwW7bREGcudGLCUMdJLgsNruAroUEFxvH7i+GMwxeNLnbawvdAgNav/KghS+4ICpnIicDIHFaznBR9Zf1DB5bk0bok7E+mlbuJOpQ8kXtf2g9SUA1dtSDBIrcwwjUFg9nCQ2ig3jyrAxts8hibbvJt486jkUI3KUA61qMwLfEM5ZHtIJQswIBbLfr5AKi9/a/F5Sryf/90qvq8M9KxfV4ep4sFfWw3ZxyQ6CBisA7DRNfU+xjMo5w/rAC2Bq+LxWfjMsseTRy1R9uZ2PFiPR4S1FxHWkxFhPRsR1m5EWE9HhBVzHF8fEVZMXr0bEVYseuWfp7M4sPInFk/kn09ExCsmvWqR8MK1MfFafDPkYGqitXK3Ru0ZnbLMXyvHxUFptJsVuLaoLH+eb3fqcdmE+K1eAiv/fCyLB2s6Eqz8eWM7HqznIsJ6KhKs2LRfiAgrFl75c68dD9ZORFh3I8IaV159JhKs2DzxRHs88Xo2El7583REWOPIE/mzExHWGyLBiskTseXqyYiwapFg5c8L7W5YNQFL7fGtbqiec+BgBkZssQSBS/T+7XYvXCZcRt8X+5RfErDyzr7n9P3PKjKSo/DRSMNZdmZKcMX/+TMhfguJfGJlM0Y7COtRascz+uOEGIXR39ofltH/JOHD9OENwaLAtUVl+cNOr6o3Ox0GWBwEgLwzbAdCv+izk9AfrI+f84eDij7hOBAU75x0aNcS+MyK9w4691MEFBymm78Sn0AKdgCMQ3aN8w7tLgpcW6KMgwCUQ1IFG7REGcudGLCsDOWOlwWiRWXI2xwEgLzK6zSOPwYBLJzutIXthQYBWP0/AkEAS6TDKBmiMip4tz3gqTbmH55LiQJYgvWBcbj5Tq2Hwwg4yv9UsIzK6IRBACo7DcLyggDUScrEvLC/hmMmnQnRJt+4eUn0M3/4RoWXF3Moxo2bFwQ+Sg6xrAm9iZ7ll3cLuNI/VMZ5T3YoXYl17gnRP0U3Bd9g9JOd66d138qy0XDQg9XfOt2B+Y4SmPUSmCz7Ut8wq06bhJzg/nTql8pMclLAsc8HzWbz6TCPOKuM4gdsl/HhG+m5ftmNa38ccOAMLScFHRAvzipThYfLcG4F4Pw5Ds5LDs7I5zx2yMNLTn2ehwyfT9uqrAInBXzmyc+HPp4t4Y16pvdJnFVmFCeQpxya9DuBzFkBTzqwvNPk+cNZZUaRYQdpcdAbPkIy7PSjBWeVSZ1Z4nwfWoRkljjv0OKcA6sfLbbbDxYtlJ6pbDOcdZflSSbeQd0B6++CbvDC6W64/A7y7Skqs7pvA3jPC9gsg/NH7QO9rDL2LupIypZsuqFyTGA2tHfQfhLb4oxhVvYlxTsquDOmXqRO/2Omg0Ht+d4tMakPPw4ru4Bnz8b2B/U5YFvTWS/PDctW7znU1H7Mg3WyIqzEPpP9MW05/cb2Pf9OyJiqfiMs26/FtFkr+lrf5rPevvLhwtR+BZP9ZX6FWegP1sfP+dOk3/6iY5Oo6jieEvj0229/3WndZuh+2+r//sUOzK8n+YzjZnzk2SJ4bjYyze+8Tln976N1Kg1vbG4ZbXF8jVZpbQebW6GyueyQKeI9LcoaA+B6Y2N3a2tnd29zb2V39ebNHt+c4cq/cfCC2m81Rf202X8314zn1M2CVtaAsiUqa0KZ4XgcYKTd726uhdAf22+J+mwzqXrwWWU+iwFr9oCwFrJeOe3t34ftx+633rAfO3S9+UFnvYnhx1a6UC0afdZ2pkR/48Ff3/V852nn6epqqEy39pXcTqFve3av/Cnz7yuZgnYmDpZXNih100pLtMMB7geFlT9PR8TrRES8XoiEV/48HgmWmuuDwDoVCVbMPuZPLF7Nn72IsJ6MCOvZiLB2I8KKNR/zx+aQyaoTUMZyPs1+PlzOs13lRBJ8fLvKCUFX3vfguy0qyx+eO6dEO6dEOy3RDgeQDwJrOhKs/OGDJoPAei4irKciwYpN+4WIsGLhlT98gHhceOLpiLCejQhrHPkrf0zOzwvYJtNMzqMcSLGXU3asadHveta77qBMZjvXdKFcq73csayXdscc2p0Q+PSzHc6d0W2G2g6t/s+C7fBkATP12CT28+zb7JUNF/vUIlrjGNVK/hssLrO2prNenk+hL6i+eTyGtppYB5IR1pQoSzGm006/sf1ZUb/KmKp+Iyz2w6Q4N4R9U7KU/TCp/KaeLG0JXKvK0k+KKEunBD79ZOkfiSRLvx1k6UoBU42b8dF81jsf2aa6b+PONL+zH8bqP0ayPA1vbK57fkhreyFR26Gy2dqfFfjwPg/LBvHDbN7b3dzavbl3d31ta2dlc6dG8A1X/o39MCo+8rSor2yz8Wi9saf8MBjHkD8NKFugsiaUGY7KD5PGtr+xF0J/bL8l6rMfJnQsW6Id9sMMAuvYAWGZH0b5WpT/mNf6Ua837PcPXW9e7aw3VXUhJbs9nWBcz/iOS9yQJ6PVnOQzbQedR+MMyzvja76gtGutf15CjVU965Xn3u0cu86crOobVXGoinZsizisfuW3R6TdCYFPP/35XaQ/e2cucb3iM5cfv9CB+Z4jW8T+Uyv5b7C47MgWkXRNO7JFZL19fVBsEV8zYlvE10ayRfwYyNKvI1sExuyzLULxb436o24uzD+zLcLqf/dQZPnmZojencgOEqx3s5xX+xmVd2egmNA7G7sbqys7e3f27m5s7mzyOm248m9si1C6xFlRP7HdZ1XZIlBXyZ8GlLWorAllhqOyRaTZo22uhtAf21fnANgWETqWKn6QbRGDwJo8ICyzRaj1XJ0nMjk1LD+i0ajMj8iXIyBN8YxYk377AWe9qXo5grce8017t6LQZ2PLy8+WVg8LvwyA5WqiGyxdfVjdxOmtAWpu8RgedJ7mT8wE67sRYT0XEdZTEWEdXXgwOp4Y1wsPno8I64gnRscTHK+EcpZthIlsCivcj7Jzd6xn4PqAfWLb2sci6hknBD799rUfP6PbDN3XWv0PwL72vzj7Wj6LjroRn0XH8ea1OYXNBnH1YqEP2o4XT5Yijy7ScFhn+BP5OYLP8HNMwUFtbtjW0Rn+JP0+OsOf9faV98+j9huyLz/Ub7hQGKBi+PI9233Zunb6rG6z6hn+d8K6dq6AqdY14yO1rpUl0i+z106V4LJetJ/YZro1wtix4DP8o4gdKzvDHyN2zDvDnyZ2TJ/hPzyxY50z/OMSO8Z2oEFgTR4QVkjsmGevPaz7qJvOehPTXptIf94YV/1ZXSYbKqNZDqe+7FX1zRvnB1l/RlqX3aeA73I/8ud2Ow5N8ufRMYVlfVS5l3juJxrHHj2iIfqBuNWzXlmBa0GTfnudIxur2ufUReip92WcA3IhYjtq/R5U9ql2EJbtU1S+T16P0+h+/t0wKv9Pnerj5/zhvM57Ds9VzSt/TODTb//3lkj7v9fB/u/tzv7PbG5q/+fpXwtUpnShwx7X/2URbQEqn5+y4x6jMmUbV/ZSvoA4lcxPHNu8zmsK0lfdVRDDXmptDcteqvrm8Y6yEXiwQvdqnOdrFDo80pp1+BR2zPxhe2mqddmzlz4oOU+/LrGM7LdefkPF9ZLPClj9h2C9/Gu0XiqbqLcmMi5lZ23L1u4PHtlLe2h6ZC896HNkL82fmPbSg9o4FayUZ22bUMbrTap8/57swzab0B9eG3GNYNn49531pilop+abWm+aRJ9EOuDGuPqmkU5VdCBsazrr5bsU+rPqmzfOai/owQqJ80JYozzzh7Qus2vhu8pOdbsdhyb58+iYwrI+Kl2c5/5htVf8XERdvCnwGXSvrdpBWGwvTRXHYn0bVPapdhAW20uVzXZc9n8L0B+sj5+zrHf/9zGH56rqRWov1TcOlPZ/uKcK2f9Z/eMYB0r7P5wLbC9FnYb3+6H7xgfFl/2JxL5sL+7Vi1VV9lKWAWX89T+Iv5rQ9xB7vNX/sfMdmLUiibHir0YgXo1z3Xj14/sm4WX13wZ4HStgGh/ifjaFDpxIT9zXl/BO5AnRJ48HqqwD2NZ01kv7FDqw6pu3LjUAH7ZTKFiNirCmRFmKMa1n5f1W80fhyv3In9vtODTJn0cjwvqciLCsjyZ3mA/yJ/E4rrAcbYh+IG71rFdWoI7FcvZqIcPUGqR4p+7QribwmRXvVZEVqh2ExTpwCt0U+zao7FPtqDXL+CpR7piNxOe21z09RuXiNLpOZgejK7Y1TbBSrSmqb4i/p6+zHbOqvufpw4ni7/bH9JjTb2x/1sFVxcvwmnJQmuTPoxFhfU5EWLymKP9W4nHcX1Ns7jVEPxC3etYrK/BcXpN++2xnTamaw2dS4DMr3htUBiMsXlOGdQbxoLJPtYOweE3BPd8gfj961gx+ovwOO8qelhEN56Bt1kHmoYz3MhwXjGXse8AytFEhXfmZoO9Ip3yefPAVHbhczx5F34jjt5HYnrLLY4SPGiMePxwjHj+O88EyHKPjVIY2PaQrP2r8jE5Vx29c6MvyFOnLehnSl+XWuNH3OJRFpO89dYY7o/6qM55KNjF9cVyYvuxfwTKVTzWUvkanUPrOEw44R9UeuUllaj81T9+RbiG5+3Gsh7Wemg7n6VHYV8OR9aSvLPSkHPY3nStv73Pb3f1Se9zEvB+cX8/aH5Zv+zjhw/ThNWRK4Jp6/zCusN5ewGLbX/50xQyS7Rz5WdmiJqAc638L8PtfE7yvZAH7B6zsbw7H9r6Ca1tGbZ0QfXw/7H3OPqLpVs+0LfLz2t19SnTnoZs/F+nI97eeEPVxP2P98/L4eG3jXH6MaJFIZ9qnxUwfWnAcjIoPQP2G16kTDqx+tHgV0WIuMS1m+9BijvCfE/VnHVrMOLD60WK7/WDR4riApe4lMjmo4v+QPkrWZOIdPsM+Jeqruc35oD4EcvxVhW+U11qDof7nT4j+pWxoKe0z+WN2v5AYqER8uG+rs/0B6pjYJsdA4X5iHvrUpN9+wrHVjVsMFO+VYsCKcZY1ZvwV76mxXuLYp+B8rta+OkeQQsdX5wIWHNqpc60tUcY6ySB3rrJeHgMWx/xhv61M2TS9s9XqfBfLU1xPcB/wK7QPMPmD+wC1Vjep/uMQQ/OfSPdXMk3FA85TGc4JjutF2vJcwnPOo9gvW/vTWS9/pphLS4RP2Vwy+pxOg8+G4XNG4KPmSc6vc1nvmCF+BkvtqRQPnaK+JuKF/TX8NOA3IdrkmNLTop/506TfPuGs4VVjStU95UoOzVEZyqFTVIb2S5bHKIfMzsXyBXFH3jCZNu/gNyHw472k0qfmRdsKvsHoJzsb53XflOy0OlaO9Y+B7LxVArNeAtM+DytuX+msLYEP66Tz1C/jw7KxYrqp8wILTrsnqd28fIFsN4of1N6tRv2cLKk/TzhY/UXAYYlwmBN0QLz4zF4VHi7DeTYA57MOzi0HZ+RzHjvk4ZZTn+chw2e/IPZB8RLPO6t/Gfp4toQ36gJm/rBdbxRn2bw8lf1yhbGuNefAUm0jH7JdbxR5MVSemRp9x/ooO/jM6EkHVj9asF0vke637vUNaXGK8Fd7mEWHFgsOrH602G4/WLRQ+lA9K59b2BbKk0y8g7oD1t8C3eBTznfD5XeU35h1jU8DeDcFbJbB+ePZ8llHwndRR1I2P9MNVRzVAsAwnUjZVw2e8k9MEw3svc+Gfm8TfsonjHbQGsFqFH/5byp3O7f9Kmj7cwdsO3+Uz4nHBv149i76ANUawOvzAvTH05U4f91roL8vnC9vb1C7gJXhHOd1DPdb3r7J6qt9LO7f2DeG+74zAbDmnLbPivpnnLYRL3yX22Y87T2VH8NoY7zcgLKYdpW8L29+ZQcPxDF/mu1u2qhxxPohtFTj2KL6SLuq++UlKgvZLyP/4nyJLZN/heZ91Ts+DB+UcRPwe0Zw2b/0LkfvRp8Yw8yfcfCnI02q+tOtfwf1p+MaMQ7+dO9u05j+9Jk+tGC9O3Ueivk+tOD109OVsX/K7tWqSIvtdjctDtvelGmh9v510Y7Su2egfibeYT3N6n8V6C0fIr2bz8/jnDc/Tz3r5Xc8j1AGa9aBNV8Cq0a/YV+xfbb1WP0PQV+/lnQ0pBWvDSrmQ40Zr8c8N3nsTK4xv5gNi+twv6z+N8A6c6PEvhOaI8Hq/zWxdindCc8BXIZ63NdG8c4o80/iWHH+vn45SDn3QFlOZqbPvEOfSYc+ic6huGcbVa5gTxarPajKv8DrvWobdQDU716s0+68v5/DI+ulJ8JoFO8Mi5799KEQeobm/2WdYVLAQhp79DQcFT0RRqN4Z5T0RH6rSk+ev1if7TNoR+Azn7g34DFSNi9cV73xqsFvvL+piX5gXhB1RoF1Tk+X77e/4XwiVv8jzv4Gc/6F7G9GkU+tqh6rYujU/oZhqbYxzp/3N6NYG5EWVddGtmm1HFgn+9DisPsVOPeT51foR4vtdjctEsV4rHt9Q1osEf4qHueUQ4tFAUvtb3BMmFah+xur//Og8zcvdMM9Rrh7tlil6yg/2gkqQ5i8Zi0Czkrucp+s/q8E6uaGl1rbkcaN4p1R8pnijVA+49hBrI/nz5g+iw59mg59UsskTy6EyiQln1WcVJV1L388XdJwVPREGI3inWH50fvdRRDiR/fuo1J349SyXj5iG1D+ePTEM8RMT7SLNIp3DqsdjOeviu9VvlPWv0PzAaLP1dYEb7xq8JunmzcBruUS5Bx800V7B/EJsG40ivgTXAerxp+wT6DlwFJtez6BUeiJSIuqeiLfqTQpYHFdLwYj7T5qdV3pDfaoswt8hgbXdM5Hjj5Kzo1xRtDBytB/ifTjZ4K+I53yebhzrQOX6+Fn5sFB9u4fJ/lgbV9z5AOekwrZUx+2OeHtIxmWalvpKYnPAuzTYqkPLU4T/p5vH/un4j1OV6QFrxtnEtPidB9ahMSMnHZo4cWf9KPFdvvBosWsgFXPyucWtoXyJBPv2PxjGfWpkD/7NRfK8eH9v2cX6jdueE7uxTrtXjwTx++s5TL5Syl+p+tsS7u7DMdysihrZb3jzrJN8cAZQQsFy+aGGo/TQCcej4h0cvPQY5t87jc0D/3nwxo56Lnf0wIfFa9Udt8QwsD54OETqi/MAtxvKNEXnh5AXzjstlbWF046sKrqC4fN1uqtC/gu04LpNlFSpnI38N4jTVzW6oY6C2uP2l/wGVqc47yHQNnJuV/PCppZ2TlBo1rW+6i9B9p1quw9YsmSt5TIkncf8r1HTFni+W0Ow94DafFS33sgLV7qe4+YtEi598BzGFj/q2Hv8S3O3sM738X26UH2HkM6O/DA7T0SxTi4ew91X3PVvcc3DWnvEXqOAvce35Jo73Ga9AXj9W8V+sKwYvT7nVcIidGfpjr5o/z9rBuouL7E/Q6+z8twU74C9NvxOfjvdfh62qGdtZVl2tc27dDuBNEutT2i312MTLvQuxh/KCLtTgh8PFgzAhb3F+ufEPVnso7f5Z3vfuGL35PRM0nfLaiCEWPnkAkYqztVgmCrBH5ZEuQa/c6LuDFQ1uedlgNfBSmHCk9790VHT7FC8mGEDzubLTzgELLZGkXAII5l1YBBTpJdNWAQgx/GwYg1iNNr0IBBpMV2+8GihdrQK+EcekhIBfHwvPxXsMH4tQvl+PDCpgzboeM2Bs6NVbXBwPFttrvLcCx5g6EScSkaLkLfmIYpFADDpUwB4EuDFkQ/XqQF/fYrjgJQ9dIgFUymgp9OUpkKaEMe9vAJXdeOAdyvpXXN6PgbzqZgFAFL04Iunvzi9Sd/vIClWdF2reS/tcO/MQ8gLDscqYKobcwTy3s3CaByQlRNAvj7zvxRY7To0E7NAyXPDjpGyvgyKKwzEWGdiwjrvIBlvHYBfo/Ia8GJfK39acI19rpYo/YMH6YP0+6iwLUlyjgA+6Jo56JopyXKOJFvDFhqXTpP73mGLORtTuSLvHq7KDP6oc6EySiXLnbaQvmDhyjw3e12pxzrf9XFDsyzxWfl8GCjN/LZaSrDOWH9Zn6w8vyxuXQJfo/Iu8GJfK396ayXP1PMpUuET9lcMvpcToPPfiLfKwIfNU8wkS+OGeJnsLxEvshDF6mviXhhfw2/DPhNiDbPQ5+5b5ehT0367ZOKjqg1HMfWG28lH1nWoBziZL0ohy5SGToqWB6jHGLbltqzIm9wIl+Fn+dMs3FW+pRy4Cn4BqOf7NyqIDtrWW9iI6t/E2Tnu0pg1ktg2ufETlBXZz0j8GGd9DOpX8aHZWPFTsVzot3zTrvnqF2VyFfxgxf0ZP2cLKl/mnCw+rcBB06Ke0rQAfHiRL5VeLgM58UAnB9zcD7j4Ix8zmOHPHzGqc/zkOGfyzRNcN6dEvCZJ18NfTxbwht1ATN/2GZ8jnC+VXxfGexZZ5pnmbYNMk3OifpIc9a1TjmwvECG/OEAnUR7mXVv/UNaXCD8vb0G9m9e9P9CRVqw/TyR7rfu9Q1pcZHwV3uYCw4tzjuw+tFiu/1g0ULpQ/WsfG5hWyhPMvEO6g5Y/3nQDd52sRsuv4N8y/Z4q/sOgPdWAZtlcP6ofSDbNcuSUZqOpAK9z0O9d9GeEeGxzRthWJBMYpuoGwijAq2qBsL8CUffr3pxx1Ig7ThgYNT2zoNeetKOSLsTAh8PlpdAVulqJ5z6ZwLr9w0wOE7feROGt7ngY4uX1WWHfllm5FZJR8oCEY4TXHw3o++Mw0TW+/R7NxR2WVlVxw5mq3pXQQylaHHEqAnEsg0kC3yr/14Q5H87ofHNynAhZWURjRqeccLqK2MRGknYiY3GlSsBsE45bS+L+lecthEvfJfbZjztPeWQNtqMIls2Gg6b7W7aqHHE+iG0VOPYovpIu6pGqUtUFmKUQv7F+VLLevllEMXHDOscEPEdzqbzKFCpA6tfkMdhz1hxFKhUTotRBCp9CNbQj14sx+coUKnzvNQDlX7K2XiMOlDpoxf744NrS2ig0h85o+GWZd2bhXKs/3Mw3z5Rslb+mwHWSjbEjWKt9Na3qmvltAOr6lo5isAxLztVv8Axb33gPQ3SkI1DqU9JGS6NPv1Qp/q6ZC799muOnFFjj795xqGTDu3YODRqwxrTLtSw9lsRaXdC4OPB8oxDSicaC+NQ2SkSNg7h8RmelNjBB8k4hItV7IV1jiKAbeH8A2cRrJpGYBRpOHBjUDUNBx8V9NLaqra9NAKHzWN7imix5MDqRwtWjhJFe657fUNanCf8lYf3nEOLMw6sfrTYbj9YtJgVsNSiGZpGQBmQWUadKixxuRz75Evl+HAaAbXAh46bt3nGDWb+NKAs4pjKNAI4vs12dxmOJW+ecdxZtlWN+POiG3A8zgGdeDxSKHnWrzIlj9MILAma5E+TfntZwXMx0gicE/ioNAJsmEb+NRg4Hzx8QvUFTCPwdYUlXBmiylKplG3S2Shm9VdhXj96qby9kKsJlNOJeROdTrymqShndXLF6nsODOy/cmpdDoDVctru59TitpVTi3HJBJ723ghloHQsYWRNs93dbzWOKjrco6UaxxbVR9qpOcpp51HWeNHOHEGtosVwvtSyXn4ZxKG8QPPe0x0snUHolRhW/wmY93uXytvjuY2pKs5RWUvgqeQFR9ypKC0vTYPHX2ru4dheCoA15bQdQ+YwLpnA095T8x5TqORPA8pSz3vc8/C8V+OoUiF5tFTj2Mp65Ss7hnFu8zUHOH/52macTywvkE/R8L5H8z5W5ovHi06oFPesL/ab9xwRbfXfDvP+z14qb8/wUvOeDbLnBJ6eLjCseY/jFzLvJ522U857xHNc5z1G3obMe6yfct7jWsVXFqo1R8mLc1SmdAGcL7Wsl1+qznu82uC5YqPhrbE1wrts3qNcwPp/Hub9+y+VtxeSvtHT5RX/s86ixt8zpMfQtT1YnsxZFvWvOG2nCCBDJ1f+NKDsQQog43m/DGVeANkMlSl9z9PllS6AAWTvp3mvrk6twW/evJ8BuO8oOpFy3n8HzPt/dDTvu2Adzfujee/N+3+UaN6/v4gYSDnvfxzm/S8czfsuWEfz/mjee/P+FxLN+/9UGCfVPGQeM1xD573V/48w7//AmffWXzW3L1OZml9WdhXKlqkPD2edJ2RfeE3Uf5jqYNsPQdm1AFjevH+ZqH/NaRvxwne5bcbT3lPz3mgzinn/EODM816NI9YPoaUaxxbVR9qpzCY871GWPERlOJ9YJixD2dXiM86X2PP+CZr3Dag3l+k2+wW92u8qvqYOv/HYqNiEJYG3stuX6SYIC2n2GOF6viKu/U71s63RO9WvYHm26X4nx5lO3in62G17PhnOmoX6I48nZ6vj2I9zor+KT7ktbge/Y/2GgG9zdM6BhZmiqs5Le/fFdb4w+Bsdy3CrMi+HFYenAqonoM2QODylUxkt5hxYqm0170cZh4e0qBqH5+2J7F21fmMWtvxptJP0+3pVv5zX3yzrlT/94tF4rqLsm3Poc2aE9Kk79FHrvLcuzYn6ak+tZNkSlaGc4Xbqop1QOWfv5nLuA4Wca1LZZqFAqbjjOvQ9JO54FHMc6Vp1jlv/QmJtVds4NuOQHQlpMezsSEiLcciOhLQYdnYkpMV2+8GiRV3AUtmRkAZKnmTiHdZTrd7nFzIql2P3LpfjM0G4erpov3Hz4o6HZJuTccfKB6/i8Tju2EvmcdCMxzg31HigLYPHIyKdVljeY9wxton8x3Toiuem356DNZLjjtX6XHdod0Hg08q6+Rf504tjwPng4XMQfeFtpC9Y+887+gLu70L2R6OQhWqfHCoLvZinkP0+7plYX0iUwXjd6xvSIiQ2SmVnVzaistgmNe/mqe45qrso6qY9x7B6T8lTe9hHgnPVytAmeZ7K0CY5R2XLWS/NrOyqoBHOLXsm6DvSqerVyWqPHypLMFbyM0pkyVcMIEt473HYZUlV26EnSxJlfl/3ZAPSIuRcBc4fliXeGY1+tOA15kpiWlzuQ4sQX/RlhxaeX7sfLbbbDxYtFgWselY+t7AtZXvGdzApH9b/Jth7fP/lcny8PSPr2/3Gzdt7DCmRnNx7dN1k0O4uw7HkvQeOO8s2xQNXBC08n54aj8tAJx6PFHsP61dZ5nq+5emioEn+NOm373L2HlVvebos8KmaVM9g4Hzw8DmIvvDxQtFTfgj2QSkbX0PQwOr3s2sbTiFnzhUs76xiPxsct61scIxLU+BZZrtEfOYELBtvpDGf11B279AxtnfzMf5nNMbKJ8lzC9tEPIZ9NqzquYZBz4ioMS6zQyI+ak/mnR2PPY8/c74bfyv7aES9P7Wuq+askofe+Ht6/xkHVlVddzkxLa70ocUy4b8s6uP6zfrdZQdWVV13+ZDTYlHAiqXrGs/xvPwV0HU/4ei6HDfoyc9BdN0h+Yplckwc32a7u2wZyljXXYb+cwyl2r8M60YndYOZineoZ71z0bvB7Hci6qdXBD7K58D6qdojIw97+BxkXfvFQvngdfkPnHUN1+eQdW0U9mDUCavag71zAgyr3xlxtmeNwm6BtKhqt2D56Nlw+tFiu/1g0eKMgKX2xHy7L8+hLCuXCzwv54uG8rn78JVyfPg8i7IPhY6bt64NKcZ7NZUNh+0uSodNHAezwnIJ1zWl69Sz3rnYdc6FfrtcdFitayp2QI29sruwX1f5ENUeDe0uxsMePqHrGt4c+K5ioqtcEBxb4eVoRP1yQrTJeSms/iuB5rx+2juh6+co8vt5Nox+difrX4jdSbWNeQh4/RyFb0ztFzzZ6Z0rrOobQ1rwHnkUvjFll/bW25i+MaTFdrubFqPQJdQeKFSXCPGNqbgBjkdAWGX2Mt4jW/3PAl3ibVe64Xo2fs6lw/s9LPPOeSDMMrtnmdzlPln9x4Tc9fSWvN5lqMc0bhTvjJLPqp4HRj7jHDJY3/JXK/pccugz6dBnFDZMXNur2jA5V46KdwlZ9/IHdZMX67Q77xuOip4Io1G8M6y9cz+bcBUfAtJI2TM4blXlG0Iae/Q0HBU90TbSKN4ZZSy7lyuwnx+N5y/Wv93uLpuA91g3V/HDVqb2oLgmeONVg99C80M9UWJzepejM/ezObFudNhtTucdWFVtTqPQE5EWVfVEz85Sllu2Luhm9zKk3Uet7ii9wR4VR3mOypTvRMVRLlLZVUEHPv/O9ONngr4jnarGWMbau38qyQeTHX8+4p56FPJB6fGh8oH31N4ardr29tSHbe80qE3a21MvJ6bFlT60WCb8l0X9Kw4tPL9zP1pstx8sWkwKWGo/izRQ8iQT79j8Yxn1AdhT/8iVcnz4rJF3RrHfuHn2ebwvIX8aUJY6xjKG35ll27KgxbKgRYgPG8eDfdiJzv+6tn5lQ61q6/+gY+tX+vukQ7srAh8v15Q6F4Y+7B9JtJ/4tYLx1VlJHOP8L3QfUaN+Io51+K1qXGSVs8mqbaXne3LCw7WfzsEyqmr+6Qmn7X57AO8C98uJ2+Z+e/sPjl1VPrAs02uG8u0pPuW2uB38jvVV7kObo5MOLJVbJXRe2rs5/HaFedmP11PEH3uwPP7p5/PhtpWsZFwU/5T5ysrGmGOJhjHGOzTGkw7+is5e3syqdPbOsCpY3hjHyM3PuKgx5v6oMZ4UsNQ6zGMca319nMa4DDfGP8RONwp/LtpJh+3PVf6CUdrpkBYp/LnjllcqZj7YfnYK9i2hPo1nqZk+l0ZIn7pDHxWr4emX/eJEQvLXqrWM24mVJ+JSMRics2Vm+f7/GHmlUtsdFc1xjofo7ecFfULsjv32SuNgd0RaVLU78r7Aszv2o8U42B2RFsuE/7Kof8WhhWd37EeL7faDRYu6gKX8U0gDJU8y8Q7vIa3eteX7/3M59inL5fjwmu3pzKG2jyO7YzW7I47HuNkdkf+YDp7dcXP5/v8YeaWuCHyUbZFjTZB/0e5o88HDpwa/heoLn1YcLuY4hs9Yvv8/xtmZw3YmlO12Zx1Y/fJIv9TPhHpnZ5YPOS3OCFjqTGjo2Rl8x3iO5+Vrlu//f/HOy+VyfNiPiDwcciY09OyMwX1QzoSq81BTWS8NU6xr6kwotslnZ0LPhN5Zvv8/xtmZKwKfQc6EGg97+ISuaxh/84oT9z8bLZpF2VuX7/9X61oT+hyyro3C7nca2qxq97P+KZkQYvdrwm/jYPdDWgz7HAfSYrv9YNGiKWCpdQ1poOZQlvVf16z+ly/f/5/P3b+0XI4P266Rh0N8NYjzuK5ryr6rzovyuubFlyEN0TY7jHVN5eLCNpFneC56ubjeu3z/v1rXcJy9sVfrU5PKQu29BgN52MMndF1rAtwz0/c/27iizYf97/3uKZyAcqz/jcud9r5vuby94opk6Rs/TWXqvnflfzpLfVBrmudvjeHz9GB5/tYUuaYygad3H/ko7ylUudC9cayat0uNY8h95KeybhpgGa6bPLdVLgIrU+sOzpda1ssvVef9BMB9TTGgKkaB9Tqch8ezbnysv6Fnwa3+Dy/f/x8jbj3ReuPeS4I0YRlzVtQ/I2gyn/XyDMNSbXtx66M4F4+0qHou3rONVT0XPw5xFEiLlHEU/Wix3e6mxSjOdiAtqp7t8HK12Lt10Q6OCdOqLEYMZRjW/+jy/f8v0vVqN9wlwkHxLfeF9aL8+YK2btvay9v+V8v3Pyt5zLIa59ZxKlN3U/D4GX8wLTmuFnXTCVGHY/is/r9bvv8/x+0GyX18R60lfH+M1f8FgOmdb/fOx2JfG8U7o9x/41hV3X9zXDq+b7xe9fy/d7499b1gp0V/vThOJRtxjfVy9PD6q9pW8eZVz7cjjEbxzrDo2U8/CaEn0slopOjJa7iKv0Qae/Q0HBU9EUajeGeU9ER+q0pPnr9Y3/JTWBnaYfjeQdTVeYzUGS5c57zxqsFvofGyDxX7DZPddha6WbSn9gFWB/cBx6Ft3gfwvuxW8X1lsMe9jxXpiO3jd6yPZ/msf7Y+zzuwVNuYI5v3AacT02KpDy1OE/5Kjqr8C/Oi/6cr0oL3AYlyr7rrE9Ki7BwL1j/t0GLJgdWPFtvtB4sWcwKWylln9qq6gIn0UbImE+/MU/15UV/N7SbVv3L1/v9cJn5P8XmW6hgM9T9/JsRvbH9GWLfb3e1wTmn1P7QdhPVo+/5/ZdcwWMPKh2zraVk+5NPQH6yPn/OnSb+9shgz5SNQvH/aod2EwEfpMwcdo1nRn0FhnYsI63xEWBcErMR2oI0QXLH9acI1Mj6rNWrP8GH6MO1Unhnlx2KdRO1b1dmQligzWRETVogNnm3FWKbOIbFfLn9YnuJ68tlFWS7fP/tqpy2UP2jfUGs1x2h9P6wZn1t8VvFF7CNTfnLlK+LcO+wryp/EtpDN0Llk7U9nvfyZYi55sZ35Uyf6JDq/sWH4LAt81Dw5md3nLR4zxM9g4X1Ktqfy7K6JeWF/Db8C+E2INjHHJ/etK5aPfntDMYfUGq5s+mq8lXxkWePZnFT8ZJWc0fljtgCWL4g78obJtHkHP8++Y+Os9Kl+NhDW9/rJzi+qIDtrWccOwrLzLSA7P1ACs14C0z4P6xyC0lnPCXxYJ3039cv4sGyssI/IU2U51rnd89RuPo8WyHaj+EHt3WrUz8mS+hznZfW/DHBYKjlXgHRAvDivSRUeLsP5dADOf9LB+ZyDM/I5jx3y8DmnPs9Dhs/2WuyD4iWed1b/T0Mfz5bwRj3TNvVxyPXu5Wzo59NmXatqrnfkw3HI9a5yLdToO9aP6dNW83WUPm2kRQqfdigtttsPFi2UPlTPyucWtoXyJBPvcF50q/+NV+//z/vxzVe74fI7yLenqMzqfgvA++sCNsvg/PFs+awj4buoIymbH/uJVL5l1ImUfdXgKf/EItHA3vsO6Pe3E35TWee53e7U+x6iPesbSwInbvd7oN3vqthuLesdA+Vv4nE5LnDO4X60KPDuIGJ5W6bXlt1T8Pegvz99tby9QW0C6lw/r2HqXJwXi7ks6uPejf1i3hlBBcvLkXVV1F922ka88F1um/G090Z4P5SMqVX3Q3njiPVDaKnGsUX1kXZV98qXqSxkr4z8i/Mltjz+bJqHyv9ubaL8ZL86vst3eP4szPv/7LRnY+Xd56TW3pA4e5ZdWdbr386yNDniPFjHnbZT5C7LBJ6Yq/zFttqdMqPNKOY97ll43nt5A/MnhJZqHJWNjOcowj5OZSquWMmLs1Sm1lucL7Wsl194DuaPF9tyHOBeKL6wfvmbRXuhe2D0+fEeeBR3dJSduevHM9i/g+Z09fbAo9jrIC2q7nWq5IztR4txuO8MaVE1NpVp4Z2T7UeL7faDRQul56i10LvzMnR/jO+E5M1Vc5vtmlMP3f+fy8S/WnyOGTeg/LS3293txIgpUL4Wjm1B+vGdKqP2i7H9JNQvtlSMmfKLVfXPHxf4eP7lqmOkcnYMCms5IqyrEWE9JGAZrz0Mv48itsXanyZcI+Oz749/mPBh+jDtrglcW6KMdZJrop1rop2WKOPYlhiwlC79EL2H85x16WWAybEtyKssT3E9Qf/sykOdtlD+4H5WrdWcS+abYM1YLz4ru4/1ez7r5bMrVIZzYjnr7g/SlufSy+D3UcS2WPvTWS9/pphLLyN8yuaS0eflafDZj215ROCj5gnGtuCYIX4Gy4ttQR66Rn1NxAv7a/jLAb8J0eZD0Gfu28uhT036bdtZw3FsvfFW8pFlDcohtsmhHLpGZctQxvL4KuDCsS1Kl0be4NgWhZ+yUfJeUulTyi6q4BuMfrLzCyrIzvwz+1qs/pMgO99bArNeAhPz0fC4DEtnXRb4sE76LPXL+LBsrPj83lXR7kNOu1epXRXbovjBy+m4XHyfLKl/hXCw+l8IOHCcyGVBB8SLY1uq8HAZzpcCcN51cF52cEY+57FDHl526vM8ZPhXM00TnHeXBXzmybdCH8+W8EY90z4UtutdJZxvFd9XBnvWmeYZ4LPk0OSqqL8MdVjXuuzAWhawkA/ZrpdoL7POsqOMFg8T/t5eA/s3L/r/cEVasF0vke637vUNaXGN8Fd7mIcdWjzkwFrOfFpstx8sWih9qJ6Vzy1sC+VJJt5B3QHrfwXoBl/5UDdcfgf5lvM2WN2vBnh/TsBmGZw/ni2fdSR8F3WkkDPQaJt8CGC8l/aT2BbHN6gz6+zP+Tro9/sIP/Qh32536v1Voj3rG979mVb3r0K7X1+x3VrWOwbK38TjovxrOdzfPXb/c0hsxkPQH09PalL9vwn9/cGENgErw/l9lfqAey1vz2T11R4W927sF8M93yMBsLx4jFeI+o84bSNe+C63zXjae8rHbbQZhY8b7RnNdjdt1Dhi/RBaqnFsUX2kXdW98suobBnKyvbKyL84X2LLY7b3mX0R9dw6wOX9R7+79Zj+/fIFcG4j3AtwrI1qW8X1eW17uPY7w87xNugbsXenst4+xpsvq1vqXLE9nJMm/zxJZcgXU1SmzhuwPw7HiM/sMk34maDvSKf8vZ1rHbhcz55xo+88lSF9T1GZOgM0bvRluWBwWS6wvFHxPznvfeRYN1zr26jkTUh+EiWLWE4hTB7LGGf+WwLW7XY3Dur8zrByNxsvh95JgLyPewCOPfiYY/eueidBU+Cj8nYddIwOYy6Fg8K6KGAljuMK9l1b+9OEa2R89v1tXpyYop2XgxjLOC+D0vnUvqElyth3HQOWisvkOFClQ6g4HPZdI6+anDP64bkP9L/UH+60hfIH96n47na7U4713/1wB2az+KxsDd697SHnLFTsPs+lRHkHgn3X1v501sufKeaS8meouZTYv7Xvu74q8FHzBH3XKhcDwvJ81ypuMjEv7K/hy4Cf8rNchD5z35ahT+w7Ol3MIbWGq5hcNd7e3RVKDvE+Xt3z5p0nUXKIfdfK9oa8wb5rhd+EwI/Pcit9Sp0jVfANRj/Z+XAF2Zl/Zh+a1X85yM5nSmDWS2Da58Tnw12d9bzAh3XSP0r9Mj4sGyvsI/IUtnvRafcCtat814ofsF32n+NdBKo+26yt/hrgsFRy9gHpgHjxXq4KD5fhfCYA5+sOzucdnJHPeeyQh8879XkeMnyOT8Q+KF7ieWf1Pw36eLaEN1TMSP6Mw5mUJYcm/c6keGfOQ86kqPxghzW//qBnUpAW2+0HixbqPvd6Vs5P2NZBz068GtbDJx/uhsvv4FhxLgKr+zTAe62AzXInf9Teh+11aq1AvUDZn0wfwrV+XsDjexis7B3FO8ZfKDvj8dfavg0XbYe1rLvt04narlF7Wab3WWV5QhHvaVHWGADXGzd29vZ2dzZXN++tr91dvVnLesdY+ZRD/CTzon5aW+Taupdb3soaUMZ3JjShzHA8nvX6ctLkuF1bD6E/tq/mZIjPy8tdi+2w/SkU1kLWK7tZL5oSsEL9CfZuLneeorgFL+eVrQ1le5qyGI4vAzn73oT2IBULwfrLctZ5vP2y1b8q6i9DnSlq24urVLDOOm0/JOpfddpehjJ8l9tmPO09Nf+NNqOIW1D3TnvjiPVDaLkMdax/LaqPtKtqJ7lCZSF2EuRfnC+x9RK29ao7mT0/YkvgUYPfmP4qH38L6vB9TcpW4rWt7kz22vZw7Xc/RYtwRb8Y39WJfbQ1Pa2+1rHPGC6NPv2oU32mQZN++xuOPVKNDf7G6+W8wEfRDu/bZFxT0O60oN0ph3a47p8WtLPfvi0i7ZYEPh4spVNyf7G+uv91Juvw+zvf/cIXvyej5xh9Z6OvIXaS6tmktboo1HiSIcJvLmnvGL2P72b0/ST9NpH1PmXvvpl+y7IOk7YI5q3i+8pAT/WgmuNUhkoXB1vgAsbBTsq4q4JqcKz4YdoinaoG1ajLnkOVYLzs+RuLjprgmYV6S9QmJtqbEHBnoRzrfwiU4J99uLy9hay7TF1+FJK8SiW7sz4ow7EnHPoldq1T294mQsGaddruZ7zktpVxmHHJBJ6Y7P/FttqdMly486cBZamV4K5LV9rdtOmXDDWElmoclVLKiaYWoGyWynChZAVZbWq9ZHc4X2pZL79UnfezAPfvFp5kleSTN+/W37J5z8k5rf6/hXn/2w+Xt8dJRZG+HGSnjAxq3rPsUvyyAL8Ne97POW2Pw7w32hzNe62wcyJLXI943qvAUCUTcN7/Ns17lYg2dN5jItofLZQQ09NwsxlxXHfVZQ728OVm+WfW01B/nKWyk1DGehrKjgaV4RhV1dOMTlX1tFjGyvMFUspIwBsglMcTDtyeizevddq7eK28Pet3VVnOm1wcj5PUBxWs7cnMfsHaLDO9yyQVrCmn7X6HPbhtNecZl0zgae8peY0Xk+RPA8pSy+sug0m7mzZqHLF+CC3VOCqDJMtW3FuwkVPtLawM59MClSGfGv/ifIk97/9CUWC804B62Afsb9m8b0A51n8Y5v2nXCtvj43uSF9Okn1S4OnJBOuDMkB6eySPv9TcU/tGD1bDaTuGzGFcMoEnHv55sa12p8x+G8W8R+Myz3vPkJxlYbRU46j2S3zJNa5VDSrDtYr3YDifTlKZkgk4X2pZL79UnfcNgPtTtfufjXeOCdxC5/0xKMf6nwnz/vXXytvjuY3zntd0RUM19xaoD2ruefM+9Xp/zGl7HNb7Uc77cV3vcW4fozKcv7zeq7VK2XpwvX89zftjoh+h8/4YwP1Q8TnluF6/cd/Z8yKuBXyTHfw0oBzrf2HR/2noh/0fJLBo7/qd1b31O3t3Nu/s7Gzcu7NA8DOg3YkE7d+5vn7j3trGvet3N9fvrG/1bT+fH28k2YmXINl7Sq5OUD11UBb5ip27qCdOCPh8YYTVf2uBrwpqPgbtT1B/8oed4ZPQxgS1q9Yeq3/i5R3c3+GsPTX6rJIMHBP4mX0D+SOFs3R/ngI+0wIfHoM/QfJjpvh9QtAR4Vj9E6LdGegr0/0EtYsHARLbglamCIfI8PeD35DuKkjL2p/NevmmVvLfYHGZtTWd6Xl9K07fVr2+KR2llfXyPR8iUbCmK8JKPL/WeX6pfmP76pBSlTFV/VYHnmazXnoN2g7S8Bj1Z1LgkP/2NSX6B8phXId4LbD6v/myDsy/6Mhh3vujjJ+msinR7rDksZKLin/rWa9Mss9IJ/vtG0Bu3gmw9Sh7oUqEz7EEKfhX8dVBZZ9qR+kcfCFejHYQls0F4zkcR4NhZbgu8t4M97KGg/HqPJXdKr6vDPgY/JNp4O/LTi8QCttXvpqq66G1NU2wUq2Hqm/KP6D2f2w3rRp85gU2pol76ozpvNNvbH9W1B90/iEsXg9bEdtBGrLtCftq8zrxfNpfW2wviGvLSYFrnerj5/zhOIl/6Kwtyu/r8fmMwKefLvFhanMa8FS6xAnqh9X/EOgSHyFdAtdg9geg7Gb+tf5Yef5MZSllzOZ6qMyz9qezXtqnkHmKF5A+daKdF6+Ac/k17U69MhmjYuQUrDdFhPXmiLB2I8J6LiKsnYiwHo8IKybtXx8RVsw+7kWE9WREWM9GhPXGiLCeiggr5jg+HRFWTNrHxCumXI2J17jKwnsRYcXk1Zh4vSEirHFda2POx3GVXzHHMeY6FHN9jClzYtL+dRFhxezjuMromLR/PiKsmHJ1XPWJmHr0ayPCGledKSbfvxARVsw5tBMRVsy9wrjqqzHlxBMRYY3rmrYbEdZORFgx6fVMRFgx9eidiLDGdd1+KexF70aEFVNGj6tcPdJNRqebvJpgmd+gLJ6Cz/xb/a8sfEFpfembW57/Ma1fcDM4QR/72REf9ptj2UAJ+jZ2t7Z2dvc291Z2V2/e3PdhniRc+bc6tJ//LYj6yueUNrHP5pp3Rlkl6DtJZU0oMxxVgr6FRPiH0B/bb4n6r2p36lUZy5ZoB+NeBoU1fUBYluxPxVPMZ928ln82P/GU6EMKf7+SfdjmDPQH6+Pn/GHZ+N5CNip//4ygnZpvLaIJ1uvn73/fy3SbZf7+aeqH1f8A+Pv/cvF5XrzPsYMqLm2evuef+aIkFTc3LnGFGJfO4+LFFX6zwwvqPAD+5sX7HacyXI8mqQxlPp+TxfUMz6lY/D7zxLdCfziZOM4X5rP8MfmWOP5uned3BvjguGH7+B3rq3gk49dZB1a/WA5OJj6KuDIVl1Oj71gf+8hxWzMCVto4npU9FQNnj8ozwbG4uMZx/CzqCRzzijoQ567A831IE34m6DvSqWoOCrWm4Lzjs2mTAkdcNzju60edOW91yuY8XyCQRv/q8LnSTXAc+Fyq0n+V7mN8PufAUm3jOQKe84kSPe7TYrEPLTgPVL/koHzed8GB1Y8WvBakuaSzQ4tTfWgRkivglEMLL+9AP1pstx8sWkwLWPWsfG5hWyhPMvEO5yKz+j8Huuqvv6wcH95/qNjq0HHDeMwX67R78Ux8fnstl8lfGnB+W110MFmUtbLecQ85v6+SqCpYnOMNx+MU0InHI4Wer2K8sU3kP6aDF+P9MUfPr3oe75TAh215yJ8qrt5g4Hzw8AnVF6YB7ocrnCc7IWB4+os6+6jmGdoM8qcBZRH5Z0PNM9TNeJ6h/s/zDMtut7tpUfU8AJY9OqawrI+KTzDPBfPJsGw+2OYx6A/LBs/m0yj2y2r+q9wR3tneWYGPsgHMUJmy23s4hM55tAt8zbXueuqcoY0l2nNizsUatWd9wt+w/WGd4e6X3wHlGI8l23PwnCjPxarnUVPDUvY763fq3AO8pjVEPxC3etY7V3A9ZL3yojOvq9rvqp6jTWz7DL7ol3MhJJrXbi4ERVejndIt2H6eP8z7J0Q7J0Q7hwnW2wtYStfmOZl6rbX1qWytZV0b96CoE7INetWZk1V1bZVrQtGO8xwkOgu4T7t9n2em9+hMO1zvu/RS+u1mRNqpHBHDzp8xrDwHsxHbQVjmtxv0jL5qR+ng3rnxxL6IYL2NYyYS+YncXAMqnsaL71B+c8ytimXYTogPPn94jYgBS82veXpPzQnFx48RTG//h3ID91fYfkO0i7D4DpI3FnItMQ+vcL44bKufX/5NL+/uK+bsUXuy7XZ3X63+b0NutS8sPivaenl72C+P6zL7tLwz+onmZrBuau0P64y+8qOq/dIwZGmZHFDxJHm9uax3zBA/g4U5bs1/p3iI83Mk4oUVltOoE2GbnPupJfqZP0367V2OTlR1fzwj8FFylmUpylm266Bud4LKUM7yfWRqf6piELzYHLWXZjsK79HK6KbgGwwlv2ye95Orf4rkKt5/oOKdyvJm/hmQq79FcpVz7GEZjivHV9p41Utwsc/DinlTe7JZgQ/vub6GaGzzDsf/hIBj9ZXddd5pd47axXyW3Jcs07TlnGF4P5KqP0M4WP2vBRw4n+oJQQfEi2M6PV9HKM7HAnD+Kw7Os1k5zorXMe+R4hmuz3YFhs86n4pPPCHgM09+E/SR41KmBM5oJ+G4lER+x3WmeZb17q0VTZS/RdFcxV8xLNW2ulh3lLFoSIuqsWjefTUMq5/+tt3upsUo4pWQFlXjlTi+oSVgpbTR5M/tdqcOjxXvJfA3XPtVzDjP/x+E9fr7X94Nl+Ui8kSjBN4HAd4/fnl5/0zPCq2n5qjRUvFsncpYr0YY/WwXnFPceGUy03PJ4DWp/o+K9UTFHrPuivoQ5yibEO0iTRXdymLVfwLG7p+W6INZVt33iTnY/xThxToOluEazePJui/CULn5lF7Ffqp/LtZCFS9heOX1Lj/S3W/k3UbxTmJ79zrrDFmm5SDPHaVHKZ2hJerbvFT0mXboc8yhT+rc5/32U6w3KnqqO97UORO2W6o7b5Ttryq/YZ8axTvjlks+lD/5HiJ8n+/3Vnc7I409euI9hUxPhNEo3hlWHvdjTp+4/TL6Iz8bjTz9ourZFx4jlL0mk3Hvn4+hktkcW3NQe8PvwZo1U4xlCjtuyB5B6RHKzsV6BNZHnW2S2lZxix6s407b/XRgblvpwIxLlpXrQt48HMX9TKjfNdvdtAn1ZXm0VOPYovpIu6r2TfYxhdg3kX9xvtSyXn6pquPh3DcfTex7h9Zv7N1ZW9m8s3dv9eaNtbXNYd97tLWxtXrjxp0b97bu7d3cuHd32O1vbN65fu/O9dXVmxuruxurQ+//vc2tu/f+EImV3dX869rQ753a29i9vnbzzvrO3t69tZs3+7W/v+dtd8pR/uSPxRWbTZXrG7wm1X+omDs5v1+jvUJDtJfXuw53CeXPccAlorxbs74dQzwIH2x/XtS3z4lxXfdwPSZwVTSulfxHWPjbsXb3b1Pt3vpIp2PU9jTWp7ITUNagdmaK78hrCMvwaFL9TdBr8uc4vGPvt0T7OGbclmof1zWGNSF+s/o5b//RAsf9GFJoO6YPGedRChmzduPG1s21uysb13fu7e1srA9bxl1fWbuztrOzs3F3fWf9en8ZF13Gru6u37y3t7q69odi9u71jWG3f3fn3tbG7ub61p2N1a07O0Nf41bXdu7dubu6sXFvY2ft7vq9Ybe/ee/G6trqnXvX723d3NvZvT78Nf7O+uaNvesrN2/s3t25O/T+7969u3Pn7r2trZv37t5bu7c37PZ3bmxsrPwh393bWLuxu7m7VeVuS9OjTX6X3TU8AeVY/2nQKf4W2SVQD6+63rGfAfV23suoO9ImANZ2uxsP3pej/eTzqe6UU/cLqe60U/cO1T3h1H0L1Z1x6r61qMtxBPlzq/i/MtBz446NJ9qzcB29R3syPKs7Id5lXrL67wde2iO7CNvSsAxtJmyb9+4xzZ/tdjcuVv+tRfuejzkT/csf5s9+NkfOh+Pl6DFef+cQ8Zsg/MruaXzx/XanzNocxhlNtpUgDZrt8P4q+vSzAbPNQ50rHKEtSdKn6dBH2XSr8g/HiiF9kHZsZ8L1ocx+jndafzbgznLd6v/vIFe+7hENs5Zp+cB+VMN3EnB4zMHB6n8VzNcbdD/vJOFwq/i+MthzU80Fe9j3h7RX56s4Fh5tyk0qQ7se+gL4maDvSIucTq8lG0UmYKkxrVMb/ca0CbC4PsJjvvoGGNMlGlPmq1vF95XBni2lW9nD/ko1pqpf6lzqBJUpn1fomBotqozp34L9svIl1Ogzxi8ombXd7pRj/W9z1lHln6hqU0f/hOHj+Sd4nf9OB7+FivipvEAc54T4Ie6LhJ/x0U+CbP2+RzrwEZdJ0d+TBM9478cB3g880l3HePCfQp2/R3VMZv0TqPNDVMdk14ehzo+U4M46N8o3PovyD0kGJIohk2dR2L9lOKmYePZ9tUr6kz9f0L7/n8+p4Xs5/T76SHm9+TGqx2UsD/LHzkkp2iFtymCddGCdLIFVy3rHLcvKxy60v7zH+hng+d+hPRb7hrFMxWx7shf7tt3uxsXq/+uKslflHQmVvSHxkR4sr+1+cpXlvpKrI8wlJfcHXTmP2uH9VfTpl1+O/cIqx5iXJ3oU9Jlz6FOVdxU9ld7Qynppx+dQcU0IiS33YkZRvquYUc7JZvV/S+jFyo43B/B/p8SGhLg2Ba7KNoVw7wEusWye/x1k6FOv6MZj3GyeVh/zoKj6dl7F3vHsnl9U1O1nF6y9ohsHFePq2QWt/tOv6MBsFJ9D7IK4nwmxC6rzALyPnyraV2uW1amXwOQzQcqu5NlZ+sW+cvyTF0er2lZxM1Z/tiKu/c6xnCBcVYwa74UWHdrHxo9tsscEfl7bnr1hviKuMc7BjNA+ez11LFtoTKLK1eDZZ+dHSB/PPjsp+uvxj7LnqvOSKmZvzqHPKPln0qGP119FHyULvfwXKpeRog+e8R02fWLa9738dih/VH4gPhdUg7Kq9n3WSaz+p4B+8OgrNMxaptfkqvZ9xsHqfzqsTUOy799R53fsUTb8GpXhmsu2YFwL2b6vztTVBA797Pu/F2gL5jFV9n1vTJV9H3XDMvv+58GYHtn37z/97PuhY2r7JrTvK161z+qsuGfft/pvdHRGdW8JwmR93btXxOBgfaXnVb1XhHXgO05/5ivi10+vZB1Y6ZUZtTMp+sL6vPHh20Fuf9EruuGxjR33n29rd5dZ3bcWMFLnFFf2d9STeD4hbd7ximr1eC/8LqDZ36G9sPLlqrnFe2GkteKb7XY3Llb/ywL2Y2V5GHhuebkBDA7WT50bQJ1ztPqh9wNY/dS2aa/tfrZplkHKNu21rfIKWf1TFXHtd9/EAuGq7t7wzvaOQg9XdzKE9FfR57Soj/ctsB5+Gso8OzrexTBs+kw79PFypyj6qHmp1lRlB/D8MKPkn1mHPv3kVgh9VI4ORR/PDjA7Qvp4/KPspR7/eHe3ofxRZxQ9P0zIGWhcGx8r6cdkpu2+Zbkxvk3sX5RvAe/2+DslNnvENdQPg3DNFxA99n5t9cbK1trm6sbO7ure8M++rN25e/3O2t07N3durq/e2Bx6+zev7927s3NzZ+/6+t6dvTt3qsT+V81nMkH1PLtQ/jAfY04Vz87G+4R/IPi4Ru9PZNrWx3qmFw+O8Ni+88ZP7uD+Y6R3q/0406ieaRoZfonzNazwGKj7ThEfHoOfILlgMmYi0z6PMl9XWV5zpvsJahfzAKa+W2LccpGw3cfK1X+DxWV8l8OxNH1z73JA/NnXjXzPeQWr5qdXsIaVD6Vfvh7Ol4/1q4yp6jfCMru50pMGbcfLyz8pcMh/+3mSHyp+wcudYvU/A+TwLzpymPMkhuZVsXrDksf97p/m3Mah909/DOTmoLmNjwt8UvKv4quDyj7VjtI52H4eox2EZXPBs3WrWIg6leF+1nBInYfb4J9MA39fdvaz6ZXFvlq5+m+wuIzvmkhkK3bvmvDu0VMxxx6sVkVYo8z5WhafwvUHnX8Ii9dD9l+o/6HtIA35fnTl70k8n9w7T5VNp0718XP+NOm32U+6/1+tLVXvi1RxX/10iZOf1N2miitU8S3sS5kBXeJUAVP5Utg+j7Kb+de7MyONjNlcD5V51v6w7szw7Gn5w/5pFVus5vJr2p16ZTJGxYspWG+KCOvNEWHtRoT1XERYOxFhPR4RVkzavz4irJh93IsI68mIsJ6NCOuNEWE9FRFWzHF8OiKsmLSPiVdMuRoTr3GVhfciworJqzHxekNEWOO61sacj+Mqv2KOY8x1KOb6GFPmxKT96yLCitnHcZXRMWn/fERYMeXquOoTMfXo10aENa46U0y+fyEirJhzaCcirJh7hXHVV2PKiSciwhrXNW03IqydiLBi0uuZiLBi6tE7EWGN67r9UtiL3o0IK6aMHle5eqSbjE43eTXBUvfNoi+HzxVZ/X9d+H/S+tI3tzz/Y1q/4OZWjdozeuNv2P6swIf95lg2SBzrjY3dra2d3b3NvZXd1Zs3932YKmYdf6tD+/lfvzMqdaL1Yhpar3n5ivg+CKZ5/jShzHDM/a1nCP80OeY210Loj+23RP1XtTv1qoxlS7SDcS+Dwpo+IKyFrHsOoJyYz7p5Lf9sfuIp0YcU/n4l+7BNPO+K9fFz/rBs/PeOv1+dsVDzrUU0wXr9/P2//Em6zTJ/f9l5iN/9pA7MXyV/v7r7c56+55+PUZmKJZun7whjXOIKMS6dx8WLK/wNhxfUeQB1n5uK9+McG7geeXf78X2fuJ7Z2OTvW/w+88TvQX9CzoerswWJ4+/WeX5ngA+OG7aP37F+1fPnXtvq7Oco48pUXE6NvmN97CPHbc0IWInPle+pGDh7ZkW/OBa3LK8R6wkc84o60CyV4flbpAk/E/Qd6ZS390E498718HPZmhJ6px+elbN1g+O+5j65gxfPeatTNuc/r33/f+Icv+498epMYo2+Y32l+xifzzmw+p1z5zl/KjEtFvvQ4hTh3y/v6EmixYIDqx8teC1YSkyLU31osUT49ztbz7RYdGD1o8V2+8GixbSAVc/K5xa2hfIkE+9wbhSr/3KITf3UTy7Hh/cfXp6L0LwVI8xFvJbL5C8NyKFgZTiWk0VZK+sdd5ZtigeWBC0ULJsbajwwlwKPRwo9X8V4Y5vIf0wHL8b7OqyRrOdXPY93SuDDtjzkTxVXbzBwPnj4hOoLeEb9JO0JvfNk6vy9p7+os49qnqHNIH8aUBaRfzbUPFO5JtRZG55nWHa73U2LqucBsOzRiLA+JyIs66PiE8yFwXwyLJuPun+qqs3nSWf+q/yR3tneWYGPsgFw/hFlt/dwCJ3zaBf4ecrHpc4Z2liiPSfmXKxRe9Yn/A3bH9YZ7n75HVCO8ViyPQfPifK8rnoeNTUsZb+zfqfOPcBrWkP0A3GrZ71zpSsnDv32NmdeV7XfVT1Hm9j2uRk6jzgXQqJ57eZCUHRVOVtZX0LbLPO+ymOs8j8eJlhvL2ApXZvnZOq11tansrWWdW3cg6JOyDboPx1R11a5JhTtOM9BorOA+7Tb93lmeo/OtMP1vksvpd++KiLtVI6IYefPGFaeg9mI7SAs89sNekZftaN0cO/ceGJfRLDexjETifxEbq4BFU/jxXcovznmhcYybCfEB58/vEbEgKXm1zy95+X1VzlfQ/Z/KDf4bhBrvyHaRVh89953FnItMQ/LXMbWVj+//HeTHQZz9qg92Xa7u69W/zNf2YH5fWTrDM3bw355XJfZp+Wd0U80N4N1U2t/WGf0lR9V7ZeGIUvL5ICKJ8nrzWW9Y4b4GSzMHW7+O8VDnJ8jES+ssJxGnQjb5NxPLdHP/OH71z7s6ERV98czAh8lZ1mWopxlu466B0rJ2c9td+Ou9qcqBsGLzVF7abaj8B6tjG4KvsFQ8svmeT+5+i9IruKdIyreqSxv5s+AD+lWIWMV3xteap/A8ZU2XvUSXPDOGx7rYe3JZgU+vOf6eaKxzTscfy9nvrK7zjvtzlG7mM+S+5JlmracM8z6OVlSf4ZwsPq/BDhwPtUTgg6IF8d0er6OUJyPBeD8Hx2cZ7NynBWvY94jxTNcn+0KDJ91PhWfeELAZ578uBOXMiVwRjsJx6Uk8juuM82zrHdvrWjS77499q959FVtq/t/RhmLhrSoGos26N0VSIvtdjctRhGvhLSoGq/E8Q0tASuljSZ/brc7dXiseC+Bv+Har2LGef5Pwj6o9spuuCwX1R1cDK8B8BZeWd4/07NC66k5arRUPFunMtarEUY/20XZXSxldxQbPL6bfa7op8qNjzzDuivqQ5yjbEK0izRVdCuLVT8LY7f0yu4+K1001PeJOdj/Be21Q/PA83iy7oswVG4+pVexn+oyjM9ZulMM4yUMr7ze5Ue6+4282yjeSWzvXmedIcu0HOS50+9uX957YX2bl97dJYo+xxz6pM593m8/xXqjoifqaXz3Db7PdsuGgKVsf1X5DfvUKN4Zt1zyofxpNFL0LLu3E2EhjT16Go6KngijUbwzrDzux5w+cftl9Ed+Nhp5+kXVsy88Rih7TSbj3h/vWkSZzbE1B7U33IY161la82LacUP2CEqPUHYu1iOwPupsfLe6ilv0YB132u6nA3PbSgdmXLKsXBfy5mHiuMNNdYcT6nfNdjdtQn1ZHi3VOLaoPtKuqn2TfUwh9k3kX5wvtayXX6rqeDj3vxt0vBd/awPcdued/DlWfDebFtc3Wjep/j2Y97swti/WFe3l9d7j1KuV/H8Rhvit0e7+bardW3+i3Vvf2p5u9+JoZSegDHkzf2aK70gvhGV4NKn+u0A25s9xeMfeb4n2j1P7XXiL33BuMKwJ8ZvVz8fnLQWO+/o7tB3bD/VimwQff2Pc3kPrWf4cw74BrLJ+TwjYajxOBMA64cCacmBNB8Ly2kZcGwTf+G2yBP4U1Z8tviM/HxP4MD+3Yf6/75XddQzmn4E6fy5ARhhOc1gm6qPdhutbX/M2v7Zoc9/OCO3E1h/L8EZesPZjyD9ra1hzNcaYeLDmAmEZPXF888/fPJyxXuM+mG0e+4nt7+/h0+Czz3vzbZ+m1n4M3rO2hsV7qm8e72F95j0Faz4QltFT8dtsGhqss1zPSmiA7eN3lOu4/tm7LLO/85XdcBS9cA2ztWjfFgNl01R2EspmCN+Fdi++CGue8F0gfG3tVTzfEu3PUfvYlmqf1+WTov5JUT/nlb9NNJ0U7+L4Gk1zXef/B8FHv0e84wYA",
  "debug_symbols": "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QwPyaEABDSiiAREaUEIDQnNqQnNqQnNqQnPqhObUCc2pE5pTJzSnTp19KLA+nsm4/Vks7FLnHAvZbW/1ez108QuHHRaOaX7dQwT7ENE+BNmHSPYh2D6E2IfI9iHUPIQ4+xD22S322S322S322S322S322S322S0Nspv9834yl3fFRc1DZGcfwrcOUWslHr/N3X5o3q6k8EUToGgiFA1B0SQoGoaiESiaDEWjSDTqoGigvFihvFihvFihvFihvFihvFihvFihvFg7e/GtFIUHTs78rRUl57BwPBZOwMKJWDiEhZOwcBgL55O+UzydQr5zZlGI/HUxBSpxIhYOfRJHCpyEhcNYOIKFk7FwFAonOCwcj4UTsHAiFg6WKwcsVw5YrhywXDlguXLAcuWI5coRy5UjlitHLFeOWK4csVw5YrlyxHLliOXKEcuVCcuVCcuVCcuVCcuVCcuVCcuVCcuVCcuVCcuVCcuVE5YrJyxXTliunLBcOWG5csJy5YTlygnLlROWKycsV2YsV2YsV2YsV2YsV2YsV2YsV2YsV2YsV2YsV2YsVxYsVxYsVxYsVxYsVxYsVxYsVxYsVxYsVxYsVxYsV85YrpyxXDljuXLGcuWM5coZy5UzlitnLFfOWK6csVxZsVxZsVxZsVxZsVxZsVxZsVxZsVxZsVxZsVxZoVw5OShXTg7KlZODcuXkoFw5OShXTg7KlZODcuXkoFz5FgsLB8uVPZYreyxX9liu7LFcGWtvX8La25ew9vYlrL19CWtvX8La25ew9vYlrL19CWtvX8La25ew9vYlrL19CWtvX8La25ew9vYlrL19CWtvX8La25ew9vYlrL19CWtvX8La25ew9vYlrL19CWtvX8La25ew9vYlrL19CWtvX8La25ew9vYlrL19CWtvX8La25ew9vYlrL19CWtvX8La25ew9vYlrL19CWtvX8La25ew9vYlrL19CWtvX8La25ew9vYlrL19CWtvX8La25ew9vYlrL19CWtvX8La25ew9vYlrL19CWtvX8La25ew9vYlrL19CWtvX8La25ew9vYlrL19CWtvX8La25ew9vYlrL19CWtvX+q+t4/849Uotz+pwCEsnISFw1g4goWTsXAUCqf73r4KjsfCCVg4WK6sWK6sWK6sWK6sWK6sWK6sUK7MDsqV2UG5MjsoV2YH5crsoFyZHZQr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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_recursive<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) {\n    if low < high {\n        let pivot_index = partition(arr, low, high, sortfn);\n        if pivot_index > 0 {\n            quicksort_recursive(arr, low, pivot_index - 1, sortfn);\n        }\n        quicksort_recursive(arr, pivot_index + 1, high, sortfn);\n    }\n}\n\npub(crate) unconstrained fn quicksort<T, Env, let N: u32>(\n    _arr: [T; N],\n    sortfn: fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = _arr;\n    if arr.len() <= 1 {} else {\n        quicksort_recursive(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "9": {
      "source": "use crate::cmp::Eq;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// An unconstrained hash table with open addressing and quadratic probing.\n// Note that \"unconstrained\" here means that almost all operations on this\n// map are unconstrained and importantly are not constrained afterward either.\n// This map is meant to be used in unconstrained or comptime code where this\n// is not an issue.\n//\n// Compared to the constrained HashMap type, UHashMap can grow automatically\n// as needed and is more efficient since it can break out of loops early.\npub struct UHashMap<K, V, B> {\n    _table: [Slot<K, V>],\n\n    // Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the UHashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, B> UHashMap<K, V, B> {\n    // Creates a new instance of UHashMap with specified BuildHasher.\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = &[Slot::default()];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    pub fn with_hasher_and_capacity<H>(_build_hasher: B, capacity: u32) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let mut _table = &[];\n        for _ in 0..capacity {\n            _table = _table.push_back(Slot::default());\n        }\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    // Clears the map, removing all key-value entries.\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = &[Slot::default()];\n        self._len = 0;\n    }\n\n    // Returns true if the map contains a value for the specified key.\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        // Safety: unconstrained context\n        unsafe { self.get(key) }.is_some()\n    }\n\n    // Returns true if the map contains no elements.\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    // Returns a BoundedVec of all valid entries in this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:entries\n    pub fn entries(self) -> [(K, V)] {\n        // docs:end:entries\n        let mut entries = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries = entries.push_back(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    // Returns a BoundedVec containing all the keys within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:keys\n    pub fn keys(self) -> [K] {\n        // docs:end:keys\n        let mut keys = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys = keys.push_back(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    // Returns a BoundedVec containing all the values within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:values\n    pub fn values(self) -> [V] {\n        // docs:end:values\n        let mut values = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values = values.push_back(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    // For each key-value entry applies mutator function.\n    // docs:start:iter_mut\n    pub unconstrained fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = f(entry.0, entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each key applies mutator function.\n    // docs:start:iter_keys_mut\n    pub unconstrained fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = (f(entry.0), entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each value applies mutator function.\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..self._table.len() {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    // Retains only the elements specified by the predicate.\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..self._table.len() {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    // Amount of active key-value entries.\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    // Get the current capacity of the inner table.\n    // docs:start:capacity\n    pub fn capacity(self: Self) -> u32 {\n        // docs:end:capacity\n        self._table.len()\n    }\n\n    // Get the value by key. If it does not exist, returns none().\n    // docs:start:get\n    pub unconstrained fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, value) = slot.key_value_unchecked();\n                if current_key == key {\n                    result = Option::some(value);\n                    break;\n                }\n            }\n        }\n\n        result\n    }\n\n    // Insert key-value entry. In case key was already present, value is overridden.\n    // docs:start:insert\n    pub unconstrained fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.try_resize();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n            let mut insert = false;\n\n            // Either marked as deleted or has unset key-value.\n            if slot.is_available() {\n                insert = true;\n                self._len += 1;\n            } else {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    insert = true;\n                }\n            }\n\n            if insert {\n                slot.set(key, value);\n                self._table[index] = slot;\n                break;\n            }\n        }\n    }\n\n    unconstrained fn try_resize<H>(&mut self)\n    where\n        B: BuildHasher<H>,\n        K: Eq + Hash,\n        H: Hasher,\n    {\n        if self.len() + 1 >= self.capacity() / 2 {\n            let capacity = self.capacity() * 2;\n            let mut new_map = UHashMap::with_hasher_and_capacity(self._build_hasher, capacity);\n\n            for entry in self.entries() {\n                new_map.insert(entry.0, entry.1);\n            }\n            *self = new_map;\n        }\n    }\n\n    // Removes a key-value entry. If key is not present, UHashMap remains unchanged.\n    // docs:start:remove\n    pub unconstrained fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    slot.mark_deleted();\n                    self._table[index] = slot;\n                    self._len -= 1;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Apply UHashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % self._table.len()\n    }\n}\n\n// Equality class on UHashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, B, H> Eq for UHashMap<K, V, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    fn eq(self, other: UHashMap<K, V, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    // Safety: unconstrained context\n                    let other_value = unsafe { other.get(key) };\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, B, H> Default for UHashMap<K, V, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        // docs:end:default\n        UHashMap::with_hasher(B::default())\n    }\n}\n",
      "path": "std/collections/umap.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "46": {
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n",
      "path": "std/slice.nr"
    },
    "50": {
      "source": "use std::collections::umap::UHashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> UHashMap::default();\n\nunconstrained fn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nunconstrained fn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"UHashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"UHashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nunconstrained fn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"UHashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nunconstrained fn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"UHashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nunconstrained fn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for entry in input {\n        println(f\"Inserting {entry}\");\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    println(hashmap.len());\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"UHashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nunconstrained fn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"UHashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nunconstrained fn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"CtHashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"CtHashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nunconstrained fn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nunconstrained fn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib cthashmap documentation\nunconstrained fn doc_tests() {\n    // docs:start:default_example\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::default();\n    assert(empty_map.len() == 0);\n    println(empty_map.capacity());\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    let mut map2: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // Safety: testing context\n    let x = unsafe { map.get(12) };\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries[i];\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for key in keys {\n        // Safety: testing context\n        let value = unsafe { map.get(key) }.unwrap_unchecked();\n        println(f\"{key} -> {value}\");\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for value in values {\n        println(f\"Found value {value}\");\n    }\n    // docs:end:values_example\n}\n\nunconstrained fn iter_examples(\n    mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>,\n) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
