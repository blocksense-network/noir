---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "4105629585450304037": {
        "error_kind": "string",
        "string": "UHashMap after one insert should have a length of 1 element."
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "6665645948190457319": {
        "error_kind": "string",
        "string": "CtHashMaps should be equal."
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "7511829951750337011": {
        "error_kind": "fmtstring",
        "length": 37,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "8082322909743101849": {
        "error_kind": "string",
        "string": "UHashMap after one insert and corresponding removal should be empty."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "13674703438729013973": {
        "error_kind": "string",
        "string": "UHashMap length is invalid."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14241324264716156348": {
        "error_kind": "string",
        "string": "CtHashMaps should not be equal."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16986922238178214607": {
        "error_kind": "string",
        "string": "UHashMap should have retained 2 elements."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_recursive<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) {\n    if low < high {\n        let pivot_index = partition(arr, low, high, sortfn);\n        if pivot_index > 0 {\n            quicksort_recursive(arr, low, pivot_index - 1, sortfn);\n        }\n        quicksort_recursive(arr, pivot_index + 1, high, sortfn);\n    }\n}\n\npub(crate) unconstrained fn quicksort<T, Env, let N: u32>(\n    _arr: [T; N],\n    sortfn: fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = _arr;\n    if arr.len() <= 1 {} else {\n        quicksort_recursive(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "9": {
      "source": "use crate::cmp::Eq;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// An unconstrained hash table with open addressing and quadratic probing.\n// Note that \"unconstrained\" here means that almost all operations on this\n// map are unconstrained and importantly are not constrained afterward either.\n// This map is meant to be used in unconstrained or comptime code where this\n// is not an issue.\n//\n// Compared to the constrained HashMap type, UHashMap can grow automatically\n// as needed and is more efficient since it can break out of loops early.\npub struct UHashMap<K, V, B> {\n    _table: [Slot<K, V>],\n\n    // Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the UHashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, B> UHashMap<K, V, B> {\n    // Creates a new instance of UHashMap with specified BuildHasher.\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = &[Slot::default()];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    pub fn with_hasher_and_capacity<H>(_build_hasher: B, capacity: u32) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let mut _table = &[];\n        for _ in 0..capacity {\n            _table = _table.push_back(Slot::default());\n        }\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    // Clears the map, removing all key-value entries.\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = &[Slot::default()];\n        self._len = 0;\n    }\n\n    // Returns true if the map contains a value for the specified key.\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        // Safety: unconstrained context\n        unsafe { self.get(key) }.is_some()\n    }\n\n    // Returns true if the map contains no elements.\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    // Returns a BoundedVec of all valid entries in this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:entries\n    pub fn entries(self) -> [(K, V)] {\n        // docs:end:entries\n        let mut entries = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries = entries.push_back(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    // Returns a BoundedVec containing all the keys within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:keys\n    pub fn keys(self) -> [K] {\n        // docs:end:keys\n        let mut keys = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys = keys.push_back(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    // Returns a BoundedVec containing all the values within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:values\n    pub fn values(self) -> [V] {\n        // docs:end:values\n        let mut values = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values = values.push_back(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    // For each key-value entry applies mutator function.\n    // docs:start:iter_mut\n    pub unconstrained fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = f(entry.0, entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each key applies mutator function.\n    // docs:start:iter_keys_mut\n    pub unconstrained fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = (f(entry.0), entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each value applies mutator function.\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..self._table.len() {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    // Retains only the elements specified by the predicate.\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..self._table.len() {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    // Amount of active key-value entries.\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    // Get the current capacity of the inner table.\n    // docs:start:capacity\n    pub fn capacity(self: Self) -> u32 {\n        // docs:end:capacity\n        self._table.len()\n    }\n\n    // Get the value by key. If it does not exist, returns none().\n    // docs:start:get\n    pub unconstrained fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, value) = slot.key_value_unchecked();\n                if current_key == key {\n                    result = Option::some(value);\n                    break;\n                }\n            }\n        }\n\n        result\n    }\n\n    // Insert key-value entry. In case key was already present, value is overridden.\n    // docs:start:insert\n    pub unconstrained fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.try_resize();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n            let mut insert = false;\n\n            // Either marked as deleted or has unset key-value.\n            if slot.is_available() {\n                insert = true;\n                self._len += 1;\n            } else {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    insert = true;\n                }\n            }\n\n            if insert {\n                slot.set(key, value);\n                self._table[index] = slot;\n                break;\n            }\n        }\n    }\n\n    unconstrained fn try_resize<H>(&mut self)\n    where\n        B: BuildHasher<H>,\n        K: Eq + Hash,\n        H: Hasher,\n    {\n        if self.len() + 1 >= self.capacity() / 2 {\n            let capacity = self.capacity() * 2;\n            let mut new_map = UHashMap::with_hasher_and_capacity(self._build_hasher, capacity);\n\n            for entry in self.entries() {\n                new_map.insert(entry.0, entry.1);\n            }\n            *self = new_map;\n        }\n    }\n\n    // Removes a key-value entry. If key is not present, UHashMap remains unchanged.\n    // docs:start:remove\n    pub unconstrained fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    slot.mark_deleted();\n                    self._table[index] = slot;\n                    self._len -= 1;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Apply UHashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % self._table.len()\n    }\n}\n\n// Equality class on UHashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, B, H> Eq for UHashMap<K, V, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    fn eq(self, other: UHashMap<K, V, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    // Safety: unconstrained context\n                    let other_value = unsafe { other.get(key) };\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, B, H> Default for UHashMap<K, V, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        // docs:end:default\n        UHashMap::with_hasher(B::default())\n    }\n}\n",
      "path": "std/collections/umap.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "46": {
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n",
      "path": "std/slice.nr"
    },
    "50": {
      "source": "use std::collections::umap::UHashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> UHashMap::default();\n\nunconstrained fn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nunconstrained fn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"UHashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"UHashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nunconstrained fn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"UHashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nunconstrained fn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"UHashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nunconstrained fn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for entry in input {\n        println(f\"Inserting {entry}\");\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    println(hashmap.len());\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"UHashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nunconstrained fn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"UHashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nunconstrained fn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"CtHashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"CtHashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nunconstrained fn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nunconstrained fn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib cthashmap documentation\nunconstrained fn doc_tests() {\n    // docs:start:default_example\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::default();\n    assert(empty_map.len() == 0);\n    println(empty_map.capacity());\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    let mut map2: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // Safety: testing context\n    let x = unsafe { map.get(12) };\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries[i];\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for key in keys {\n        // Safety: testing context\n        let value = unsafe { map.get(key) }.unwrap_unchecked();\n        println(f\"{key} -> {value}\");\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for value in values {\n        println(f\"Found value {value}\");\n    }\n    // docs:end:values_example\n}\n\nunconstrained fn iter_examples(\n    mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>,\n) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
