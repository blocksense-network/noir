---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "4105629585450304037": {
        "error_kind": "string",
        "string": "UHashMap after one insert should have a length of 1 element."
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "6665645948190457319": {
        "error_kind": "string",
        "string": "CtHashMaps should be equal."
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "7511829951750337011": {
        "error_kind": "fmtstring",
        "length": 37,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "8082322909743101849": {
        "error_kind": "string",
        "string": "UHashMap after one insert and corresponding removal should be empty."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "13674703438729013973": {
        "error_kind": "string",
        "string": "UHashMap length is invalid."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14241324264716156348": {
        "error_kind": "string",
        "string": "CtHashMaps should not be equal."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16986922238178214607": {
        "error_kind": "string",
        "string": "UHashMap should have retained 2 elements."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, let N: u32, Env>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_loop<T, let N: u32, Env>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) {\n    let mut stack: [(u32, u32)] = &[(low, high)];\n    // TODO(https://github.com/noir-lang/noir_sort/issues/22): use 'loop' once it's stabilized\n    for _ in 0..2 * N {\n        if stack.len() == 0 {\n            break;\n        }\n\n        let (new_stack, (new_low, new_high)) = stack.pop_back();\n        stack = new_stack;\n\n        if new_high < new_low + 1 {\n            continue;\n        }\n\n        let pivot_index = partition(arr, new_low, new_high, sortfn);\n        stack = stack.push_back((pivot_index + 1, new_high));\n        if 0 < pivot_index {\n            stack = stack.push_back((new_low, pivot_index - 1));\n        }\n    }\n}\n\npub unconstrained fn quicksort<T, let N: u32, Env>(\n    arr: [T; N],\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = arr;\n    if arr.len() > 1 {\n        quicksort_loop(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "9": {
      "source": "use crate::cmp::Eq;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// An unconstrained hash table with open addressing and quadratic probing.\n// Note that \"unconstrained\" here means that almost all operations on this\n// map are unconstrained and importantly are not constrained afterward either.\n// This map is meant to be used in unconstrained or comptime code where this\n// is not an issue.\n//\n// Compared to the constrained HashMap type, UHashMap can grow automatically\n// as needed and is more efficient since it can break out of loops early.\npub struct UHashMap<K, V, B> {\n    _table: [Slot<K, V>],\n\n    // Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the UHashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, B> UHashMap<K, V, B> {\n    // Creates a new instance of UHashMap with specified BuildHasher.\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = &[Slot::default()];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    pub fn with_hasher_and_capacity<H>(_build_hasher: B, capacity: u32) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let mut _table = &[];\n        for _ in 0..capacity {\n            _table = _table.push_back(Slot::default());\n        }\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    // Clears the map, removing all key-value entries.\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = &[Slot::default()];\n        self._len = 0;\n    }\n\n    // Returns true if the map contains a value for the specified key.\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        // Safety: unconstrained context\n        unsafe { self.get(key) }.is_some()\n    }\n\n    // Returns true if the map contains no elements.\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    // Returns a BoundedVec of all valid entries in this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:entries\n    pub fn entries(self) -> [(K, V)] {\n        // docs:end:entries\n        let mut entries = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries = entries.push_back(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    // Returns a BoundedVec containing all the keys within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:keys\n    pub fn keys(self) -> [K] {\n        // docs:end:keys\n        let mut keys = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys = keys.push_back(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    // Returns a BoundedVec containing all the values within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:values\n    pub fn values(self) -> [V] {\n        // docs:end:values\n        let mut values = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values = values.push_back(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    // For each key-value entry applies mutator function.\n    // docs:start:iter_mut\n    pub unconstrained fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = f(entry.0, entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each key applies mutator function.\n    // docs:start:iter_keys_mut\n    pub unconstrained fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = (f(entry.0), entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each value applies mutator function.\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..self._table.len() {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    // Retains only the elements specified by the predicate.\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..self._table.len() {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    // Amount of active key-value entries.\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    // Get the current capacity of the inner table.\n    // docs:start:capacity\n    pub fn capacity(self: Self) -> u32 {\n        // docs:end:capacity\n        self._table.len()\n    }\n\n    // Get the value by key. If it does not exist, returns none().\n    // docs:start:get\n    pub unconstrained fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, value) = slot.key_value_unchecked();\n                if current_key == key {\n                    result = Option::some(value);\n                    break;\n                }\n            }\n        }\n\n        result\n    }\n\n    // Insert key-value entry. In case key was already present, value is overridden.\n    // docs:start:insert\n    pub unconstrained fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.try_resize();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n            let mut insert = false;\n\n            // Either marked as deleted or has unset key-value.\n            if slot.is_available() {\n                insert = true;\n                self._len += 1;\n            } else {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    insert = true;\n                }\n            }\n\n            if insert {\n                slot.set(key, value);\n                self._table[index] = slot;\n                break;\n            }\n        }\n    }\n\n    unconstrained fn try_resize<H>(&mut self)\n    where\n        B: BuildHasher<H>,\n        K: Eq + Hash,\n        H: Hasher,\n    {\n        if self.len() + 1 >= self.capacity() / 2 {\n            let capacity = self.capacity() * 2;\n            let mut new_map = UHashMap::with_hasher_and_capacity(self._build_hasher, capacity);\n\n            for entry in self.entries() {\n                new_map.insert(entry.0, entry.1);\n            }\n            *self = new_map;\n        }\n    }\n\n    // Removes a key-value entry. If key is not present, UHashMap remains unchanged.\n    // docs:start:remove\n    pub unconstrained fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    slot.mark_deleted();\n                    self._table[index] = slot;\n                    self._len -= 1;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Apply UHashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % self._table.len()\n    }\n}\n\n// Equality class on UHashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, B, H> Eq for UHashMap<K, V, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    fn eq(self, other: UHashMap<K, V, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    // Safety: unconstrained context\n                    let other_value = unsafe { other.get(key) };\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, B, H> Default for UHashMap<K, V, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        // docs:end:default\n        UHashMap::with_hasher(B::default())\n    }\n}\n",
      "path": "std/collections/umap.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32, T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "46": {
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n",
      "path": "std/slice.nr"
    },
    "50": {
      "source": "use std::collections::umap::UHashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> UHashMap::default();\n\nunconstrained fn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nunconstrained fn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"UHashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"UHashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nunconstrained fn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"UHashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nunconstrained fn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"UHashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nunconstrained fn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for entry in input {\n        println(f\"Inserting {entry}\");\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    println(hashmap.len());\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"UHashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nunconstrained fn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"UHashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nunconstrained fn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"CtHashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"CtHashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nunconstrained fn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nunconstrained fn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib cthashmap documentation\nunconstrained fn doc_tests() {\n    // docs:start:default_example\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::default();\n    assert(empty_map.len() == 0);\n    println(empty_map.capacity());\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    let mut map2: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // Safety: testing context\n    let x = unsafe { map.get(12) };\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries[i];\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for key in keys {\n        // Safety: testing context\n        let value = unsafe { map.get(key) }.unwrap_unchecked();\n        println(f\"{key} -> {value}\");\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for value in values {\n        println(f\"Found value {value}\");\n    }\n    // docs:end:values_example\n}\n\nunconstrained fn iter_examples(\n    mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>,\n) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
