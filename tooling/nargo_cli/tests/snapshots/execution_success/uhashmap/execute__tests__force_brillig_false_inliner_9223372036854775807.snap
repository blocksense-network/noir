---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "4105629585450304037": {
        "error_kind": "string",
        "string": "UHashMap after one insert should have a length of 1 element."
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "6665645948190457319": {
        "error_kind": "string",
        "string": "CtHashMaps should be equal."
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "7511829951750337011": {
        "error_kind": "fmtstring",
        "length": 37,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "8082322909743101849": {
        "error_kind": "string",
        "string": "UHashMap after one insert and corresponding removal should be empty."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "13674703438729013973": {
        "error_kind": "string",
        "string": "UHashMap length is invalid."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14241324264716156348": {
        "error_kind": "string",
        "string": "CtHashMaps should not be equal."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16986922238178214607": {
        "error_kind": "string",
        "string": "UHashMap should have retained 2 elements."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, let N: u32, Env>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_loop<T, let N: u32, Env>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) {\n    let mut stack: [(u32, u32)] = &[(low, high)];\n    // TODO(https://github.com/noir-lang/noir_sort/issues/22): use 'loop' once it's stabilized\n    for _ in 0..2 * N {\n        if stack.len() == 0 {\n            break;\n        }\n\n        let (new_stack, (new_low, new_high)) = stack.pop_back();\n        stack = new_stack;\n\n        if new_high < new_low + 1 {\n            continue;\n        }\n\n        let pivot_index = partition(arr, new_low, new_high, sortfn);\n        stack = stack.push_back((pivot_index + 1, new_high));\n        if 0 < pivot_index {\n            stack = stack.push_back((new_low, pivot_index - 1));\n        }\n    }\n}\n\npub unconstrained fn quicksort<T, let N: u32, Env>(\n    arr: [T; N],\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = arr;\n    if arr.len() > 1 {\n        quicksort_loop(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "9": {
      "source": "use crate::cmp::Eq;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// An unconstrained hash table with open addressing and quadratic probing.\n// Note that \"unconstrained\" here means that almost all operations on this\n// map are unconstrained and importantly are not constrained afterward either.\n// This map is meant to be used in unconstrained or comptime code where this\n// is not an issue.\n//\n// Compared to the constrained HashMap type, UHashMap can grow automatically\n// as needed and is more efficient since it can break out of loops early.\npub struct UHashMap<K, V, B> {\n    _table: [Slot<K, V>],\n\n    // Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the UHashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, B> UHashMap<K, V, B> {\n    // Creates a new instance of UHashMap with specified BuildHasher.\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = &[Slot::default()];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    pub fn with_hasher_and_capacity<H>(_build_hasher: B, capacity: u32) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let mut _table = &[];\n        for _ in 0..capacity {\n            _table = _table.push_back(Slot::default());\n        }\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    // Clears the map, removing all key-value entries.\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = &[Slot::default()];\n        self._len = 0;\n    }\n\n    // Returns true if the map contains a value for the specified key.\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        // Safety: unconstrained context\n        unsafe { self.get(key) }.is_some()\n    }\n\n    // Returns true if the map contains no elements.\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    // Returns a BoundedVec of all valid entries in this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:entries\n    pub fn entries(self) -> [(K, V)] {\n        // docs:end:entries\n        let mut entries = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries = entries.push_back(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    // Returns a BoundedVec containing all the keys within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:keys\n    pub fn keys(self) -> [K] {\n        // docs:end:keys\n        let mut keys = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys = keys.push_back(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    // Returns a BoundedVec containing all the values within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:values\n    pub fn values(self) -> [V] {\n        // docs:end:values\n        let mut values = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values = values.push_back(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    // For each key-value entry applies mutator function.\n    // docs:start:iter_mut\n    pub unconstrained fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = f(entry.0, entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each key applies mutator function.\n    // docs:start:iter_keys_mut\n    pub unconstrained fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = (f(entry.0), entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each value applies mutator function.\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..self._table.len() {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    // Retains only the elements specified by the predicate.\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..self._table.len() {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    // Amount of active key-value entries.\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    // Get the current capacity of the inner table.\n    // docs:start:capacity\n    pub fn capacity(self: Self) -> u32 {\n        // docs:end:capacity\n        self._table.len()\n    }\n\n    // Get the value by key. If it does not exist, returns none().\n    // docs:start:get\n    pub unconstrained fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, value) = slot.key_value_unchecked();\n                if current_key == key {\n                    result = Option::some(value);\n                    break;\n                }\n            }\n        }\n\n        result\n    }\n\n    // Insert key-value entry. In case key was already present, value is overridden.\n    // docs:start:insert\n    pub unconstrained fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.try_resize();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n            let mut insert = false;\n\n            // Either marked as deleted or has unset key-value.\n            if slot.is_available() {\n                insert = true;\n                self._len += 1;\n            } else {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    insert = true;\n                }\n            }\n\n            if insert {\n                slot.set(key, value);\n                self._table[index] = slot;\n                break;\n            }\n        }\n    }\n\n    unconstrained fn try_resize<H>(&mut self)\n    where\n        B: BuildHasher<H>,\n        K: Eq + Hash,\n        H: Hasher,\n    {\n        if self.len() + 1 >= self.capacity() / 2 {\n            let capacity = self.capacity() * 2;\n            let mut new_map = UHashMap::with_hasher_and_capacity(self._build_hasher, capacity);\n\n            for entry in self.entries() {\n                new_map.insert(entry.0, entry.1);\n            }\n            *self = new_map;\n        }\n    }\n\n    // Removes a key-value entry. If key is not present, UHashMap remains unchanged.\n    // docs:start:remove\n    pub unconstrained fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    slot.mark_deleted();\n                    self._table[index] = slot;\n                    self._len -= 1;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Apply UHashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % self._table.len()\n    }\n}\n\n// Equality class on UHashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, B, H> Eq for UHashMap<K, V, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    fn eq(self, other: UHashMap<K, V, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    // Safety: unconstrained context\n                    let other_value = unsafe { other.get(key) };\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, B, H> Default for UHashMap<K, V, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        // docs:end:default\n        UHashMap::with_hasher(B::default())\n    }\n}\n",
      "path": "std/collections/umap.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32, T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "46": {
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n",
      "path": "std/slice.nr"
    },
    "50": {
      "source": "use std::collections::umap::UHashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> UHashMap::default();\n\nunconstrained fn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nunconstrained fn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"UHashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"UHashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nunconstrained fn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"UHashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nunconstrained fn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"UHashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nunconstrained fn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for entry in input {\n        println(f\"Inserting {entry}\");\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    println(hashmap.len());\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"UHashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nunconstrained fn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"UHashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nunconstrained fn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"CtHashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"CtHashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nunconstrained fn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nunconstrained fn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib cthashmap documentation\nunconstrained fn doc_tests() {\n    // docs:start:default_example\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::default();\n    assert(empty_map.len() == 0);\n    println(empty_map.capacity());\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    let mut map2: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // Safety: testing context\n    let x = unsafe { map.get(12) };\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries[i];\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for key in keys {\n        // Safety: testing context\n        let value = unsafe { map.get(key) }.unwrap_unchecked();\n        println(f\"{key} -> {value}\");\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for value in values {\n        println(f\"Found value {value}\");\n    }\n    // docs:end:values_example\n}\n\nunconstrained fn iter_examples(\n    mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>,\n) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
