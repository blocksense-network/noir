---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12435520423058260345": {
        "error_kind": "string",
        "string": "borrow_mut_two should create a fresh array and not decrease its RC"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "50": {
      "source": "use std::mem::array_refcount;\n\nfn main() {\n    let mut array = [0, 1, 2];\n    assert_refcount(array, 1);\n\n    borrow(array, array_refcount(array));\n    borrow_mut(&mut array, array_refcount(array));\n    let _ = copy_mut(array, array_refcount(array));\n\n    borrow_mut_two(&mut array, &mut array, array_refcount(array));\n\n    let mut u32_array = [0, 1, 2];\n    let rc1 = array_refcount(array);\n    let rc2 = array_refcount(u32_array);\n    borrow_mut_two_separate(&mut array, &mut u32_array, rc1, rc2);\n\n    // Safety: test\n    regression_7297();\n}\n\nfn borrow(array: [Field; 3], rc_before_call: u32) {\n    assert_refcount(array, rc_before_call);\n    println(array[0]);\n}\n\nfn borrow_mut(array: &mut [Field; 3], rc_before_call: u32) {\n    // Optimization: inc_rc isn't needed since there is only one array (`array`)\n    // of the same type that `array` can be modified through\n    assert_refcount(*array, rc_before_call + 0);\n    array[0] = 3;\n    println(array[0]);\n}\n\n// Returning a copy of the array, otherwise the SSA can end up optimizing away\n// the `array_set`, with the whole body just becoming basically `println(4);`.\nfn copy_mut(mut array: [Field; 3], rc_before_call: u32) -> [Field; 3] {\n    assert_refcount(array, rc_before_call + 1);\n    array[0] = 4;\n    println(array[0]);\n    array\n}\n\n/// Borrow the same array mutably through both parameters, inc_rc is necessary here, although\n/// only one is needed to bring the rc from 1 to 2.\nfn borrow_mut_two(array1: &mut [Field; 3], array2: &mut [Field; 3], rc_before_call: u32) {\n    assert_refcount(*array1, rc_before_call + 1);\n    assert_refcount(*array2, rc_before_call + 1);\n    array1[0] = 5;\n    array2[0] = 6;\n    println(array1[0]); // array1 & 2 alias, so this should also print 6\n    println(array2[0]);\n}\n\n/// Borrow a different array: we should be able to reason that these types cannot be mutably\n/// aliased since they're different types so we don't need any inc_rc instructions.\nfn borrow_mut_two_separate(\n    array1: &mut [Field; 3],\n    array2: &mut [u32; 3],\n    rc_before_call1: u32,\n    rc_before_call2: u32,\n) {\n    assert_refcount(*array1, rc_before_call1 + 0);\n    assert_refcount(*array2, rc_before_call2 + 0);\n    array1[0] = 7;\n    array2[0] = 8;\n    println(array1[0]);\n    println(array2[0]);\n}\n\nfn assert_refcount<T>(array: [T; 3], expected: u32) {\n    let count = array_refcount(array);\n\n    // All ref counts are zero when running this as a constrained program\n    if std::runtime::is_unconstrained() {\n        if count != expected {\n            // Brillig doesn't print the actual & expected arguments on assertion failure\n            println(f\"actual = {count}, expected = {expected}\");\n        }\n        assert_eq(count, expected);\n    } else {\n        assert_eq(count, 0);\n    }\n}\n\nfn regression_7297() {\n    let mut array = [0, 1, 2];\n\n    let refcount_0 = array_refcount(array);\n    borrow_mut_two(&mut array, &mut array, refcount_0);\n    let refcount_1 = array_refcount(array);\n    let array_2 = copy_mut(array, refcount_1);\n    let refcount_2 = array_refcount(array);\n\n    // Mutation of the original could occur if we double decremented the RC and then went back to 1 by accident.\n    // For this to come out we have to run the test with `--inliner-aggressiveness -9223372036854775808`\n    assert_eq(array[0], 6, \"the original should not be mutated by copy_mut, only borrow_mut_two\");\n    assert_eq(array_2[0], 4, \"the copy should have the expected content\");\n\n    if std::runtime::is_unconstrained() {\n        // Double decrementing the RC could occur if we don't realize that array mutation made a copy,\n        // which decreases the RC of the original and sets the new one to 1.\n        // This assertion is redundant with the one following it, but it's here because `assert_eq` doesn't print\n        // what actual values that cause it to fail, so this is a way to highlight the bug about the refcount of\n        // still live arrays going to zero, without any doubt that it's just not 1, as it should be.\n        assert(\n            refcount_1 != 0,\n            \"borrow_mut_two should create a fresh array and not decrease its RC\",\n        );\n\n        // Difference from min & 0 inliner settings: we fail to remove an inc_rc here\n        assert_eq(refcount_1, 2);\n        assert_eq(refcount_2, refcount_1);\n    }\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
