---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "struct Bar {\n    inner: [Field; 3],\n}\n\nstruct Foo {\n    a: Field,\n    b: [Field; 3],\n    bar: Bar,\n}\n\nfn main(y: Field) {\n    let foo_one = Foo { a: 1, b: [2, 3, 20], bar: Bar { inner: [100, 101, 102] } };\n    let foo_two = Foo { a: 4, b: [5, 6, 21], bar: Bar { inner: [103, 104, 105] } };\n    let foo_three = Foo { a: 7, b: [8, 9, 22], bar: Bar { inner: [106, 107, 108] } };\n    let foo_four = Foo { a: 10, b: [11, 12, 23], bar: Bar { inner: [109, 110, 111] } };\n    let mut x = &[foo_one];\n    x = x.push_back(foo_two);\n    x = x.push_back(foo_three);\n    x = x.push_back(foo_four);\n\n    assert(x[y - 3].a == 1);\n    assert(x[y - 3].b == [2, 3, 20]);\n    assert(x[y - 2].a == 4);\n    assert(x[y - 2].b == [5, 6, 21]);\n    assert(x[y - 1].a == 7);\n    assert(x[y - 1].b == [8, 9, 22]);\n    assert(x[y].a == 10);\n    assert(x[y].b == [11, 12, 23]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n\n    if y != 2 {\n        x[y - 2].a = 50;\n    } else {\n        x[y - 2].a = 100;\n    }\n    assert(x[y - 2].a == 50);\n\n    if y == 2 {\n        x[y - 1].b = [50, 51, 52];\n    } else {\n        x[y - 1].b = [100, 101, 102];\n    }\n    assert(x[2].b == [100, 101, 102]);\n\n    assert(x[y - 3].bar.inner == [100, 101, 102]);\n    assert(x[y - 2].bar.inner == [103, 104, 105]);\n    assert(x[y - 1].bar.inner == [106, 107, 108]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
