---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/+VdS4hkVxk+dW/VVN/q6q7qR6bnkZnuSXp6HkkmVV093ZOFMJgeQd0IWQqBnk4GA2Ik4MaNhQjiSlBwIYI7dSMJLlxl6ULEhbgQFMGNkI3gyoWgYm76/lVfffXX37emz1/VSQ4U93HO/R/f+R/33Drn3koYlkqxrdJxUNo8LLads5VuRFodVVCrSJv30pNtVhwnUJ9GVDYjvjHpP+jsHWSKfhHl72UFTU98hKYD/U69oPO5/pA+65KXpeIYbUiuWfjw1wzD/Xaxn9E1Hn3riH1nTZE/Ad3y8mp/WBdCfL847LvoNqD/yId+b7GwhbfSUVsQ/CJitcs+EpH2wL+r0Wl398SnakBb7Ej4Xggu/bNXIX4hjMaYQPwbJGtse6wQP5GH8RH7EezqiqxtpQ5jBNYhn7rCR6OVRqQlduVnZ/t7bEsRad/PFH0j0d6XPl4A2uwfGfVLHN7l/UP4N0hWL//ISB7Gh/2jocjaVurwBhfrkE9D4aPRuhCRltiVnw13HG24s892Go929/6SgiX7xyKcn4d/CP+G0rce/rFI8kyyNcGuqcjaVurYppsKn6bCR6NVj0hL7Moxxh84xvgHfv6x/4r0MdoE+wdiOQ//EP6N4OqvXcvWEB/2jyVF1rZSx/6xpPBZUvhotOoRafn7R+eBY/54xTF/7HMMFMwQL8RyHv4h/BvB1V+7lq1psViwW1ZkbSt17B/LCp9lhY9Gqx6R1gzyx5Fj/njsmD+OOQYKZogXYjkP/xD+jeDqr13L1rRYLNi1FFnbSh37R0vh01L4aLTqEWnNIH88dswfx47544BjoGCGeCGW8/AP4d8Irv7atWxNi8WCXVuRta3UsX+0FT5thY9Gqx6R1gzyxxuO+eNNx/zxhGOgYIZ4IZbz8A/h3wiu/tq1bE2LxYLdiiJrW6lj/1hR+KwofDRa9Yi0MtIH/aMyYSt8+Bz+9+SUL7p+/tDZY5uPSHvwjGIlPu3B/esa9ElE3xjk6Gd86PfEjtfDqH2xTsJfbHUV2k9jq8irQbS84oqmG8rPProO8iAGk2itT0krU+o8+nTN0Bv5LxmyanrUI2JSi0hrISKtLCKtRkRaixFptSPSakaktRSR1kpEWssRafH9PN6jcGzlGISxNCX+6YTr8vPOuWqPcamdIleN2v+q2OZ+/HY6qvM6YMo08/Kof7IVHS/66DiIrc8Aby22In88xvaY00W/VhjHi2lpvNHuDvujWFxyxmIj2FhcIvkvKe03oM0zhMVFhVamXBdRt11LVvTjDZLnijPWl4ON9RXC+orS/rKCZ0vR7QrV4XUXZ6N3R/S4WtCrgh7IU2RLqD3u56VG535bbPOY8w7FnMsGdsIrL+0wbqeXDezWCburztg9G8axu2pg9yzUyT5iJ+f+EOJht67Iw8c1wEjq6lQnbf9UbDNFp5gYo+8F4mXF8iyM28Ws+p555mXavv9rsdX6HvOylqstv0kN7NhvvPpU9LgWxrF7NkzG7hrUyT5iJ+f+HuJhx2PISdjVCDunsaeJ3XoE7P4R4mHH81URn2su+HTflLH29TBepG4TeF+kui2oQ/m5pHSMOuXYfSMd0uV2LA/akcjGsfjfxTYLOrYPi+POGYsWb3mONMpbobYJ4DPJBipQj+drE65bm4DJ/4qtNp5B+2eaeXnUP9n62uPwvlIbnyDWyJ99NA2nx/GaQUvjjfZ72B/FYtMZi+unYLFJ8m8q7a9Dm4uExTWD1nUDi3yfxxs3nLHYCjYWN0j+G0r7LWhznbDYVGi1lOuuzUbvQf56rqCH+Qt5imwJtcf9vNTo3FoRjLT8tRUmYye88tIO43a0ZWC3Sdg954zd82Ecu+fCZOyehzrZR+zk3NWI2G0q8vCx8MfYlVGdtL1RyJYpOnnnP+FlxVrnNREd7gfse+QpsiVh3E5lX8P3ltH3mDe1XGr5Tc3Ajv1mC+pm5TdbYTJ2Zf3m5YjYbZbErkHYefmD6LEdxrF73sBuG+pkH7GTcwcRsWso8mSKPPHw2R2sA7kZxovU7QDva1R3C+pQfi4pHaNO04430I5ENo7FhxRvndaOqPGW19Twf5jYtg744DFfh+ONGuisXbc2AZPPg62+PcFWE4VmXh71T7a+9ji8r9TWfSHWyJ99NA2T/aml4MW0NN7ot4f9USx2nLG4eQoWOyT/jtL+JrRpEBbbBq2bBhb5Po83bjljsXMKFrdI/ltKe9TxJmFRU2i1lOu2Z6P3IH/dLuhh/kKeIltC7XE/hGFMkHOvG/lrx8BOeOWlHSbbkYYd57bbztjdCePY3TawuwN1so/YybknEbHTchofC3+MXW2qk7ZfpfyHOnnnP+FlxVrnOawd7gfse20+cxLG7RT7gfF9x+j7adf0byvyaNix3zjlHdNvdgzsyvrNNyNiVzOww7omYVefA3ZaX06L3bcN7KYdbzQVeXzjxe6R3MPfDeNF6l4A3ttU9yLUofxctPGG6HSW8YbIxvfW36d467TWUI23TdCZ5a2QHBW6pux/FtL+h2B/PIaQNmX/s/AeQ5w2v7XMGALnwol+WnxhWhpvXAt62B/F4q4zFndOweIuyX9XaY8xYY2w2DZo3TGwyPd5DOGNxWnz0cpggfPK+H6nqdBqKddtz0bvQU6S2IU56a7SD0kYj8Oyn5canfuFkZM2DOyEV160e6ENAzvO5y84Y/eigt0LBnaYp2QfsZNz70XETvMpPtb+s1ihOmn7a8ppqJN3ThNeVqzldTtefS94YN8jT76X21Bw1/B93+j7ae/lthV5ytwHO82PNf1mw8CurN/8JiJ2zZLYLRN2Xv4gerwUxrF70cDuJaiTfcROzv0+InbLijyZIk/EMcRgjtS9MF6k7mXgzWOIDtSh/Fy0MYTodJYxhMjGsfjPFG+d1pur8VZ4lYm3XnJZdq/Z2bR2/7dzEG+dxjwmdtsRsPtgDvG2Rdj5xJMhdvcU7F4ysLsHdfcU7OTcPyNi11LkyRR5IsbbJxxTsWgxtUl1XahD+blo8VZ0Oku8Fdk43v6H4u08ntkEkklkxLYJ7GNdCONzK/Ny2B/VK4G6h1F06u0ylpcKJvk6xUqxL/2U9ofyCxZ5f/4I+jOvw/fXVkkHp3lJg2cC2nNnfK8pr/fNlPbae37byvXSHxo+VQOfuoGPk+32yurL63u1dwUiBhcJH7we55gwPnUDn+o5w6d6BnwqBj6bVIdrg4Vnfu7lp/TDT5KdsR82Faw+zXb2tH74aYlTT+uHwhP9sEU08Zp55jmU52nznOim5cyPq268LiM1dJuHXaNu09o1r7PQfESz15T0durTDusxab64yJYoOCAG/D/mZwuf1MZklTCOHZ7jMVmqyKNhx++jT+eAXRoBuy9ExI7fFRSUY+GPsSWhOmn7paLCe56HNqZjXTQscG7pYX9UBxlLfR3GUq9R7sCxIOeOmo+ugxhUVfRBeXjegfZsA/vwZhjVLVVoaXllYTZ6dzivoB8hT5EtCeN2gDmJ5++9bvhR1cBOeOWlTZhgO+2+Ta77pI+/G4QPXr9g4GPd1ybnDJ/kDPhUDHx4zIT3tcIzP/cDik3ovxybnOJwz4o1KA/rruGJPs2xqarQyhTeD6Po1etlipyRaA++HYY2UiGdztu3LZz8y/y2BeKDz+zyumVFVu0/UX52e5b37dci0qqDPh9d3x/WSX9MGwPn4eOJolNZH+ccgddnBj5WDk3PGT5niYEVA58q1fG3BkPQcwT6OOeIxAefI+ueCuUR/lo+q85G1sdWX1qyYn7ie2eWFfXwvneWPp507yyyJWHcjvB91zU691Pj3jlRsMNz1vg9MbBjG3D6vqY57rhgYFd23PHziNhVS2LHY7bqHLCrRsDu3YjYLSjy+OaK6ddfpFSH889Qfi4pHaNO0/6Xj3bE6y+k7n167uP1bE177sMx1TvPp4RzheQpk+cRH36fqnZP9XF9hs/vL9We4WvPwJPZ6F36OTevtSv7rPZ3Rryadq2dZhdl7jG819pp2Gl9OS12f5zDPQbnSa85SaLHsoJd08AOx5DLCnZy7i8zypM+c1HnmydFJ488+cE5ypNO37sunSeRPx5je8SH/w+2/NZpjnTPkhV1428RaM+KUH/+PzhVaLXCvPxxGK9k7f6kueEiW0LtcT8vNTr3LyNeLRjYCa8Q9Dy5QNhZedLJH0zstL6cFrv/ziFPLhJ23u+RWFGwaxvY4fqwFQW7wZq7NB52i4o8vmvk4uZJlJ+LlidFJ488uVrQOw950um73qXzJH9TaFFpj/jw+6Usv/XWrRFBN3yPmDVnYZHq8LpkNnqb8Qp5imzTxqstI141DOyEV160PGnZDPuD17v8LOy0vpwWu9sRY33ZPLlE2HmvlV5VsFsxsMP4t6pgJ+c6EbFbUuTJFHnOa55E+bloeRLn+sfOk585R3nS6fvlpfMkf5duSWmP+PA7VCy/dfoGZs+SFXVbJd1Wlfao/x3SLVVoaf8Jsz869akZr7gfQ5g+Xn3RiFcVBTs8Z+XJioEd+0MyB+ySCNi9FhG7NJTDjtcaO/nbALs1BbvVMBk7fA/VmoKdnPtyROxaijyZIk88fLp7/K1ZLFLH3zrGOvzGyLRrjUWnafMk2pHIxvPSv3IO8uRiGP6nVO3H53/w4MS+P8K3P8SBsUb+NWr/taJxQ9GjegY5nxwcdZ/0jp4c3T9644294yPGKS8J4BSb//H9/cfHe/ePOm9288PdWfM/Oug9ON7dOz54fL931Ns/Vf/cB94CHxD+QZGL6aQG7bZC69X+yVZ7BwTHnXnPueF3QJSdN/ItIy5P+w6IiiKP93wunt+IvHJ8vjNBp1oYv/fNy6N+GMFJ2n8vHdL8brGv5Wuxn8Wg2w3O9eG+sXKfnNee+VvrHtFGyvyvlBi8tTkNCwZvbd4qy1JT5OR5IhcUeWoKLW3u1wWiZc1Fzcth/2Rb1q4kl9f6QLc/vOaj9sVxFehhe9GrRu1/DDb3E8r7VYVf3u5dyOd5WQBZIvrdruhWRzlIHuTfUtrLvrOsPUvWuiKrhvG0eaXeHz2X9cfbI0514t3A9lS3CHVV4tMsjtHWkJbIUaP2vyR7XoBr5Pq2wh/7jHlp/NGHmVaqnJP2uW3/jO7BqsA7or100Y/yOP5/5fzSGj2lAAA=",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "struct Bar {\n    inner: [Field; 3],\n}\n\nstruct Foo {\n    a: Field,\n    b: [Field; 3],\n    bar: Bar,\n}\n\nfn main(y: Field) {\n    let foo_one = Foo { a: 1, b: [2, 3, 20], bar: Bar { inner: [100, 101, 102] } };\n    let foo_two = Foo { a: 4, b: [5, 6, 21], bar: Bar { inner: [103, 104, 105] } };\n    let foo_three = Foo { a: 7, b: [8, 9, 22], bar: Bar { inner: [106, 107, 108] } };\n    let foo_four = Foo { a: 10, b: [11, 12, 23], bar: Bar { inner: [109, 110, 111] } };\n    let mut x = &[foo_one];\n    x = x.push_back(foo_two);\n    x = x.push_back(foo_three);\n    x = x.push_back(foo_four);\n\n    assert(x[y - 3].a == 1);\n    assert(x[y - 3].b == [2, 3, 20]);\n    assert(x[y - 2].a == 4);\n    assert(x[y - 2].b == [5, 6, 21]);\n    assert(x[y - 1].a == 7);\n    assert(x[y - 1].b == [8, 9, 22]);\n    assert(x[y].a == 10);\n    assert(x[y].b == [11, 12, 23]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n\n    if y != 2 {\n        x[y - 2].a = 50;\n    } else {\n        x[y - 2].a = 100;\n    }\n    assert(x[y - 2].a == 50);\n\n    if y == 2 {\n        x[y - 1].b = [50, 51, 52];\n    } else {\n        x[y - 1].b = [100, 101, 102];\n    }\n    assert(x[2].b == [100, 101, 102]);\n\n    assert(x[y - 3].bar.inner == [100, 101, 102]);\n    assert(x[y - 2].bar.inner == [103, 104, 105]);\n    assert(x[y - 1].bar.inner == [106, 107, 108]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
