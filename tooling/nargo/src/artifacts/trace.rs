use serde::{Deserialize, Serialize};
use serde_with::skip_serializing_none;

// This represents a CodeTracer trace, as generated by `nargo trace`.
#[derive(Clone, Serialize, Deserialize, Debug)]
pub struct TraceArtifact {
    program: String,
    args: Vec<String>,
    workdir: String,
    pub calls: Vec<CallRecord>,
    pub steps: Vec<StepRecord>,
    variables: Vec<Vec<VariableRecord>>,
    types: Vec<TypeRecord>,
    events: Vec<EventRecord>,
    paths: Vec<String>,
}

impl TraceArtifact {
    pub fn new() -> TraceArtifact {
        TraceArtifact {
            program: String::from(""),
            args: Vec::new(),
            workdir: String::from(""),
            calls: Vec::new(),
            steps: Vec::new(),
            variables: Vec::new(),
            types: Vec::new(),
            events: Vec::new(),
            paths: Vec::new(),
        }
    }

    pub fn add_step(&mut self, step: StepRecord) {
        self.steps.push(step);
    }

    pub fn add_vars(&mut self, vars: Vec<VariableRecord>) {
        self.variables.push(vars);
    }

    pub fn add_call(&mut self, call: CallRecord) {
        self.calls.push(call);
    }

    pub fn add_type(&mut self, typ: TypeRecord) {
        self.types.push(typ);
    }

    pub fn get_next_call_id(&mut self) -> usize {
        self.calls.len()
    }

    pub fn add_or_get_filepath_id(&mut self, filepath: String) -> usize {
        // Note: stanm: some easy optimizations can be performed here.
        match self.paths.iter().position(|p| *p == filepath) {
            Some(id) => id,
            None => {
                self.paths.push(filepath);
                self.paths.len() - 1
            }
        }
    }
}

#[derive(Clone, Serialize, Deserialize, Debug)]
pub struct CallRecord {
    pub key: usize,
    pub path_id: usize,
    pub line: usize,
    pub name: String,
    pub args: Vec<VariableRecord>,
    pub return_value: ValueRecord,
    pub step_id: usize,
    pub depth: usize,
    pub parent_key: isize,
}

#[derive(Clone, Serialize, Deserialize, Debug)]
pub struct StepRecord {
    pub step_id: usize,
    pub path_id: usize,
    pub line: usize,
    pub call_key: usize,
}

pub type VariableRecord = (String, ValueRecord);

#[skip_serializing_none]
#[derive(Clone, Serialize, Deserialize, Debug)]
pub struct ValueRecord {
    // type name, e.g. String or Int
    pub kind: String,
    // type index?
    pub ti: usize,
    // In case of int: the value
    pub i: Option<usize>,
    // In case of bool: the value
    pub b: Option<bool>,
    // In case of string: the value
    pub text: Option<String>,
    // In case of "Sequence": the value
    pub elements: Option<Vec<ValueRecord>>,
}

#[derive(Clone, Serialize, Deserialize, Debug)]
pub struct TypeRecord {
    pub kind: usize,
    pub lang_type: String,
}

#[derive(Clone, Serialize, Deserialize, Debug)]
pub struct EventRecord {}
